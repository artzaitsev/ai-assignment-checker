candidate_id,file_name,ext,parser,text,error
1,01042.docx,.docx,docx,"Стоит поменять тип поля age на тип date и добавлять туда информацию о дате рождения, так как возраст каждый год меняется.
Необходимо добавить историчность в данную сущность. Можно использовать для этого SCD второго типа.
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) as TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID is NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE upper(CITY) = 'SEOUL')
GROUP BY DEPARTMENT_NAME, DEPARTMENT_ID
Having SUM(SALARY) >= 100000
Например карандаш лежит у самой стены.",
2,100.docx,.docx,docx,"Ответ
Комментарии по имеющимся столбцам
client_id можно сразу тип данных integer. Удобно, можно формировать автоматически, меньше памяти по сравнению с другими способами задавать id. Минус – легко угадываемые idшки других покупателей, легко понять, сколько покупателей. Если это важно учесть, а также если планируется очень большое число пользователей, можно использовать строковые id, содержащие и другие символы (varchar, GUID, base). Not Null. Primary key
client_name and client_surname можно всё-таки меньше, вплоть до varchar(50). На запись значений не повлияет, повлияет на выделение памяти. Решение зависит от того, какие именно имена будут храниться, это бизнесовый вопрос. Также бизнесовый о целесообразности создания для отчества/доп.части полного имени, т.к. полное официальное имя может использоваться при передаче в доставку, можно хранить не в этой таблице, можно вообще не хранить. Not Null/Null уточняется бизнесом.
Login 30 хорошее ограничение. Зачем интернет-магазину вход пользователя по логину – отдельный вопрос, мб авторизация по телефону/почте будет лучше. Не хватает ссылки на хешированный пароль в пару к логину. Нужен триггер на уникальность. Not Null
City_id хорошо, что есть справочник городов. Нужно ли хранить город проживания клиента, вопрос к бизнесу, будут ли они делать такую аналитику, т.к. в таблице заказов в любом случае будет ссылка на город заказа. Null
Age не нужен, нужна Date of birth Date Not Null. Возраст – величина, меняющаяся каждый год, её проще рассчитывать от даты, чем постоянно обновлять.
Reg date DATETIME not null
Можно добавить поля
Last login DATETIME not null для антифрода и бизнесовых акций/отчётов
Mobile VARCHAR(15) null
Mail VARCHAR(50) null
Адрес добавлять не предлагаю, т.к. по одному клиенту скорее всего нужно хранить несколько адресов доставки, давая пользователю выбрать конкретный адрес в момент заказа. В справочнике адресов будет ссылка по id клиента.
Дополнительно, решался ли вопрос о хранении общей инфы по юзерам сайта вместе (так можно назначать роли/ставить флаги), с выделением особенных полей в отдельные таблицы (customers, employees, vendors etc)
Ответ
Вопрос о подходящем типе работы с версионностью.
Допустим, историю изменения цены на продукт храним в отдельной таблице
Product_price_hist
Id INT PK
Product_id INT FK
Date_start DATETIME
Date_end DATETIME
Inserted DATETIME – если нужно следить, когда внесли запись
Price numeric
Для иллюстрации идеи нашла картинку из другой БД
Отдел финансов отчёты строить будет на основе таблицы фактов продаж, где будет ID продукта и дата продажи, соответственно определится цена по связям с таблицей Product_price_hist.
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.MANAGER_ID IS NULL (= NULL неверно)
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME (если столбец не агрегировался функцией, что в селекте, то и группируем)
HAVING SUM(E.SALARY) > 100000; (агрегирующие функции мы используем с HAVING, а не WHERE)
Возможные проверки:
Все объекты (комната, карандаш, я) материальны?
Комната больше меня, я больше карандаша?
Я могу прыгать вообще?
Я в одной комнате с карандашом?
Пол в комнате допускает возможность прыжка?
Я могу прыгнуть больше длины карандаша?
На пути прыжка нет препятствий?
При хотя бы одном ответе нет я не могу перепрыгнуть. При всех ответах да проверка пройдена, перепрыгивание возможно.",
3,101.docx,.docx,docx,"Задание 1
Предлагаемые мной изменения:
1. client_id:
- Изменить тип данных с `number` на `BIGINT`.
- Добавить `PRIMARY KEY AUTO_INCREMENT`.
- Причина изменения:
`BIGINT` лучше подходит для уникальных идентификаторов, особенно при большом количестве записей, так как он эффективно хранит целые числа.
‘PRIMARY KEY’ гарантирует уникальность ‘client_id’ в таблице.
‘AUTO_INCREMENT’ автоматически генерирует новое уникальное значение для каждого клиента, исключая необходимость ручного ввода.
2. client_name:
- Уменьшить размер с `varchar(255)` до `varchar(100)`.
3. client_surname:
- Уменьшить размер с `varchar(255)` до `varchar(100)`.
- Причина изменений client_name и client_surname:
Имена и фамилии обычно не превышают 100 символов, следовательно, использование большего количества символов может быть избыточно, что приведет к неоправданному расходу памяти
4. city_id:
- Добавить внешний ключ:
FOREIGN KEY (city_id) REFERENCES cities(city_id)
- Причина изменения:
Внешний ключ обеспечит целостность данных, гарантируя, что значение `city_id` в таблице `clients` соответствует существующему значению в таблице `cities`.
5. age:
- Добавить ограничение:
CHECK (age BETWEEN 0 AND 150)
- Причина изменения:
Ограничение гарантирует, что возраст клиента находится в допустимом диапазоне (от 0 до 150 лет), предотвращая некорректные данные.
6. reg_date:
- Изменить тип данных с `date` на `datetime`.
- Причина изменения:
Тип `date` хранит только дату в формате YYYY-MM-DD, в то время, как `datetime` позволяет хранить как дату, так и время регистрации, что полезно, если точное время события важно для бизнес-логики.
clients (
client_id BIGINT PRIMARY KEY AUTO_INCREMENT, -- уникальный id клиента
client_name varchar(100), -- имя клиента
client_surname varchar(100), -- фамилия клиента
login varchar(30), -- логин, который придумал клиент
city_id number, -- id города, который указал клиент
age number CHECK (age BETWEEN 0 AND 150), -- возраст клиента
reg_date datetime -- дата и время регистрации на сайте
);
-- Добавление внешнего ключа
ALTER TABLE clients
ADD FOREIGN KEY (city_id) REFERENCES cities(city_id);
Задание 2
1. Таблица с основной информацией о товаре:
items (
item_id NUMBER PRIMARY KEY, -- Уникальный ID товара
item_name VARCHAR(255) NOT NULL -- Название товара
);
2. Таблица с историей изменения цен:
item_prices (
price_id NUMBER PRIMARY KEY, -- Уникальный ID записи
item_id NUMBER NOT NULL, -- Ссылка на товар
item_cost NUMBER NOT NULL, -- Стоимость товара
valid_from DATE NOT NULL, -- Дата начала действия цены
valid_to DATE -- Дата окончания действия цены (NULL, если текущая цена)
-- Внешний ключ
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Как работает:
Каждый раз при изменении цены для товара создается новая запись в item_prices.
Старой записи устанавливается valid_to = <дата начала новой цены> - 1.
Текущая цена — это запись с valid_to IS NULL.
Задание 3
MANAGER_ID = NULL — нужно использовать IS NULL.
SUM(SALARY) >= 100000 — агрегатные функции нельзя использовать в WHERE, нужно в HAVING.
В SELECT есть DEPARTMENT_ID, но в GROUP BY он не указан.
Устаревший стиль JOIN, лучше использовать JOIN ... ON.
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN
LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
Задание 4
Через карандаш перепрыгнуть нельзя, потому что он упал к стене.",
4,102.docx,.docx,docx,"Тестовое задание
Вера Судник
Задание 1
Мой код
CREATE TABLE clients (
client_id number PRIMARY KEY NOT NULL,
client_name varchar(100) NOT NULL,
client_surname varchar(100) NOT NULL,
phone_number varchar(50) NOT NULL,
email varchar(255) NOT NULL,
login varchar(30) UNIQUE NOT NULL,
address TEXT NOT NULL,
city_id number,
birth_date DATE,
reg_date date NOT NULL);
Описание исправлений
поле client_id должно быть уникальным и являться PRIMARY KEY;
во избежание отправки и хранения пустых полей вводим ограничение NOT NULL;
поле login должно быть уникальным (UNIQUE), чтобы предотвратить дублирование логинов;
количество символов varchar можно где-то сократить до 100, для оптимизации места в БД;
добавила поля с номером телефона, адресом и почтой;
поле age лучше заменить на birth_date, так как возраст меняется с течением времени.
Задание 2
Мой код
CREATE TABLE items (
item_id NUMBER PRIMARY KEY NOT NULL,
item_name VARCHAR2(255) NOT NULL,
category_id BIGINT FOREIGN KEY NOT NULL,
price NUMBER (10,2) NOT NULL,
previous_price NUMERIC(10,2) DEFAULT NULL,
is_actual BOOLEAN NOT NULL,
load_dttm TIMESTAMP NOT NULL);
Описание исправлений
поле item_id должно быть уникальным и являться PRIMARY KEY;
во избежание отправки и хранения пустых полей ввела ограничение NOT NULL;
добавила внешний ключ к таблице категорий;
добавила is_actual и логическое значение BOOLEAN, чтобы определять является ли текущая запись актуальной;
добавила временную метку, указывающую на момент загрузки или создания записи;
Задание 3
Мой код
SELECT d.department_id,
d.department_name,
SUM(e.salary) AS total_salary
FROM employee e,
departments d
INNER JOIN (SELECT location_id
FROM locations
WHERE city = 'SEOUL') t(location_id) ON d.location_id = t.location_id
WHERE e.department_id = d.department_id
AND e.manager_id IS NULL
GROUP BY department_id, department_name
HAVING SUM(e.salary) >= 100000
Описание исправлений
для проверки значений на NULL используется оператор IS NULL, а не = NULL;
SUM(SALARY) >= 100000 должно быть в HAVING, а не в WHERE. SUM является агрегированной функцией и не может быть использована в условии WHERE;
в GROUP BY нужно использовать идентификатор отдела (DEPARTMENT_ID)
Задание 4
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?

Нужно выяснить в какой комнате и где конкретно лежит этот карандаш, а потом уже прыгать.",
5,103.docx,.docx,docx,"Изучая таблицу, оставленную прошлым Дата-инженером, можно выделить следующие моменты:
client_id – используемый тип данный number, что является не самым лучшим выбором для значения id, которое является PRIMARY KEY для данной таблицы. Разумнее использовать целочисленный int, который бы явно отражал, что данное поле имеет уникальные значение.
client_name и client_surname – сейчас допустимая длина имени составляет 255 символов, что является избыточным для этих значений. Можно сократить до 50 символов varchar(50).
Login – возможно, что вместо логина можно использовать email клиента, но, если структура интернет-магазина основывается на логине.
age – возраст клиента лучше изменить на дату рождения клиента и при необходимости вычислять значение возраста исходя неё.
reg_date – можно заменить тип данных на datetime, чтобы хранить точную дату регистрации.
Можно добавить дополнительные поля:
email varchar(255) – для хранения почты клиента.
ctn varchar(15) – для хранения телефона клиента.
gender char(1) – хранить и знать пол клиента достаточно важно, так как это позволит проводить точечные рекламные кампании.
Также необходима проверка значений Логина, почты и телефона на уникальность.
Хранение исторических данных о ценах на товар можно реализовать с помощью дополнительной таблицы.
CREATE TABLE item_prices (
price_id INT PRIMARY KEY, – уникальный id записи цены
item_id number NOT NULL, – внешний ключ на таблицу items
item_cost NUMBER NOT NULL, – стоимость товара
start_date DATE NOT NULL, – дата, с которой цена начинает действовать
end_date DATE, – дата, до которой цена действовала (может быть NULL для текущей цены)
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Убрав при этом поле item_cost из таблицы items.
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
);
Теперь используя запрос, который приведен ниже, мы можем получить новую стоимость необходимого товара
SELECT item_cost
FROM item_prices
WHERE item_id = {id необходимого товара} AND end_date IS NULL;
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME – необходимо использовать алиасу таблицы для выбираемых полей, так как поле DEPARTMENT_ID есть в двух таблицах. SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME
MANAGER_ID = NULL – проверка на NULL значение должна быть через IS или NOT IS. В данном случае должно быть: MANAGER_ID IS NULL. Также для данного поля стоит явно указать таблицу используя префикс: E.MANAGER_ID.
LOCATION_ID – тоже лучше использовать с префиксом таблицы: E.LOCATION_ID
AND SUM(SALARY) >= 100000 – данное условие необходимо переместить в блок HAVING после GROUP BY
GROUP BY DEPARTMENT_NAME – группировка в данном случае будет по 2м полям: GROUP BY D.DEPARTMENT_ID, DEPARTMENT_NAME
В результате исправленный запрос имеет следующий вид:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E. DEPARTMENT_ID = D. DEPARTMENT_ID
AND E.MANAGER_ID IS NULL
AND E.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = ‘SEOUL’ )
GROUP BY D.DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(SALARY) >= 100000
Карандаш упал и закатился к стене или в угол. Из-за чего его стало невозможно перепрыгнуть;
Меня нет в этой комнате.",
6,104.docx,.docx,docx,"1.
Я изменил бы следующим образом:
в Client_id добавляю not null и unique;
вместо age добавим bith_date в формате date.
Также выносим login и reg_date во внешнюю таблицу, а в таблице clients будем хранить внешний ключ.
2.
Создадим отдельную таблицу items_cost. В items заменяем поле item_cost на item_cost_id – внешний ключ на новую таблицу. Items_cost при этом выглядит следующим образом:
Items_cost (
Id number,-- уникальный ключ таблицы
Item_id number,-- внешний ключ на items
Cost number,-- стоимость товара начиная с сost_date_start по настоящее время или до следующего значения сost_date_start
Cost_date_start date— дата, начиная с которой становится актуальной текущая стоимость
);
Чтобы получать актуальную стоимость нужно будет написать запрос, группирующий cost по item_id и упорядоченный по Cost_date_start. Это позволит хранить историчные данные по цене, не раздувать исходную таблицу items и блюсти нормальную форму.
3. Исправляем ошибки и получаем:
SELECT
DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D,
LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND D.LOCATION_ID = L.LOCATION_ID
AND L.CITY = 'SEOUL'
GROUP BY DEPARTMENT_NAME, DEPARTMENT_ID
HAVING SUM(SALARY) > 100000
4.
Потому, что карандаш обладает очень малыми размерами относительно человека, поэтому перепрыгнуть через него практически невозможно",
7,105.docx,.docx,docx,"1.
Считаю данный набор и смысл полей не совсем корректным, и изменил бы следующее:
в Client_id добавляем ограничение not null и unique;
age – странное поле, его придётся минимум раз в год пересчитывать. Лучше хранить bith_date в формате date.
Для нормальзации можно подумать над тем, чтобы вынести login и reg_date во внешнюю таблицу, а в таблице clients хранить внешний ключ.
2.
Лучший вариант – создание отдельной таблицы items_cost. В items заменяем поле item_cost на item_cost_id – внешний ключ на новую таблицу. Items_cost при этом выглядит следующим образом:
Items_cost (
Id number,-- уникальный ключ таблицы
Item_id number,-- внешний ключ на items
Cost number,-- стоимость товара начиная с сost_date_start по настоящее время или до следующего значения сost_date_start
Cost_date_start date—дата, начиная с которой становится актуальной текущая стоимость
);
Чтобы получать актуальную стоимость нужно будет написать запрос, группирующий cost по item_id и упорядоченный по Cost_date_start. Это позволяет и хранить историчные данные по цене, и не раздувать исходную таблицу items, и блюсти нормальную форму.
3.
Я бы сформировал запрос следующим образом:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID IS NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_NAME, DEPARTMENT_ID
HAVING SUM(SALARY) > 100000
4.
Если учесть, что комната с мебелью, карандаш мог упасть, например, под диван. И тогда, понятное дело, через него не перепрыгнуть. Кроме того, наш герой - карандаш - мог приземлиться возле стены или в углу комнаты. Если же карандашу посчастливилось упасть в центре воображаемой комнаты, где нет препятствий для прыжка, то тот человек, который его уронил, тот час же поднимет его, поскольку с помощью этого карандаша он, например, делает заметки. Из всего вышеуказанного следует, что через карандаш не перепрыгнуть.",
8,106.txt,.txt,text,"1.client_id number, 
client_name varchar(50), 
client_surname varchar(50), 
login varchar(30), 
city_id number, 
age DATE, 
reg_date date 

2.
загружу пока без ответа

3.
SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE as E, 
 DEPARTMENTS as D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 AND MANAGER_ID IS NULL
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS 
 WHERE CITY = 'SEOUL')
 AND SUM(SALARY) > 100000
GROUP BY DEPARTMENT_NAME

4.Возможно потому что карандаш упал рядом со стеной",
9,107.docx,.docx,docx,"Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки. Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients ( client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента reg_date date –дата регистрации на сайте );
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему мнению некорректно и какие изменения внесли бы.
Ответ: В таблице не определен Первичный ключ (primary key) для этого подойдет client_id, необходимый для формирования запросов из нескольких таблиц , например товары или заказы.
Так же в архитектуре БД интернет магазина необходимо определить сущности и связи. Если сущности это: клиенты, товары, заказы
То связь между клиентами и заказами будет в формате «один ко многим»: у покупателя может быть множество заказов, а у заказа только один покупатель.
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она илиможно внести некоторые доработки. Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items ( );
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различные отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года. Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
Ответ: В этой таблице не определен внешний ключ, для формирования запросов из нескольких таблиц, ссылающийся на таблицу клиентов.
Для формирования отчетности необходимо хранить историю изменения цен, для этого в БД я бы добавил таблицу price_history для хранения истории цен каждого товара, из нее получить стоимость товара на дату оформления заказа. Если товар менял стоимость несколько раз в этом году, то нам нужна история цен, чтобы знать сколько денег заработал наш интернет магазин за определенный товар в данном году.
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000 GROUP BY DEPARTMENT_NAME
Ответ:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM SCHEMA_NAME.EMPLOYEE E
JOIN SCHEMA_NAME.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND E.LOCATION_ID = (SELECT LOCATION_ID
FROM SCHEMA_NAME.LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000
В некоторой комнате на пол уронили карандаш. Объясните, почему вы не можете через него перепрыгнуть?
Ответ: Есть несколько вариантов почему мы не можем перепрыгнуть карандаш который уронили на пол. Карандаш лежит в углу вплотную, и перепрыгнуть его не получится, так как мы упираемся в стены. Карандаш после падения мог попасть под шкаф, через который мы так же не можем перепрыгнуть. Карандаш после падения попал под пол(в трещину в полу), мы его не видим и прыгнуть через него соответственно не можем.",
10,108.txt,.txt,text,"Считаю данный набор и смысл полей корректным.
В таблице items оставил бы хранение текущей цены. Создал бы таблицу
items_price (

price_id - уникальный id для записи цены

item_id - внешний ключ на таблицу items

item_cost - стоимость

item_date - дата установления цены

)

3. Вместо = NULL использовать IS NULL, использовать JOIN для соединения таблиц, переместить SUM(SALARY) >= 100000 в HAVING.

Пример исправленного запроса

SELECT DEPARTMENT_ID,DEPARTMENT_NAME, SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
4. Карандаш лежит в углу.",
11,109.docx,.docx,docx,"Я считаю данную таблицу не вполне корректной по следующим причинам:
К client_id нужно добавить первичный ключ и предусмотреть его автоматическое увеличение.
Сделать некоторые поля обязательными (NOT NULL): имя, фамилию, логин.
Проверить, нужно/можно ли сделать обязательными другие поля, такие как дата регистрации и город (т.е. проверить, всегда ли они заполнялись раньше, и во всех ли сценариях работы они заполняются).
Обеспечить уникальность поля login.
Поле age заменить на birth_date (дату рождения), чтобы возраст можно было в любое время рассчитать автоматически вне зависимости от его изменения, а также чтобы можно было проводить акции в честь дня рождения, или хотя бы на birth_year.
Для поля reg_date задать значение по умолчанию, чтобы при вставке новой строки в таблицу текущая дата заполнялась автоматически.
Добавить другие необходимые поля, такие как email, phone_number и address, если эти данные не содержатся в других таблицах.
Длина полей с именем и фамилией клиента кажется избыточной, поэтому можно ее сократить.
В данной таблице не хватает информации об изменении цен. Я бы добавила поле start_date, в котором будет указываться дата начала действия новой цены, и поле end_date с указанием даты окончания действия цены. Также можно учитывать в этих полях не только дату, но и время, с которого начинает/заканчивает действовать цена. У актуальной цены не задавать дату окончания.
3. Ошибки в запросе есть и могут быть исправлены следующим образом:
Добавить псевдонимы таблиц к названиям столбцов в коде.
Вставить AS перед псевдонимом TOTAL_SALARY.
Изменить способ соединения таблиц с CROSS JOIN с WHERE на INNER JOIN с ON, т. к. первый способ менее эффективен в плане производительности.
“= NULL” исправить на “IS NULL”.
Подзапрос в условии WHERE можно заменить на INNER JOIN для улучшения читабельности.
AND SUM(SALARY) >= 100000 заменить на HAVING SUM(SALARY) >= 100000 после группировки (агрегатные функции не используются в условии WHERE).
Группировку делать по DEPARTMENT_ID, т. к. названия отделов в разных городах могут быть одинаковыми.
4. Возможные варианты:
Карандаш упал так, что через него невозможно перепрыгнуть - возле стены или возле стола. Или улетел в дыру в полу.
Неизвестно, что это за комната, и где она находится.
Проводится эксперимент, и прыгнуть через карандаш – значит нарушить его.
Я не хочу/не могу прыгать по какой-либо причине.",
12,110.pdf,.pdf,pdf,"1) Задание:
● Имеем: Интернет магазин, таблица с информацией о
зарегистрировавшихся покупателях (клиентах).
● Запрос: Считаете ли вы данный набор и смысл полей корректным? Если
нет, то напишите, что по вашему мнению некорректно и какие изменения
внесли бы.
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название
города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date --дата регистрации на сайте
);
Рассмотрим каждое поле, вызывающее вопросы:
1. client_id number, --уникальный id клиента
● Так как id клиента должно быть уникальным и не может быть null, нужно
поставить ключевое ограничение => client_id number primary key
2. client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
● Поля client_name и client_surname с типом varchar(255) избыточны, так
как имена и фамилии редко превышают 50 символов. Сокращение
длины до varchar(50) оптимизирует использование памяти и повышает
производительность базы данных => client_name varchar(50),
client_surname varchar(50)
3. login varchar(30), --логин, который придумал клиент
● Ограничение в 30 символов для поля login может быть слишком
маленьким, учитывая современные тенденции, где пользователи могут
использовать длинные комбинации символов. Увеличение до 50-100
символов могло бы быть более безопасным => login varchar(100)
4. city_id number, --id города, который указал клиент (в интерфейсе выбирается
название города, а в таблицу сохраняется id)
● Отсутствие информации о структуре таблицы городов затрудняет оценку
правильности использования. Важно убедиться, что есть отдельная
таблица cities, где хранятся уникальные записи о городах (например,
city_id, city_name, region, country и т.д.), и что реализована связь между
таблицами.
5. age number, --возраст клиента
● Хранение возраста как числа может вызвать проблемы, так как данное
значение меняется с течением времени. Лучше было бы заменить поле
age на birth_date, а возраст рассчитывать динамически на основе
текущей даты и даты рождения => birth_date date
6. reg_date date --дата регистрации на сайте

● Поле reg_date выглядит корректным, однако стоит убедиться, что для
этого поля используется тип данных, позволяющий хранить точное время
регистрации, а не только дату. В таком случае можно рассмотреть
использование типа данных timestamp вместо date, чтобы сохранить
точное время регистрации => reg_date timestamp
Дополнение: Возможно, стоит добавить поле email или phone_number, которые также
могут быть уникальными, чтобы избежать дублирования данных, и использоваться для
аутентификации клиента или для связи с ним.
● email varchar(255), -- email клиента (уникальный)
● phone_number varchar(15), -- телефон клиента (уникальный)
Говоря о регистрации клиентов, также важно включить поле для хранения паролей. Их
нельзя хранить в открытом виде, они должны быть безопасно зашифрованы в виде
хэшей с использованием соли (уникальной для каждого пользователя). Это делает
пароли более защищенными от брутфорса, так как соль добавляется к паролю перед
его хэшированием, что усложняет взлом даже при возможном совпадении паролей у
разных пользователей.
Обновленный вариант таблицы:
clients (
client_id NUMBER PRIMARY KEY, -- уникальный id клиента
first_name VARCHAR(50), -- имя клиента
last_name VARCHAR(50), -- фамилия клиента
login VARCHAR(100) UNIQUE, -- логин, который придумал клиент (уникальный)
city_id NUMBER, -- id города, который указал клиент
birth_date DATE, -- дата рождения клиента
reg_date TIMESTAMP, -- дата и время регистрации на сайте
email VARCHAR(255) UNIQUE, -- email клиента (уникальный)
phone_number VARCHAR(15) UNIQUE, -- телефон клиента (уникальный)
password_hash VARCHAR(255), -- хэш пароля клиента
salt VARCHAR(255) -- соль для хэширования пароля
);
2) Задание:
● Имеем: База данных для магазина, таблица с информацией о товарах
магазина.
● Запрос: Провести проверку существующей архитектуры и решить
корректна ли она или можно внести некоторые доработки. Как бы вы
доработали архитектуру таблицы, чтобы обеспечить историческое
хранение стоимости товара?
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number --стоимость товар
);

Чтобы обеспечить историческое хранение стоимости товара, необходимо реализовать
систему версионирования данных о стоимости через разделение информации о
товарах и их ценах на две отдельные таблицы:
1. Таблица items с основной информацией о товаре, которая не меняется со
временем. Схема:
CREATE TABLE items (
item_id NUMBER PRIMARY KEY, -- уникальный ID товара
item_name VARCHAR(255) -- наименование товара
);
2. Таблица items_prices с историей изменения цен товаров, с указанием даты,
начиная с которой цена актуальна. Схема:
CREATE TABLE item_prices (
price_id NUMBER PRIMARY KEY, -- уникальный ID записи о цене
item_id NUMBER, -- ID товара, связанный с таблицей items
item_cost NUMBER, -- стоимость товара
start_date DATE, -- дата начала действия цены
end_date DATE, -- дата окончания действия цены (может быть NULL для
актуальной цены)
CONSTRAINT fk_item FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Связь между таблицами, соответствие между товарами и их ценами осуществляется с
помощью внешнего ключа item_id в таблице item_prices, связанным с таблицей items.
Такое решение позволит хранить все изменения цен, что особенно важно для
финансовой отчетности и аналитики.
3) Задание:
● Имеем: Существует учебная схема HR, содержащая таблицы:
employees, departments и locations
● Запрос: Необходимо получить все отделы, расположенные в Сеуле, в
которых все сотрудники, не имеющие менеджера, зарабатывают в общей
сложности более 100000.
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Соответственно в данном запросе есть следующие ошибки:
1. Ошибка 1 - MANAGER_ID = NULL:

● Условие MANAGER_ID = NULL не будет работать, так как сравнение с
NULL выполняется с помощью оператора IS NULL. В SQL значение NULL
представляет неизвестное значение, и прямое сравнение с ним всегда
возвращает FALSE. Чтобы корректно отобрать строки, где значение поля
MANAGER_ID отсутствует, нужно использовать E.MANAGER_ID IS NULL.
2. Ошибка 2 - агрегатная функция в разделе WHERE:
● Агрегатные функции, такие как SUM(SALARY), нельзя использовать в
разделе WHERE, так как этот раздел фильтрует строки до этапа
группировки. Для фильтрации по агрегатным функциям нужно
использовать раздел HAVING, который применяется к уже
сгруппированным данным. Поэтому условие SUM(SALARY) >= 100000
должно быть перемещено в HAVING.
3. Ошибка 3 - группировка:
● Запрос должен группироваться не только по DEPARTMENT_NAME, но и
по DEPARTMENT_ID, так как это поле используется в разделе SELECT, а
SQL требует, чтобы все поля, которые не являются агрегатными
функциями, были перечислены в GROUP BY.
4. Ошибка 4 - связь с таблицей местоположений:
● Запрос должен фильтровать отделы, расположенные в Сеуле, на основе
правильного сопоставления таблицы DEPARTMENTS с таблицей
LOCATIONS. Для этого нужно использовать JOIN между таблицами
DEPARTMENTS и LOCATIONS, чтобы получить отделы, связанные с
городом Сеул. Это делается через поле LOCATION_ID.
Исправленный запрос:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
4) Задание: В некоторой комнате на пол уронили карандаш. Объясните почему вы
не можете через него перепрыгнуть?
1. Пространственные ограничения:
● Карандаш лежит вплотную к стене, препятствующей прыжку.
● Карандаш закатился под какой-то предмет, и без его
перемещения прыгнуть через карандаш невозможно.
2. Физические ограничения:
● Невозможно прыгнуть из-за состояния здоровья.
● Отсутствие меня в комнате, где уронили карандаш.
3. Просто нет желания/мотивации прыгать через карандаш.",
13,111.docx,.docx,docx,"1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему мнению некорректно и какие изменения внесли бы.
1) Вместо age number можно создать столбец birth_date, указывающий дату рождения;
2) Вынести city_id number в другую таблицу с информацией о заказах
3) Вынести login varchar(30), phone_number в отдельную таблицу с информацией данных регистрации.
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое хранение стоимости товара?
Нужно добавить еще одну таблицу с информацией о изменении цены:
Items_cost_history (
item_id number, --уникальный id товара
item_cost_new number – стоимость товара
item_date_change timestamp– дата изменения цены
);
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
SELECT D.DEPARTMENT_ID,
DEPARTMENT_NAME,
FROM DEPARTMENTS D
JOIN LOCATIONS L
ON L.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN EMPLOYEE E
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE L.CITY = 'SEOUL' and E.name NOT LIKE “%manager”
GROUP BY DEPARTMENT_NAME
Having SUM(SALARY) > 100000
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Предполагаю, что карандаш уронили в комнате, находящейся надо мной.",
14,112.txt,.txt,text,"1. 
1) client_id сделала бы int, достаточно будет целового числа для уникального идентификатора пользователя, это будет первичный ключ;
2)reg_date изменила бы на timestamp, что позволит знать не только дату, но и время. При анализе даст больше информации время, чем только дата;
3)для client_name и client_surname достаточно 30 и 50 соответсвенно символов, 255 - это слишком много, что для таких данных не требуется;
4)city_id и age также сделала бы int, что хранит целые числа;
5)city_id будет уникальным;
6)для client_name и client_surname можно оставить как name и surname, так как и так ясно, что таблица для данных клиента.

2. Необходимо создать вторую таблицу, где для каждого item_id будет дата изменения цены, новая цена, старая цена(из первой таблицы будет удалено) и указание в какой период это было (перед началом учебного года или новым годом и тд). item_id будет уже внешним ключом в данной таблице. 

3.SELECT DEPARTMENT_NAME
FROM EMPLOYEE E 
LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN LOCATION L ON D.LOCATION_ID = L.LOCATION_ID

WHERE D.MANAGER_ID IS NULL
 AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000

4.Недостаточно условий для предоставления ответа, то есть очень мало вводных данных.",
15,113.docx,.docx,docx,"Первое задание:
Возраст лучше хранить в виде даты рождения, иначе придётся каждый год менять записи.
Можно добавить поля «Отчество» и «Пароль».
В случае, если мы добавляем пароль, можно вынести пароль и логин в отдельную таблицу. Пароль лучше хранить в к-л преобразованном виде для безопасности.
Длину имени и фамилии можно уменьшить. Вряд ли у кого-то в имени будет больше 100 символов.
Второе задание:
Можно добавить поле «Дата обновления цены», в которое записывать дату, в которую цена обновилась до текущий, и каждый раз вместо того, чтобы обновлять запись в таблице, добавлять новую.
Третье задание:
1. Нас не просят вывести суму зарплат, только отделы. Строчка в заголовке select ""sum(salary) total_salary не нужна.
2. Неявное объединение таблиц обычно не приветствуется. Лучше использовать join..on.
3. Manager=null - это не законно. Manager is null.
4. And sum(salary) >= 100000 - агрегирующие функции используются в having. Вместо этого дальше, в group by, стоит написать: Having sum(salary) >= 100000
Вопрос четвёртый:
Рассмотрим варианты:
1. Мы знаем, в какой комнате упал карадндаш и можем до него добраться.
Тогда проблема, очевидно, в самой комнате или в карандаше (если свойства карандаша вообще способны меняться, например, его размер).
В частности, мы не сможем перепрыгнуть карандаш, если его больше нет (упал на пол, отскочил, упал в измельчитель, всё). Или если он выпал за текстуры и теперь падает в пустоту. Или если на полу лежит ковер, и карандаш упал на ковёр, а не на пол: так не выполняется условие с падением на пол, а, следовательно, и перепрыгнуть через лежащий на полу карандаш мы не можем.
Размеры комнаты и её наполнение тоже могут быть любыми. В частности, если карандаш упадёт под что-то, что мы физически или при помощи приборов не можем перепрыгнуть, то это успех. 
Надо понимать, что если мы находимся снаружи комнаты, то нам достаточно не мочь перепрыгнуть комнату, чтобы не мочь перепрыгивать карандаш.
2. Мы не знаем, в какой комнате карандаш или не можем до него добраться.
Тогда вполне понятно, почему мы не можем через него перепрыгнуть. Мы или просто не знаем о его существовании (не видели или не знаем, что он упал), или же просто не дойдём до места, где находится карандаш и где надо его перепрыгивать.
Конечно, мы можем попытаться найти нужную комнату, но так как комната ""некоторая"", мы не можем точно сказать, сколько времени уйдёт на поиск. Оно правда нам надо?
Ещё один редкий вариант: мы не можем перепрыгнуть карандаш из-за каких-либо психологических особенностей. Например, особая реакция на карандаши, заставляющая человека при виде падающего карандаша упасть ничком и лежать рядом, подбадривая карандаш и призывая не мириться со сложившейся ситуацией.",
16,114.docx,.docx,docx,"Денисова А.Д.
Тестовое задание
Задание 1.
Я считаю, что:
- поля client_name и client_surname можно объединить.
- для client_id можно использовать тип PRIMARY KEY.
- для login можно уменьшить количество символов varchar(10).
- поле age бессмысленное, так как возраст с годами меняется, лучше заменить его на дату рождения.
Задание 2.
Для обеспечения исторического хранения стоимости товара нужно добавить поле с датой, например, date_cost с типом данных date, где хранилась бы дата изменения стоимости товара.
Также эту таблицу можно доработать, добавив столбец amount с типом данных int для количества имеющегося товара.
Задание 3.
Корректный запрос:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D USING(DEPARTMENT_ID)
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID,
D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
Задание 4.
Его уронили в углу комнаты.",
17,115.sql,.sql,text,"1. Задание
1.1. В колонке client_id ставил бы секвенсом значениеи изменил констрейнт unique на первичный ключ. Он содержит в себе сразу два констрейнта unique и not null.
1.2. В колонках client_name, client_surname, login тип данных varchar(количество символов) Oracle. Я бы заменил на пресловутый байтовый varchar2. Да и вдобавок сами Oracle не рекомеднуют использовать тип данных varchar.
1.3. В колонке age изменил бы тип данных на DATE. Было бы удобно делать рассылки на день рождения клиента с текстом ""Поздравляем с ДР!"" Естетсвенное pl/sql блоком, может джобом.
1.4. В колонке reg_date дописал бы стандартное значение - sysdate. Т.е. reg_date date default sysdate.
1.5. Считаю, что стоит добавить сущность тип документа document_id и добавлять значение id, который указал клиент (в интерфейсе выбирается название тип документа (паспорт, загран паспорт и прочее), а в таблицу сохраняется id). Мы ведь солидная компанию.
1.6. Считаю, что стоит добавить сущность пол клиента gender_client и добавлять значение id, который указал клиент (в интерфейсе выбирается мужской/женский) , а в таблицу сохраняется id). Было бы полезно для сбора статистики покупок по гендеру.
1.7. Считаю, что МОЖНО добавить сущность отчество клиента. И в целом столбцы с информацией о имени клиента переименовать client_name => f_name, client_surname => m_name, новый столбец с отчеством m_name varchar2(255),. Отчество пригодиться для рассылок с официальным обращением.
1.8. Cчитаю, что стоит добавить сущность номер телефона клиента phone_number varchar2(200).
1.9. Считаю, что стоит добавить сущность имейл клиента email_client varchar2(200) constraint check_client_email check (instr(email_client,'@')>0)). Указание имейла для рассылок.

2.Задание
2.1. Необходимо добавить первичный ключ на столбец item_id, чтобы можно было ссылаться на таблицу.
2.2. В колонке item_cost стоит тип данных number. Я бы заменил его на number(15.2), т.е. придал размерность для копеек. Потому что скидки, которые будут применяться могу срезать цену и до копеек. Тут 2 символа отвел бы на копейки. Больше нет необходимости.
Да и не всегда округлять цену в большую сторону это приемущество. Ведь цена 99999999.84 выгляди лучше чем 100000000. На авито даже ставят аренду квартиры не 25000, а 248000. Хотя, по сути, платишь все равно 25000))
2.3. В колонке item_cost добавил бы констрейнт not null. А то кто-нибудь заберет товар бесплатно, воспользовавшись нашей ошикбой.
2.4. --Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом).
Для ввода цены, которая скачет по законам рыночной экономики, я создал бы промежуточную таблицу items_price
create table items_price
(id number constraint pk_item_price_id primary key,--первичный ключ
item_id number constraint fk_item_price_item_id references items(item_id), -- внешний ключ на парент таблицу items и столбец item_id
item_name varchar2(255), --наименование товара
item_cost_fix number(15,2) constraint n_n_item_cost not null, -- цена не может быть Null
date_price timestamp default sysdate); -- дата ввода цены. Если цена меняется несколько раз в день, то тип данных таймстам даст возможность отследить этот моммент.

В эту таблицу посредством интерфейса будет вносится информация об изменении цены на определенный товар. 
Каждое изменение цены это новая строка. 
Эта информация позволит собрать данные о ценах за на товар определенный период. 

Цель таблицы items_price содержать в себе накопительную иноформацию об изменении цены на любой товар. Эта таблица позволит не захламлять основную таблицу items.
В главной таблице items будет выводиться актуальная на текущее время цена на товар.

3. Задание
select d.department_name, sum(salary)
 from departments d
 join employees e
 on (d.department_id = e.department_id)
 where exists (select 1
 from locations l
 where l.location_id = d.location_id
 and upper(city) = 'SEOUL')
 and e.manager_id is null having sum(salary) >= 100000
 group by d.department_name;

4. Задание
Прыгнуть через карандаш не получится, потому что он мог упасть у в плотную к стене. Или же мог упасть на пол в комнате, 
которая находится в другом городе и поэтому прыжок не будет реализован. Также, есть вероятность того, что прыгать, в целом не хочется. Зачем?",
18,116.docx,.docx,docx,"Тут всё зависит от задачи и данных:
Как правило login сам по себе является уникальным идентификатором пользователя и в данном случае может являться первичным ключом вместо client_id (который будет не нужен)
Или, учитывая что заказ будет связан с login, можно провести декомпозицию, выделив персональные данные (создав им первичный ключ), т.к. они нужны исключительно для информации в профиле клиента и для, возможно, персональных предложений. В таблице clients останутся login, person_id, reg_date.
Я б вынес item_cost в отдельную таблицу:
CREATE TABLE item_costs (item_id INT (foreing key таблицы items), cost_value money, cost_set_day date). Стоимость товара со «старшей» датой и будет текущей.
Но при большом количестве записей запрос к этим таблицам будет работать медленнее. В таком случае текущая цена должна остаться в таблице items и при изменении должна заносится в историю цен (триггером я бы сделал). Дату в таком случае удобнее использовать - дату изменения, но ту уж зависит от того что нужно условной бухгалтерии
SELECT DEPARTMENT_ID,
MAX(DEPARTMENT_NAME) DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D,
LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND MANAGER_ID = NULL
AND D.LOCATION_ID = L.LOCATION_ID AND L.CITY = 'SEOUL'
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) >= 100000
Карандаш у стены",
19,117.pdf,.pdf,pdf,"1 задание) Я хочу предложить несколько изменений в исходную структуру, которые, по
моему мнению, улучшат дальнейшее использование базы данных и снизят затраты на
разработку сервисов для взаимодействия с ней:
1) client_id – подразумевается уникальным. Логично использовать в качестве первичного
ключа
2) login – логин может быть только уникальным. Стоит добавить уникальный индекс на это
поле
3) Возраст (age) лучше заменить на дату рождения. Возраст можно рассчитать на лету.
4) city_id должен ссылаться на таблицу с городами, т.е. получить ForeingKey
5) reg_date лучше сделать TIMESTAMP
6) Добавить доп информацию – email, phone_number etc.
2 задание) Лучшим решение будет не менять архитектуру таблицы, а добавить другую
таблицу, где будут хранится исторические данные.
CREATE TABLE item_prices (
price_id SERIAL PRIMARY KEY,
item_id NUMBER REFERENCES items(item_id),
price_number NUMBER NOT NULL,
effective_date DATE NOT NULL,
expiration_date DATE
);
Таблица items будет оставаться без изменения, кроме добавления ссылки на таблицу цен,
если это необходимо. Однако логически она будет ссылаться на текущие цены, хранящиеся в
item_prices.
Когда цена товара изменяется, вместо обновления поля item_cost в таблице items, будет
добавляться новая запись в item_prices с новой ценой и соответствующими датами.
3 задание)
Вот корректный запрос:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE
E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY =
'SEOUL')
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;

4) В комнату нет доступа. Карандаш упал около стены и его нельзя перепрыгнуть. Комната
очень низкая для прыжка.",
20,118.md,.md,text,"# Тестовое задание в рамках входных мероприятий Data Engineer (осенний набор 2024)

## Вопрос 1

1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).

Таблица имеет следующую схему:

```sql
clients (
 client_id number, --уникальный id клиента
 client_name varchar(255), --имя клиента
 client_surname varchar(255), --фамилия клиента
 login varchar(30), --логин, который придумал клиент
 city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
 age number, --возраст клиента
 reg_date date --дата регистрации на сайте
);
```

Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему
мнению некорректно и какие изменения внесли бы.

## Ответ 1

Исходя из комментария ""в интерфейсе выбирается название города, а в таблицу сохраняется id"" можно сделать вывод, что города сохраняются в отдельную таблицу (для решения я воссоздал ее, как бы она могла выглядеть, в скрипте ниже), а следовательно эта схема уже удовлетворяет 3NF, так как поскольку избегает транзитивных зависимостей, каждая таблица содержит только те столбцы, которые полностью зависят от первичного ключа, и не включает ненужные зависимости.

Есть вопросы к самому исполнению, а именно:

- `client_id` данные не проверяются на уникальность и требует заполнения, предлагаю:
```sql
client_id INT PRIMARY KEY AUTO_INCREMENT
```
- `login` данные не проверяются на уникальность, нулевые значения, предлагаю:
```sql
login VARCHAR(30) UNIQUE NOT NULL
```
- `age` возраст может изменится, корректнее хранить дату рождения, а возраст вычислять:
```sql
birth_date DATE
```
- `reg_date` имеет смысл получать автоматически:
```sql
reg_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
```
Также стоит добавить внешний ключ для обеспечения целостности:
```sql
FOREIGN KEY (city_id) REFERENCES cities(city_id) ON UPDATE CASCADE ON DELETE CASCADE
```

В скрипте ниже я попытался дать свой вариант, сопроводив его комментариями с пояснением вносимых изменений.

### Сам скрипт с тестовыми данными (тестировалось на MySQL8)

```sql
DROP DATABASE IF EXISTS test_database;
CREATE DATABASE test_database;

USE test_database;

/*Таблица `cities` разделяет информацию о городах, уменьшая избыточность данных и обеспечивая согласованность информации.*/
DROP TABLE IF EXISTS cities;
CREATE TABLE cities (
 city_id INT PRIMARY KEY AUTO_INCREMENT,
 city_name VARCHAR(100) NOT NULL,
 country VARCHAR(100) NOT NULL
) ENGINE=InnoDB;

DROP TABLE IF EXISTS clients;
CREATE TABLE clients (
 client_id INT PRIMARY KEY AUTO_INCREMENT, -- уникальный идентификатор
 client_name VARCHAR(100) NOT NULL, -- имя клиента
 client_surname VARCHAR(100) NOT NULL, -- фамилия клиента
 login VARCHAR(30) UNIQUE NOT NULL, -- уникальный логин
 city_id INT, -- id города
 birth_date DATE, -- дата рождения клиента
 reg_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- дата регистрации с автоматическим заполнением
 email VARCHAR(255) UNIQUE NOT NULL, -- уникальная электронная почта
 phone_number VARCHAR(20), -- телефон клиента (опционально)
 FOREIGN KEY (city_id) REFERENCES cities(city_id) ON UPDATE CASCADE ON DELETE CASCADE -- внешний ключ для обеспечения целостности
) ENGINE=InnoDB;

-- создаем таблицу логирования
DROP TABLE IF EXISTS logs_table;
CREATE TABLE logs_table (
 id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
 created_at DATETIME NOT NULL,
 table_name VARCHAR(25) NOT NULL,
 primary_key_id INT NOT NULL,
 name_value VARCHAR(100) NOT NULL
) ENGINE=ARCHIVE;

-- триггер
DROP TRIGGER IF EXISTS change_users;
DELIMITER //
CREATE TRIGGER change_users AFTER INSERT ON clients
FOR EACH ROW
BEGIN
 INSERT INTO logs_table (created_at, table_name, primary_key_id, name_value)
 VALUES (NOW(), 'clients', NEW.client_id, NEW.client_name);
END //
DELIMITER ;

-- Начало транзакции
START TRANSACTION;
-- Вставка тестовых данных в cities
INSERT INTO cities (city_name, country)
VALUES
 ('New York', 'USA'),
 ('Los Angeles', 'USA'),
 ('Chicago', 'USA'),
 ('Houston', 'USA'),
 ('Phoenix', 'USA'),
 ('Philadelphia', 'USA'),
 ('San Antonio', 'USA'),
 ('San Diego', 'USA'),
 ('Dallas', 'USA'),
 ('San Jose', 'USA'),
 ('Austin', 'USA'),
 ('Jacksonville', 'USA'),
 ('Fort Worth', 'USA'),
 ('Columbus', 'USA'),
 ('Charlotte', 'USA');
-- Коммит транзакции
COMMIT;

-- Начало транзакции
START TRANSACTION;
-- Вставка тестовых данных в clients
INSERT INTO clients (client_name, client_surname, login, city_id, birth_date, email, phone_number)
VALUES
 ('John', 'Doe', 'johndoe', 1, '1985-07-12', 'john.doe@example.com', '+123456789'),
 ('Jane', 'Smith', 'janesmith', 2, '1990-03-25', 'jane.smith@example.com', '+123456788'),
 ('Alice', 'Johnson', 'alicej', 3, '1992-05-10', 'alice.johnson@example.com', '+123456787'),
 ('Bob', 'Brown', 'bobbyb', 4, '1987-11-21', 'bob.brown@example.com', '+123456786'),
 ('Charlie', 'Williams', 'charliew', 5, '1984-02-18', 'charlie.williams@example.com', '+123456785'),
 ('Diana', 'Jones', 'dianaj', 6, '1993-09-07', 'diana.jones@example.com', '+123456784'),
 ('Eve', 'Taylor', 'evetaylor', 7, '1988-12-14', 'eve.taylor@example.com', '+123456783'),
 ('Frank', 'Moore', 'frankm', 8, '1981-06-22', 'frank.moore@example.com', '+123456782'),
 ('Grace', 'Clark', 'gracec', 9, '1986-01-03', 'grace.clark@example.com', '+123456781'),
 ('Hank', 'Lee', 'hankl', 10, '1991-08-19', 'hank.lee@example.com', '+123456780'),
 ('Ivy', 'Walker', 'ivyw', 11, '1989-04-28', 'ivy.walker@example.com', '+123456779'),
 ('Jack', 'Harris', 'jackh', 12, '1982-11-13', 'jack.harris@example.com', '+123456778'),
 ('Kelly', 'Young', 'kellyy', 13, '1994-07-04', 'kelly.young@example.com', '+123456777'),
 ('Leo', 'Martinez', 'leom', 14, '1983-10-25', 'leo.martinez@example.com', '+123456776'),
 ('Mona', 'Garcia', 'monag', 15, '1980-03-30', 'mona.garcia@example.com', '+123456775');
-- Коммит транзакции
COMMIT;

/*Для ускорения поиска данных можно добавить индексы, например, на `client_id` или `reg_date`,
в зависимости от частоты использования и типов запросов к базе данных.*/
CREATE INDEX idx_client_id ON clients(client_id); -- Индекс на client_id для быстрого доступа
CREATE INDEX idx_reg_date ON clients(reg_date); -- Индекс на reg_date для эффективных запросов по дате

-- для удобства создадим представление
CREATE OR REPLACE VIEW summary AS
SELECT 
 clients.client_id, 
 clients.client_name, 
 clients.client_surname, 
 clients.email,
 cities.city_name,
 clients.phone_number,
 clients.reg_date
FROM 
 clients
JOIN 
 cities 
ON 
 clients.city_id = cities.city_id;

-- скрипты характерных выборок
SELECT * FROM summary;
SELECT * FROM logs_table;

```

## Вопрос 2

2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.

Таблица имеет следующую схему:

```sql
items (
 item_id number, --уникальный id товара
 item_name varchar(255), --наименование товара
 item_cost number --стоимость товара
):
```

Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно строить различныотчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.

Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранениестоимости
товара?

## Ответ 2

Для реализации исторического хранения стоимости товаров создать дополнительную аудитную таблицу, которая будет служить для записи всех изменений цен, а также триггеры на основную таблицу `items`, которые будут автоматически записывать изменения цен в аудитную таблицу `item_prices_audit`.

Данный подход обеспечивает полную историчность изменений цен, позволяет строить отчеты и анализировать изменения во времени, что часто является важным требованием для финансовой отчётности и аналитики.

### Скрипт с тестовыми данными (тестировалось на MySQL8)

```sql
DROP DATABASE IF EXISTS test_database;
CREATE DATABASE test_database;

USE test_database;

-- Создание основной таблицы товаров
DROP TABLE IF EXISTS items;
CREATE TABLE items (
 item_id INT AUTO_INCREMENT PRIMARY KEY,
 item_name VARCHAR(255) NOT NULL,
 item_cost DECIMAL(10.2) NOT NULL
) ENGINE=InnoDB;

-- Создание аудитной таблицы цен товаров
DROP TABLE IF EXISTS item_prices_audit;
CREATE TABLE item_prices_audit (
 audit_id INT AUTO_INCREMENT PRIMARY KEY,
 item_id INT,
 price DECIMAL(10, 2),
 change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
 changed_by VARCHAR(100),
 change_type VARCHAR(50),
 FOREIGN KEY (item_id) REFERENCES items(item_id)
) ENGINE=InnoDB;

-- Создание триггера для записи изменений цен в аудитную таблицу
DELIMITER //
CREATE TRIGGER trg_price_audit AFTER UPDATE ON items
FOR EACH ROW
BEGIN
 INSERT INTO item_prices_audit (item_id, price, changed_by, change_type)
 VALUES (NEW.item_id, NEW.item_cost, USER(), 'изменение цены');
END//
DELIMITER ;

-- Начало транзакции
START TRANSACTION;
-- Вставка тестовых данных для товаров
INSERT INTO items (item_name, item_cost) VALUES
 ('Товар A', 100.00),
 ('Товар B', 150.00),
 ('Товар C', 200.00),
 ('Товар D', 120.50),
 ('Товар E', 180.75),
 ('Товар F', 220.25),
 ('Товар G', 110.00),
 ('Товар H', 160.00),
 ('Товар I', 190.50),
 ('Товар J', 210.75);
-- Коммит транзакции
COMMIT;

-- Обновление цен для всех товаров (для демонстрации работы триггера)
UPDATE items SET item_cost = 105.00 WHERE item_id = 1;
UPDATE items SET item_cost = 155.00 WHERE item_id = 2;
UPDATE items SET item_cost = 205.00 WHERE item_id = 3;
UPDATE items SET item_cost = 125.50 WHERE item_id = 4;
UPDATE items SET item_cost = 185.75 WHERE item_id = 5;
UPDATE items SET item_cost = 225.25 WHERE item_id = 6;
UPDATE items SET item_cost = 115.00 WHERE item_id = 7;
UPDATE items SET item_cost = 165.00 WHERE item_id = 8;
UPDATE items SET item_cost = 195.50 WHERE item_id = 9;
UPDATE items SET item_cost = 215.75 WHERE item_id = 10;

-- Вывод данных для проверки
SELECT * FROM items;
SELECT * FROM item_prices_audit;
```

Результат выполнения запроса

```sql
SELECT * FROM item_prices_audit;
```

| audit_id | item_id | price | change_date | changed_by | change_type |
|----------|---------|-------|----------------------|------------------|-----------------|
| 1 | 1 | 105.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 2 | 2 | 155.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 3 | 3 | 205.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 4 | 4 | 126.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 5 | 5 | 186.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 6 | 6 | 225.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 7 | 7 | 115.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 8 | 8 | 165.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 9 | 9 | 196.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |
| 10 | 10 | 216.00| 2024-09-11 20:41:11 | root@localhost | изменение цены |

## Вопрос 3

3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:

```sql
SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID = NULL
 AND LOCATION_ID = (
 SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL'
 )
 AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
```

## Ответ 3

Запрос содержит несколько ошибок. Исправленная версия должна выглядеть:

```sql
SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
 JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
 AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
```

### Исправления подробнее:

1. **JOIN**: Заменены неявные соединения (использование запятых в `FROM` условии) на явные `JOIN` операторы для улучшения читаемости и поддерживаемости запроса.

2. **IS NULL**: Заменено условие `MANAGER_ID = NULL` на `MANAGER_ID IS NULL`, так как сравнение с `NULL` должно выполняться с использованием `IS NULL`.

3. **HAVING**: Использован оператор `HAVING` вместо `WHERE` для фильтрации по агрегатной функции `SUM(E.SALARY)`. `HAVING` используется для фильтрации результирующих строк, когда необходимо применять условия к агрегированным данным (например, `SUM`, `COUNT` и т.д.).

4. **GROUP BY**: Добавлено группирование по `D.DEPARTMENT_ID` и `D.DEPARTMENT_NAME`, так как в `SELECT` выражении используются агрегатные функции (`SUM(E.SALARY)`).

## Вопрос 4

В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?

## Ответ 4

Карандаш на полу в комнате не является просто карандашом. Это - символ творческой энергии и вдохновения, который не подлежит преодолению физическими средствами. Прыжок через него означал бы не просто перепрыгивание предмета, а совершение акта творческого вдохновения.
В этом свете попытка перепрыгнуть через карандаш на полу приведет к мгновенной трансформации комнаты в олимпийский спортивный объект, где каждый прыжок становится частью арт-перформанса ""Маленький прыжок для человека, но гигантский скачок для карандаша"".",
21,119.docx,.docx,docx,"Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки. Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах). Таблица имеет следующую схему:
clients ( client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте );
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему мнению некорректно и какие изменения внесли бы.
Вывод:
Я считаю, что данная база данных не практичная, поэтому решилась переделать её, сделав более оптимальной и удовлетворяющей требованиям.
Листинг:
DROP DATABASE IF EXISTS Magaz;
CREATE DATABASE Magaz;
use Magaz;
CREATE TABLE gorod (
g_id int(100)NOT NULL AUTO_INCREMENT,
g_name varchar(255)NOT NULL,
PRIMARY KEY (g_id)
);
CREATE TABLE client (
client_id int(100) NOT NULL AUTO_INCREMENT,
client_surname varchar(255)NOT NULL,
client_name varchar(255)NOT NULL,
login varchar(30)NOT NULL,
age_number tinyint unsigned NOT NULL,
reg_date timestamp default current_timestamp,
gorod_id int(100)NOT NULL,
PRIMARY KEY (client_id),
FOREIGN KEY (gorod_id) REFERENCES gorod(g_id) ON DELETE CASCADE ON UPDATE CASCADE
);
INSERT INTO gorod
VALUES (58,'Пенза'), (150,'Москва'), (92,'Санкт-Петербург');
select * from gorod;
INSERT INTO client (client_surname,client_name,login,age_number,gorod_id)
VALUES ('Алёшина','Анна','AnnaA',20,(select g_id from gorod where g_name='Пенза'));
INSERT INTO client (client_surname,client_name,login,age_number,gorod_id)
VALUES ('Сорокина','Елена','Sorchka',25,(select g_id from gorod where g_name='Санкт-Петербург'));
select * from client;
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки. Вы обратили внимание на таблицу с информацией о товарах магазина. Таблица имеет следующую схему:
items ( );
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
Глядя на эту таблицу, вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах, например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года. Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое хранение стоимости товара?
Вывод:
Для данной базы я создала дополнительную таблицу, в которую записывается вся история цен.
Листинг:
DROP DATABASE IF EXISTS Price;
CREATE DATABASE Price;
use Price;
CREATE TABLE items (
item_id int(100) NOT NULL AUTO_INCREMENT,
item_name varchar(255) NOT NULL,
PRIMARY KEY (item_id)
);
CREATE TABLE histori (
item_id int(100) NOT NULL,
price_cost int(100) NOT NULL,
price_id int(100) NOT NULL AUTO_INCREMENT,
price_date timestamp default current_timestamp,
PRIMARY KEY (price_id),
FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE CASCADE ON UPDATE CASCADE
);
INSERT INTO items
VALUES (12,'Арбуз'), (13,'Дыня'), (14,'Тыква');
select * from items;
INSERT INTO histori (item_id,price_cost,price_id)
VALUES (12,110,112), (13,99,113), (14,85,114);
INSERT INTO histori (item_id,price_cost,price_id)
VALUES (12,100,212), (13,89,213), (14,80,214);
select * from items;
select * from histori
order by item_id;
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Вывод:
Данный код я переписала как посчитала правильным в соответствии с заданием.
Листинг:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) as TOTAL_SALARY
FROM EMPLOYEES E
inner join DEPARTMENTS D on E.EMPLOYEES_ID=D.DEPARTMENTS_ID
WHERE E.MANAGER_ID is NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_NAME,D.DEPARTMENT_ID
WHERE SUM(E.SALARY) > 100000;
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Вывод:
К данному вопросу можно строить множество различных теорий, так как нет точных вводных данных. Например, можно предположить, что мы находимся в разных комнатах с карандашом. Или, как вариант, он мог укатиться к стене, и его будет невозможно перепрыгнуть. На данный вопрос нет однозначного ответа.",
22,120.pdf,.pdf,pdf,"1. Измененная структура:
create table clients (
client_id number primary key, -- уникальный идентификатор рекомендуется сделать
первичным ключом
client_name varchar(255), -- поле корректно
client_surname varchar(255), -- поле корректно
client_gender varchar(10), -- добавить пол для формирования предложения
продуктов
login varchar(30) unique, --как правило, логин клиента в магазине должен быть
уникальным
client_email varchar(255), -- добавить контактные данные клиента для настройки
рекламы
client_phone_number varchar(255), -- добавить контактные данные клиента для
настройки рекламы
city_id number, -- поле корректно, если существует таблица-справочник городов с
id и названиями
birth_date date, -- добавить дату рождения
age number, -- поле само по себе некорректно, так как возраст-динамическая
переменная. Можно оставить, если вычислять возраст как extract(year from age(now(),
birth_date)) as age
reg_date date – поле коректно,
);
2. Я бы предложила создать таблицу-справочник с ценами PRICES со следующей
структурой:
create table prices (
item_id number, -- id товара
price_id number primary key, -- id записи цены
item_cost number, -- стоимость товара
item_cost_dif number, -- процент изменения цены по сравнению с прошлым
значением
cost_dif_type varchar(255), -- тип скидки
start_date date, -- дата начала действия цены
end_date date, -- дата завершения действия цены
foreign key (item_id) references items(item_id)
);
Актуальное значение цены из этого справочника (с самой поздней датой создания и
пустой датой завершения) будет отражаться в ITEMS:
create table items (
item_id number primary key, -- уникальный id товара
item_name varchar(255), -- наименование товара
price_id number primary key, -- id записи цены
item_cost number -- текущая стоимость товара
);
3. Ошибки: отсутствует as при присвоении алиаса, нет явного указания таблиц, из
которых выбираются атрибуты (особенно критично для department_id), неправильно
указано название таблицы employees, соединение таблиц должно осуществляться при
помощи оператора join on, условия задаются после оператора where, проверка на пустое
значение задается как is null, при наличии агрегатной функции другие атрибуты в select

должны также войти в агрегатные функции или group by, для отбора условие для суммы,
вычисляемой с помощью агрегата, нужно указать в операторе having, а не where.
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM (E.SALARY) >= 100000
4. Перепрыгнуть карандаш не получится, если его положили в угол или под стену,
также если, например, он лежит на полу под столом, или прыгающий находится в другой
части комнаты и не сможет допрыгнуть физически, или потолок в комнате настолько
низкий, что можно только проползти над карандашом.",
23,1205245524.docx,.docx,docx,"Задание 1
Вместо поля age я бы внесла данные о дате рождения клиента, чтобы была возможность предоставлять для него скидки и акции к празднику. Поле birthdate тип date.
Для client_id можно добавить значение NOT NULL, чтобы ограничить применение значения NULL и сделать его PRIMARY KEY.
Также ограничения NOT NULL добавить в поля login, client_name, client_surname, birthdate.
Присвоить полю city_id FOREIGN KEY.
Задание 2
Добавление поля sale number (3,2), хранящим скидку в процентах и start_cost number, хранящим начальную стоимость. Это обеспечит наглядное понижение стоимости в праздники.
Создать еще одну связанную таблицу, содержащую дату изменения цен и саму цену для каждого товара.
history (
change id number NOT NULL PRIMARY KEY
date_change date NOT NULL
item_id number FOREIGN KEY
old_cost number NOT NULL
new_cost number NOT NULL
)
На самом деле new_cost можно не хранить, записывая только предыдущее значение цены. Новое всегда можно узнать из актуальной таблицы или следующей записи (если цена вновь изенилась).
Задание 3
Исправленный запрос:
SELECT D.DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID IS NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_NAME
HAVING SUM(SALARY) >= 100000
Задание 4
Невозможно перепрыгнуть через карандаш, потому что он лежит в некоторой закрытой комнате, к которой мы не имеем доступа.",
24,121.docx,.docx,docx,"- необходимо добавить атрибут PRIMARY KEY к столбцу с уникальными id клиентов;
- столбец с возрастом клиента age необходимо заменить на столбец с информацией о дате рождения клиента. Так, со временем актуальность данных не пропадет;
- также стоит добавить колонку с email для связи с клиентом или рассылки информации;
- добавить атрибут UNIQUE колонкам, поля которых должны быть уникальными – login, email
Таблица имеет следующую схему:
clients (
client_id number PRIMARY KEY, -- уникальный id клиента
client_name varchar(255), -- имя клиента
client_surname varchar(255), -- фамилия клиента
login varchar(30) UNIQUE NOT NULL, -- уникальный логин, который придумал клиент
email varchar(255) UNIQUE NOT NULL -- уникальный email
city_id number, -- id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
birth_date date, -- возраст клиента
reg_date date -- дата регистрации на сайте
);
2.
Перед нами стоят 2 задачи:
- обеспечить историчность данных о ценах на товары и сделать это удобным для финансовых отчетов
- обеспечить хранение информации об акциях и скидках
Для обеспечения исторического хранения изменений цены товара в базе данных можно использовать метод SCD2 и выделить информацию о ценах в отдельную таблицу.
items_costs (
item_id number, -- уникальный id товара
ivent_id number, -- уникальный id акции или NULL, если цена установлена вне акции
item_cost number -- стоимость товара
item_cost_date_from date -- дата установки стоимости товара
item_cost_date_to date -- дата, до которой актуальна стоимость товара
current_flag char (1) default 'Y' -- флаг актуальности текущей записи ('Y'/'N')
);
items (
item_id number, -- уникальный id товара
item_name varchar(255), -- наименование товара
…
);
ivents (
ivent_id number, -- уникальный id акции
ivent_name varchar(255), -- наименование акции
ivent_info varchar(255), -- краткая информация
);
- колонка current_flag упростит поиск актуальной цены товара при запросах.
- колонка ivent_id будет содержать информацию в рамках акции ли установлена новая цена и
ссылаться на отдельную таблицу с информацией об акции.
- таблицу items можно наполнить информацией о товаре.
3.
SELECT E.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY E.DEPARTMENT_ID,
D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
4.
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Я нахожусь в другой комнате или даже в здании напротив таким образом, что вижу карандаш, но добраться до него не могу.
Или:
Карандаш на самом деле представляет собой какой-то огромный объект (скульптуру), который я не могу физически перепрыгнуть.",
25,122.docx,.docx,docx,"Тип данных number без указания точности и масштаба будет использовать максимально возможное значение точности и масштаба, а значит занимать больше памяти и замедлять работу базы в целом. Лучше указать какое-то фиксированное значение, например, number(10) у client_id, если вообще не сделать это значение типа int.
Ещё считаю, что стоит включить в таблицу столбец с email пользователя.
Ещё я бы заменил столбец city_id на столбец city_name с типом varchar, в котором будут храниться полные названия городов. Использование id города подразумевает, что мы должны использовать отдельную таблицу, связанную с основной, где будут храниться city_id и city_name. Мне кажется, такой подход не рационален и не стоит загружать базу отдельной таблицей.
Я считаю, что удобным вариантом хранения истории стоимости товара будет являться создание второй таблицы price_history. В ней мы укажем 5 столбиков:
Чтобы показать актуальную цену, её столбец second_date будет равняться null. Для столбца price при желании можно указать бОльшую точность и масштаб.
Таким образом легко можно будет выполнить запрос:
Который покажет актуальную цену для товара с item_id=2 из таблицы items. Когда мы добавим новую цену в таблицу price_history, мы сможем легко обновить данные в таблице items через использование вложенного запроса:
Когда же нам потребуется цена товара за определенный промежуток для создания отчета, например, за 2018-ый год, то мы сможем легко достать данные подобным запросом:
В данной задаче исправленный код должен выглядеть следующим образом:
В исходном варианте была неверно употреблена агрегирующая функция в операторе WHERE, агрегирующие функции используются вместе с оператором HAVING. Ещё была неправильно употреблена проверка значения NULL, она осуществляется с помощью операторов IS NULL или IS NOT NULL. Ещё не было уточнения, к каким именно таблицам относятся одинаковые столбцы, в таком случае нужно указывать название таблицы перед названием столбца через точку.
Потому что он лежит у стены, ведь тогда при прыжке мы ударимся об стену.",
26,123.pdf,.pdf,pdf,"1. В cient_id я бы использовал тип INT с автоинкрементом, так было бы
проще
В login нужно сделать UNIQUE чтобы логины у разных клиентов не
повторялись
Если есть логин, то также нужен и пароль. Номер телефона и почта тоже
не были бы лишними
В city_id нужно добавить внешний ключ со ссылкой на таблицу городов
(если это не учтено в тестовом задании)
Aage лучше заменить на дату рождения, потому что возраст
перезаписывать каждый раз неудобно
Можно в reg_date указать тип DATETIME, чтобы была и дата и время
В столбцах с именем, фамилией, логином, мейлом, паролем NOT NULL.
2. Можно создать отдельнуюд таблицу с датами начала действия цена и
окончания (item_prices) и перед этим убрать в таблице items колонку
item_cost:
CREATE TABLE item_prices (
price_id INTEGER PRIMARY KEY AUTOINCREMENT,
item_id INTEGER NOT NULL,
price NUMBER NOT NULL,
start_date DATE NOT NULL,
end_date DATE, (может быть пустым, потому что цена
актуальна до сих пор)
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
3. Нельзя писать = с NULL, нужно IS NULL.
SUM(SALARY) >= 100000, такие функции нельзя использовать с WHERE,
вместо этого используем HAVING
FROM A, B WHERE A.id = B.id лучше заменить на JOIN, чтобы понятнее
было, например:

FROM EMPLOYEES e JOIN DEPARTMENTS d ON e.DEPARTMENT_ID =
d.DEPARTMENT_ID JOIN LOCATIONS l ON d.LOCATION_ID =
l.LOCATION_ID WHERE e.MANAGER_ID IS NULL
4. Возможно, потому что после того как карандаш упал на пол, он
укатился к одной из стен и прижался к ней, либо карандаш закатился
под дверь. В таком случае не получится перепрыгнуть карандаш",
27,1231245.docx,.docx,docx,"4. В любой комнате есть углы, так что карандаш упал в угол и через него нельзя перепрыгнуть ни в одном из направлений. Если карандаш закатился под высокий предмет, то его тоже нельзя будет перепрыгнуть.
Если комната необычная или есть дополнительные условия, то ответ может быть практически любым.
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Запрос для таблиц, находящихся в schema HR:
SELECT d.DEPARTMENT_ID,
d.DEPARTMENT_NAME,
SUM(e.SALARY) AS TOTAL_SALARY
FROM HR.EMPLOYEES e
JOIN HR.DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN HR.LOCATIONS l ON d.LOCATION_ID = l.LOCATION_ID
WHERE e.MANAGER_ID IS NULL
AND l.CITY = 'SEOUL'
GROUP BY d.DEPARTMENT_ID, d.DEPARTMENT_NAME
HAVING SUM(e.SALARY) > 100000
ORDER BY d.DEPARTMENT_NAME;
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она или можно внести
некоторые доработки.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости
товара?
(в PostgreSQL нет типа number, так что я заменила так, чтобы можно было проверить именно в PostgreSQL)
Поскольку менять можно только архитектуру таблицы, то:
items (
item_id INTEGER, -- уникальный идентификатор товара (генерируется автоматически)
item_name VARCHAR(255) NOT NULL, -- наименование товара
item_cost INTEGER NOT NULL, -- цена товара в копейках
valid_from DATE NOT NULL, -- дата начала действия текущей цены
valid_until DATE, -- дата окончания действия текущей цены (NULL, если цена актуальна)
PRIMARY KEY (item_id, valid_from) -- составной первичный ключ
);
Таким образом, изначально строка будет примерно такой:
{'1', ‘Молоко’, 12099, '2025-04-10', NULL}, если изменить цену, то надо обновить запись до такой и добавить вторую запись:
{'1', ‘Молоко’, 12099, '2025-04-10', ‘2025-04-19’},
{'1', ‘Молоко’, 13099, '2025-04-19', NULL}
Если бы я создавала БД с самого начала, то добавила бы serial для автоматической генерации уникальных значений, но поскольку в БД могут быть записи, то лучше не ставить SERIAL, так как логика создания айди для товара может быть более сложной, чем присвоение порядкового номера.
Цену товара лучше хранить в копейках, так легче проводить операции над ценами. При выводе цены можно будет возвращать ее к стандартному виду.
Первичный ключ составной, потому что записи с одним товаром могут повторяться, как показано выше.
1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она или можно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите, что по-вашему мнению некорректно и какие изменения внесли бы.
(в PostgreSQL нет типа number, так что я заменила так, чтобы можно было проверить именно в PostgreSQL).
clients (
client_id INTEGER PRIMARY KEY,
client_name VARCHAR(50) NOT NULL,
client_surname VARCHAR(50) NOT NULL,
login VARCHAR(30) UNIQUE NOT NULL,
city_id INTEGER NOT NULL CHECK(city_id>0),
age SMALLINT CHECK(age BETWEEN 18 AND 100),
reg_date DATE NOT NULL,
FOREIGN KEY(city_id) REFERENCES cities(city_id)
);
Если бы я создавала БД с самого начала, то добавила бы serial для автоматической генерации уникальных значений, но поскольку в БД могут быть записи, то лучше не ставить SERIAL, так как логика создания айди для клиента может быть более сложной, чем присвоение порядкового номера.
Уменьшила ограничение на длину имени и фамилии.
Можно установить проверку для возраста, допустим, покупки можно совершать только с 18 лет CHECK(age BETWEEN 18 AND 115), к тому же таким образом не будет отрицательных значений.
Лучше сделать логин уникальным - (UNIQUE(login)), чтобы пользователи не могли регистрироваться с одинаковыми логинами.
city_id – тип данных зависит от того, с какими клиентами работает магазин. Если только из России, то можно ограничится числом 1125, если нет, то INTEGER хватит, чтобы вместить все города в мире.
К reg_date добавлено NOT NULL, поскольку дата регистрации точно должна быть, если клиент где-то регестрировался. Ее не может не быть.
Внешний ключ на город указан, но его тип обозначен как число, что предполагает связь с другой таблицей городов. Необходимо явно создать такую связь, если она еще не существует.
Можно было бы еще включить телефон и электронную почту
 email VARCHAR(100) UNIQUE, -- дополнительный уникальный email
phone_number VARCHAR(20), -- номер телефона клиента
Но и без них таблица выглядит корректно.",
28,124.pdf,.pdf,pdf,"1.
Представьте, что вы устроились работать дата-инженером в некоторый
интернет магазин. До вас в этой компании уже работал один разработчик,
который придумал небольшую базу данных для этого магазина и потом неожиданно
уволился. Ваша задача провести проверку существующей архитектуры и решить
корректна ли она или можно внести некоторые доработки. Вы обратили внимание
на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
CREATE TABLE clients (
client_id NUMBER, -- уникальный id клиента
client_name VARCHAR(255), -- имя клиента
client_surname VARCHAR(255), -- фамилия клиента
login VARCHAR(30), -- логин, который придумал клиент
city_id NUMBER, -- id города
age NUMBER, -- возраст клиента
reg_date DATE -- дата регистрации на сайте
);
На мой взгляд, не совсем правильно подобраны типы данных для столбцов:
client_id — все зависит от того, насколько большая база данных, как ее используют, в
какой СУБД она находится и планируется ли (однажды) миграция с одной СУБД в другую
Из-за того, что у нас нет тех полей, которые могли бы использоваться в качестве
естественного первичного ключа (например, поля email / phone_num), будем
использовать искусственный первичный ключ
Представим, что у нас PostgreSQL. Обычный id serial primary key — все еще
решение, но тут могут возникнуть проблемы с безопасностью данных (но не только лишь
с ней). Из-за последовательной нумерации могут быть различные утечки информации, в
том числе информации довольно коммерчески чувствительной + это может дать
преимущественно злоумышленникам, которые могут перебирать айди. Например, если
идентификатор легко доступен в API / URL. Условно, легко будет найти профиль
покупателя с id 1. И если он есть, значит скорее всего будет и 2, и 3, и так далее
Если интернет-магазин камерный, мощность используемой техники ограничена + важна
скорость взаимодействия с БД, а перехода с Postgres не планируется — я бы
использовал bigserial. Есть запас под рост БД, и в случае, когда значения id перерастет

диапазон обычного int, нам не придется ничего менять на продакшне, когда БД уже
будет под нагрузкой. Если же магазин набирает обороты, бизнес растет, важна
безопасность данных, а в планах есть серьезное масштабирование или перенос БД в
другую СУБД — я бы выбрал uuid — id default gen_random_uuid() primary key. Здесь
важно понимать контекст.
client_name — varchar(20). Ограничение в 20 символов для имени более чем
достаточно, как кажется
client_surname — varchar(20). То же самое, что и с именами
login — varchar(20). Важно уточнить — мы не можем позволить себе дублирование
логинов. Поэтому нужно будет либо добавить constraint unique_login unique (login),
либо на этапе создания БД указать, что login должен быть уникальным, и что нельзя
принимать дубликаты. С учетом того, что ДЕ в интернет магазине только лишь “придумал”
БД, скорее всего, будем писать create table :)
city_id — здесь можно обойтись int. Вряд ли уникальных значений будет больше, чем
позволит integer. Большинство реальных случаев, особенно если система работает на
уровне страны или региона, не потребуют значительного количества уникальных городов.
Даже если расширять географию до нескольких стран, int будет достаточно
age — int. Вряд ли потребуется дробное значение возраста
reg_date — date. Но стоит понимать, что такой тип подходит, если важны только даты
регистрации, без учета времени. Если же есть шанс, что потребуется анализ времени
регистрации, то стоит подумать над тем, чтобы сменить тип на timestamp. 4 байта vs 8 —
есть повод поразмышлять.
CREATE TABLE clients (
client_id UUID DEFAULT gen_random_uuid() PRIMARY KEY, -- уникальный id
клиента
client_name VARCHAR(20), -- имя клиента (до 20 символов)
client_surname VARCHAR(20), -- фамилия клиента (до 20 символов)
login VARCHAR(20) UNIQUE, -- логин клиента с ограничением по уникальности
city_id INT, -- идентификатор города
age INT, -- возраст клиента
reg_date DATE -- дата регистрации
);
2.

Представьте, что вы устроились работать Дата-инженером в некоторый
интернет магазин. До вас в этой компании уже работал один разработчик,
который придумал небольшую базу данных для этого магазина и потом неожиданно
уволился. Ваша задача провести проверку существующей архитектуры и решить
корректна ли она, или можно внести некоторые доработки. Вы обратили внимание
на таблицу с информацией о товарах магазина. Таблица имеет следующую схему:
... items (
item_id number, -- уникальный id товара
item_name varchar(255), -- наименование товара
item_cost number -- стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена,
если не каждый день, то каждый месяц может меняться. К примеру, сезонные
повышения цен или наоборот скидки (перед началом учебного года или новым
годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в
котором сотрудникам нужно строить различные отчёты (о доходах, например) за
разные промежутки времени, в том числе и за прошлые месяцы, и даже прошлые
года. Как бы вы доработали архитектуру таблицы, чтобы обеспечить
историческое хранение стоимости товара?
Для решения задачи можно сделать дополнительную таблицу, которая будет хранить
историю цен товаров. Здесь снова необходимо задуматься, что использовать в качестве
айдишников для товаров — int vs bigint. Если интернет магазин — не маркетплейс
или агрегатор, а сторонний магазин со своими товарами, количество которых определено,
то можно использовать int, существенно повышая общую производительность и
эффективность запросов к БД. Но если количество товаров не определено, и есть шанс,
что их общее количество превысит допустимый диапазон int, то тогда лучше сразу
использовать bigint. Представим, что это маленький интернет магазин, которые продает
товары собственного производства. Поэтому, выберу int. В качестве айди для истории
цен я в том числе выберу int, поскольку предполагаю, что фиксировать историю цен
будут вручную и не чаще, чем раз в месяц. В ином случае, стоит выбрать bigint — цена
не слишком велика, зато не придется лишний раз задумываться о масштабируемости
-- таблица для хранения информации непосредственно о товарах
CREATE TABLE items (
item_id SERIAL PRIMARY KEY, -- уникальный id товара
item_name VARCHAR(255) -- наименование товара
);
-- таблица для хранения истории изменений стоимости

CREATE TABLE item_price_history (
price_id SERIAL PRIMARY KEY, -- уникальный id записи о цене
item_id INT, -- ID товара
item_cost NUMERIC(10, 2), -- стоимость товара
start_date DATE, -- дата начала действия цены
end_date DATE, -- дата окончания действия цены (NULL для текущей стоимости)
FOREIGN KEY (item_id) REFERENCES items(item_id) -- связь с таблицей items
);
-- записываем новую цену
INSERT INTO item_price_history (item_id, item_cost, start_date, end_date)
VALUES (1001, 500, TO_DATE('2024-05-15', 'YYYY-MM-DD'), NULL);
-- обновляем старую запись
UPDATE item_price_history
SET end_date = TO_DATE('2024-09-22', 'YYYY-MM-DD')
WHERE item_id = 1001 AND end_date IS NULL;
-- добавляем новую запись
INSERT INTO item_price_history (item_id, item_cost, start_date, end_date)
VALUES (1001, 450, TO_DATE('2024-09-22', 'YYYY-MM-DD'), NULL);
Теперь можно будет проследить историю изменения цен, строить отчеты. Когда данных
станет слишком много, их можно будет разбивать на отдельные БД. С учетом любви к
отчетам за прошлые года — удалять данные не вариант. Их можно архивировать
CREATE TABLE archived_price_history (
price_id SERIAL PRIMARY KEY,
item_id INT,
item_cost NUMERIC(10, 2),
start_date DATE,
end_date DATE,
);
INSERT INTO archived_price_history
SELECT * FROM item_price_history WHERE start_date < '2024-01-01';
DELETE FROM item_price_history WHERE start_date < '2024-01-01';
Ну, и чтобы избежать дубликатов, можем добавить constraint unique_item_data unique
(item_id, start_date), чтобы избежать ошибок при случайной вставке одинаковых
записей

3.
Требуется проверить запрос на корректность и исправить там ошибки, если они
есть. Существует учебная схема HR, содержащая таблицы: employees, departments
и locations. Необходимо получить все отделы, расположенные в Сеуле в которых
все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более
100000 у.е. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (
SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL'
)
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Неадекватно присоединяются таблицы; нет необходимости в where прописывать
e.department_id = d.department_id, это нужно было делать в джойне; для проверки
значения на NULL надо использовать оператор is null; нет необходимости делать
подзапрос, потому что мы джойним табличку с локациями по ключам; в where нельзя
прописывать агрегатные функции; в group by пропущена колонка department_name.
Исправленный запрос ↓
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;

4.
В некоторой комнате на пол уронили карандаш. Объясните, почему вы не можете
через него перепрыгнуть?
Если мы уделяем внимание семантическому наполнению каждого слова в формулировке
вопроса, то ключевое значение здесь будет иметь выражение “не можете” — если мы
реально не можем, значит есть какое-то физическое ограничение, которое мы не можем
преодолеть. Например, карандаш в углу / у стены / под объемным объектом (и чтобы
перепрыгнуть через карандаш, нужно перепрыгивать через этот самый объект) / в воде /
далеко от субъекта, который должен этот карандаш перепрыгнуть.
С другой стороны, мы можем сказать, что перепрыгивать его нет никакого смысла,
поскольку мы можем его перешагнуть. Не можем через него перепрыгнуть, потому что эта
мысль абсурдна настолько, что попросту не появляется в голове. Оттого мы через него не
прыгаем.",
29,124273.docx,.docx,docx,"1:
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
(три вверху относятся к клиенту, к ним может быть обращение из каких либо СRМ и лучше держать их в отдельной таблице, первичный ключ: client_id number )
login varchar(30), --логин, который придумал клиент
(один выше это внутренние-персональные данные, используемые для доступа\безопасности. Его вынести отдельно к соответствующим данным часть из которых будет зашифрована + отдельно необходим механизм защиты для них, первичный ключ: client_id number)
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
(три выше это данные по клиенту которые могут использоваться для анализа\рассылок\рекламы и соответственно вынести в отдельную таблицу, чтобы не затрачивать ресурсы подгружая лишние данные, первичный ключ: client_id number)
2:
создать таблицу с айди товара
датой изменения
цены на которую она изменилась
Первая строчка будет у всех ""отправной точкой""(то есть занесём первые данные)
Дальше при изменении цены, добавляем
При просмотре отчёта, чтобы взять интересующую нас цену по которой продавался товар в определённый период (например 2004:12:1) если дата попадает в промежуток, то для расчёта берём сумму которая находится на ""верхнем"" значении промежутка (1 на скриншоте)
3: 
(ниже есть вариант как правильно написать, где есть ошибки там выделил жёлтым цветом)
SELECT DEPARTMENT_ID, (определить чье E\D тк не понимает)
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, (добавить S тк называется EMPLOYEES)
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID (использовать JOIN, помню там было чтото про произведения значений, если брать из двух таблиц)
AND MANAGER_ID = NULL (использовать IS NULL)
AND LOCATION_ID = (SELECT (добавить ANY после равно) + (вопрос: LOCATION_ID есть в D? Если нет то необходимо будет использовать ещё один JOIN )
LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL') (для строковых использовать LIKE вместо равно)
AND SUM(SALARY) >= 100000 (использовать HAVING, для работы с «обработанными» данными)
GROUP BY DEPARTMENT_NAME (идет выше HAVING)
Написано должно быть так:
SELECT D.DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEES E
JOIN
DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE
MANAGER_ID IS NULL
AND LOCATION_ID = ANY (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY LIKE 'SEOUL')
GROUP BY DEPARTMENT_NAME
HAVING SUM(SALARY) >= 100000
4:
физическое\прикладного типа препятствие это около стены карандаш\потоки по мой рост поэтому я не смогу сделать прыжок
или
иного типа препятствие это я не знаю где данная комната\я не могу попасть в эту комнату так как она закрыта\карандаш сломался разделившись на две и более частей, поэтому нет возможности полноценно выполнить условие",
30,125.txt,.txt,text,"Задание 1. По порядку:
client_id : используется уникальный идентификатор, подразумевается, что он является первичным ключом.
client_name и client_surname : если поля не допускают пробелы или спец. символы.
Нужно добавить проверки на уровне базы данных или приложения, для того, чтобы убедиться,
что данные соответствуют ожидаемому формату.
login : желательно, чтобы логин содержал допустимые символы и был ограничен по длине, а также был уникальным.
Нужно добавить проверки на корректность заполнения, а также сделать его уникальным.
city_id : Если таблица городов не существует или внешний ключ не установлен,
нужно создать таблицу cities и добавить соответствующий внешний ключ
age : Хранение возраста может быть проблематичным, так как он меняется со временем.
Лучше хранить дату рождения (birth_date), а возраст вычислять при необходимости.
reg_date : Если дата регистрации автоматически устанавливается текущей датой, то всё хорошо.

Пример выполнения:
CREATE TABLE clients (
 client_id NUMBER PRIMARY KEY, -- Уникальный идентификатор клиента
 client_name VARCHAR(255) NOT NULL, -- Имя клиента
 client_surname VARCHAR(255) NOT NULL, -- Фамилия клиента
 login VARCHAR(30) UNIQUE NOT NULL, -- Логин клиента, должен быть уникальным
 city_id NUMBER, -- Идентификатор города
 birth_date DATE, -- Дата рождения клиента
 reg_date DATE DEFAULT SYSDATE, -- Дата регистрации, по умолчанию текущая дата
 CONSTRAINT fk_city FOREIGN KEY (city_id) REFERENCES cities(city_id) -- Внешний ключ для города
);

Задание 2. Создадим следующие таблицы:
Таблица товаров(item_cost будет храниться в item_prices):

CREATE TABLE items (
 item_id NUMBER PRIMARY KEY, -- Уникальный идентификатор товара
 item_name VARCHAR(255) NOT NULL -- Наименование товара
);

Таблица истории цен:

CREATE TABLE item_prices (
 price_id NUMBER PRIMARY KEY, -- Уникальный идентификатор записи о цене
 item_id NUMBER, -- Идентификатор товара
 price NUMBER, -- Стоимость товара
 start_date DATE, -- Дата начала действия цены
 end_date DATE, -- Дата окончания действия цены (NULL, если цена действующая)
 CONSTRAINT fk_item FOREIGN KEY (item_id) REFERENCES items(item_id) -- Внешний ключ на таблицу товаров
);

Тогда запрос для получения текущей цены будет выглядеть так:
SELECT price FROM item_prices WHERE item_id = :item_id AND end_date IS NULL;

а для исторических цен так:

SELECT price, start_date, end_date FROM item_prices WHERE item_id = :item_id ORDER BY start_date;

Задание 3. 
1. В SQL проверка на NULL выполняется командой IS NULL.
2. Использовать SUM в секции WHERE невозможно, вместо этого нужно использовать HAVING после группировки.
3. Если группируем по DEPARTMENT_NAME, то также нужно включить DEPARTMENT_ID.
4. Нужно добавить таблицу locations и объединить её с другими таблицами.

SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
 AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;

Задание 4. Карандаш упал около стены.",
31,12524245.pdf,.pdf,pdf,"Подольский Иван Алексеевич
Задание 1.
В целом, набор полей таблицы корректен, однако стоит поменять поле age,
обозначающее возраст клиента, на поле client_birth_date, отвечающее
за дату его рождения. Так как мы заполняем age на стадии добавления
пользователя в базу данных, то значение остаётся таким же на протяжении
долгого времени, пока мы его каким-либо образом не изменим. Вполне
возможно, что нам понадобится наиболее актуальная информация о
возрастах клиентов (например, для аналитики), но в случае с полем age в базе
будет хранится некорректная информация для пользователей, которых мы
добавили ранее, а посчитать возраст клиентов можно будет и через запрос.
Поэтому и стоит поменять поле, хранящее возраст клиента на поле с датой
его рождения.
Задание 2.
Кажется, стоит завести отдельную от items таблицу item_prices, где
хранить историю изменения цен.
Предлагаемая схема:
Убрать из items поле со стоимостью:
items (
item_id number primary key,
item_name varchar(255)
)
Сделать таблицу для учёта цен:
item_prices (
item_id number FOREIGN KEY REFERENCES
items(item_id),
price number,
valid_from date,
valid_to date

Подольский Иван Алексеевич
)
В такой таблице можно будет хранить историю цен для одного и того же
товара, информация о которой может понадобиться для составления отчётов.
Задание 3.
В запросе есть следующие ошибки:
 нет группировки по DEPARTMENT_NAME (есть группировка
DEPARTMENT_ID и агрегация TOTAL_SALARY);
 некорректная проверка MANAGER_ID на равенство NULL;
 WHERE нельзя использовать для фильтрации групп ( AND
SUM(SALARY) >= 100000 );
 я не уверен, но скорее всего лучше связать таблицы JOIN-ами, так как
в исходном варианте таблицы связаны неявно, вполне возможно
берутся не те поля.
Вариант исправленного запроса:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
Задание 4.
Через карандаш не получится перепрыгнуть, если он упал и лежит вплотную

Подольский Иван Алексеевич
к стене. При попытке прыжка в обычной комнате мы просто ударимся о
стену и вряд ли перепрыгнем карандаш.",
32,125378.docx,.docx,docx,"Вопрос 1.
Исходя из текста вопроса, я предполагаю, что база данных состоит из нескольких связанных таблиц, и мы рассматриваем одну конкретную таблицу, которая хранит информацию о зарегистрированных клиентах. Поэтому далее я не предлагаю добавление истории покупок, потраченной суммы и другими данными, полезными для маркетинга. Также я считаю, что в текущем виде таблица clients хранит именно те данные, которые нужны владельцу БД, в связи с чем не будет предложений по добавлению колонок с новой информацией (например, пол, семейное положение и т.п.). Я предлагаю лишь исправления текущей архитектуры. В том случае, если таблица clients – единственная в БД, либо заказчик желает расширить набор хранимых данных, то рекомендации будут совершенно другими.
В представленной базе данных я вижу следующие проблемы:
Колонка client_id по своему смыслу является первичным ключом, причем значения в ней формируются как раз при заполнении данной таблицы. Однако, в схеме таблицы это не указано. Кроме того, текущий вариант схемы предполагает, что данное поле заполняется вручную, что не является хорошей идеей, поскольку может привести к возникновению дублей, некорректных либо избыточных значений.
В идеале нужно назначить данную колонку первичным ключом. Однако, в базе уже есть какие-то данные, а в столбце client_id могут быть дублирующие, непоследовательные либо пустые значения. В такой ситуации назначение ключа может привести к нарушению связей между таблицами БД. Поэтому предлагаю обходное решение – находим максимальное значение колонки client_id, затем модифицируем колонку, добавив автогенерацию со значения, следующего за максимальным.
Колонка city_id. В текущем виде данная колонка имеет смысл только в том случае, если в БД есть таблица с id и названиями городов. В этом случае для колонки city_id нужно указать, что она является внешним ключом. Если же таблицы с городами в БД нет, колонка city_id не имеет смысла – это просто набор цифр, по которому можно группировать данные, не получая при этом никакой практической пользы.
Колонка age. Судя по типу numeric, в данном поле хранится возраст клиента в виде числа, возможно даже вещественного. Исходя из смысла таблицы, предположу, что это возраст в годах на момент регистрации. В таком виде данные этой колонки имеет минимальную ценность – мы будем только знать, в каком возрасте к нам приходят клиенты. Также ручное заполнение ведет к ошибкам, не говоря уже о том, что некоторые люди предпочитают скрывать либо искажать свой возраст. Предлагаю создать колонку с типом date, содержащую дату рождения клиентов. Имея такую колонку, мы без труда сможем рассчитать актуальный возраст клиента при выгрузке данных и формировании аналитических отчетов.
Но остается вопрос - что делать с уже заполненным возрастом? Можно включить в личном кабинете этих клиентов запрос даты рождения, что обновит данные в таблице. Для тех, кто не указал, рассчитаем примерную дату рождения как дату регистрации минус указанный возраст. Также создадим дополнительный столбец булевого типа, в котором укажем True для клиентов, указавших дату рождения, и False для не указавших. Это позволит избежать неприятных ситуаций, например, при проведении маркетинговых акций на день рождения.
Предложил бы ограничить колонки с именами и фамилиями 50 символами. Вряд ли в этих колонках могут быть более длинные данные. Перед ограничением обязательно проверить размер имеющихся в таблице имен и фамилий.
Поскольку мы работаем с таблицей, в которой уже есть данные, все указанные изменения будут производиться при помощи запросов ALTER TABLE clients.
Если бы мы проектировали таблицу с нуля, то она бы имела такой вид (зеленым указаны отличия от первоначальной версии).
clients (
client_id number primary_key -- уникальный id клиента
client_name varchar(50), -- имя клиента
client_surname varchar(50), -- фамилия клиента
login varchar(30), -- логин
city_id number foreign_key -- id города
birth_date date -- дата рождения клиента
reg_date date -- дата регистрации на сайте);
Вопрос 2.
Аналогично предыдущему заданию, я предполагаю, что база данных состоит не только из предложенной таблицы. Поэтому очевидную рекомендацию по добавлению продаж не даю, работаем только с таблицей товаров. Предлагаю разделить таблицу с товарами и ценами на товары и цены отдельно. Реализовано это будет следующим образом.
В таблице items храним только id товара и его название. При этом id является первичным ключом, каждый товар в таблице уникален.
Создадим новую таблицу prices со списком полей: price_id (первичный ключ), item_id (внешний ключ к таблице items), price_date (дата установки цены), item_cost (стоимость товара).
Дополнительно предлагаю добавить в таблицу prices информацию о валюте. Тем более, что у нас интернет-магазин, а значит есть возможность работать не только с отечественными клиентами и товарами. Для этого создадим еще одну таблицу с идентификаторами и названиями валют (currencies), а таблицу prices дополним идентификатором валюты, который будет являться внешним ключом к таблице валют.
Ниже приведена схема того, как будут выглядеть новые таблицы.
Вопрос 3.
Ниже приведен код корректного, на мой взгляд, запроса к базе данных. Все исправления выделены зеленым. Для всех алиасов счел нужным добавить AS для того, чтобы запрос был более универсальным. Конечно, в PostgreSQL и MySQL запросы будут работать и без AS, но, к сожалению, я не знаком со всеми возможными диалектами языка, а поэтому не исключаю, что где-то отсутствие AS может привести к ошибке.
Что касается регистра, то исправил его только для таблиц, так как в формулировке задания названия таблиц указаны явно в нижнем регистре.
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM departments AS D
INNER JOIN employees AS E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID IN
(SELECT LOCATION_ID
FROM locations
WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(SALARY) > 100000
Вопрос 4.
Я смогу перепрыгнуть карандаш, если будет известно местоположение комнаты. Другие проблемы будем решать по мере поступления.",
33,126.txt,.txt,text,"1. Считаю данный набор и смысл полей корректным. Внес бы следующие изменения: 
 - Можно уменьшить максимальное количество вводимых символов, например до 50, в client_name и client_surname.
 - Логин сделать уникальным.
 - Возраст: добавить условие для возраста > 0

2. В качестве решения проблемы можно добавить новую таблицу, в которой будем хранить историю цен со следующими полями:
 items_id(id товара, связан с таблицей items); 
 price; 
 data_start(начало скидки); 
 data_end(конец скидки).

3. 1) Для проверки на NULL нужно использовать IS NULL, т.к. ""="" не работает с NULL. 
 Корректно будет - AND MANAGER_ID IS NULL
 2) Вместо AND SUM(SALARY) >= 100000 используем HAVING SUM(SALARY) >= 100000
 3) ""WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID"" можно заменить на JOIN DEPARTMENT_D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID.

4. Карандаш лежит возле стены.",
34,127.docx,.docx,docx,"Бадиков Александр Вячеславович
Задание Data Engineer
1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему
мнению некорректно и какие изменения внесли бы.
Ответ:
К данной таблице несколько вопросов:
Поле client_id – используется тип данных NUMBER. Данный тип данных содержит в себе не только целые, но и дробные числа, что совершенно не нужно для идентификаторов. Лучше использовать целочисленный тип данных. INTEGER. А также сделать это поле Primary Key.
Поля client_name, client_surname - к типу данных вопросов нет, но зачем разделять поля Имени и фамилии? А еще может у человека может быть отчество. Предлагается сделать поле client_full_name varchar(255). Для подавляющего числа клиентов должно хватить 255 символов.
Либо опционально можно добавить Поле с отчеством, хотя на мой взгляд – это излишне усложняет структуру.
Поле login varchar(30) –30 символов может оказаться ограниченным набором для пользователя. Можно увеличить число символов до 50. К тому же поле ОЧЕНЬ желательно сделать уникальным.
Поле city_id number - из задания не совсем понятно, существует ли отдельная таблица с полями city_id, city_name, но вероятно она должна быть. Также есть вопросы к типу данных. На мой взгляд INTEGER подошел бы лучше.
Поле age – получается, что клиент при регистрации вводит возраст и мы его сохраняем. А что делать через год, когда возраст поменяется? Лучше использовать поле с датой рождения в формате DATE. А то вдруг клиент отрицательный возраст введет в тип данных NUMBER, а мы и не заметим.
К полю reg_date вопросов у меня не возникло.
Также неплохо бы добавить еще поля client_email, а также phone_number для дополнительной идентификации клиентов.
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она или можно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
);
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
Глядя на эту таблицу, вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете, что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различные отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое хранение стоимости товара?
Проблема – в данной таблице хранится только актуальная цена и невозможно отследить историю и динамику цен на товары.
Выходом могла бы послужить отдельная таблица с историей цен. Ее структура была примерно следующей.
Id_cost – Primary Key
item_id INTEGER– уникальный ID товара. Кстати, его неплохо бы в обеих таблицах переделать в INTEGER.
item_cost NUMBER – цена товара
start_cost_date DATE – дата начала действия цены
finish_cost_date DATE – окончание действия цены. Теоретически, цена может поменяться несколько раз в день, поэтому, при желании можно поставить тип данных TIMESTAMP
Опционально можно добавить поле
cost_change_type_id – идентификатор типа изменения цены ( повышене, акция, сезонные скидки и т.д). Но тут придётся еще хранить отдельно расшифровки идентификаторов/
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы , расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Обнаруженные ошибки:
В условии говорится о сотрудниках, зарабатывающих более 100000, а в запросе используется условие >=.
Перечисление таблиц в FROM через запятую. Лучше и нагляднее использовать JOIN. И сразу же присоединить LOCATION.
AND MANAGER_ID = NULL – правильно нужно писать AND MANAGER_ID IS NULL
В GROUP BY необходимо добавить DEPARTMENT_ID
В FROM название таблицы указано неверно EMPLOYEE, вместо employees
Агрегирующие функции не работают в WHEREБ надо перенести их в HAVING
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES AS E
JOIN DEPARTMENTS AS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS AS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = ‘SEOUL’
GROUP BY D.DEPARTMENT_ID , D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >100000
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?
Тут несколько вариантов ответов приходят в голову.
я не знаю, что через него нужно прыгать - нет задачи.
я не знаю, где находится комната с карандашом.
карандаш слишком огромный и я физически не могу через него перепрыгнуть
я могу просто переступить через него, зачем мне затрачивать силы?
Карандаш уже кто-то украл
комната заперта и у меня нет ключа
в комнате низкий потолок и невозможно протиснуться между карандашом и потолком;
я не хочу прыгать через какой-то там карандаш
Я уехал в другой город и не могу сейчас приехать
Карандаш уронили и тут же подобрали
Пол, стены и потолок в комнате абсолютно упругие и карандаш скачет как сумасшедший. Он сам прыгает по всей комнате со скоростью света
Карандаш проломил пол и провалился под землю. В данный момент его местонахождение неизвестно
В здании случился пожар, всех эвакуировали, а карандаш сгорел",
35,128.docx,.docx,docx,"Поля с паролем не хватает, как я понимаю авторизовываться клиент по логину и паролю должен. А так, указанные поля имеют места быть в таблицы клиентов.
Я бы создал две таблицы:
items (
item_id number – уникальный id
item_name varchar(255) – наименование товара
)
prices (
price_id number – уникальный id
price_date timestamp - дата изменения цены и она становится текущей
item_id number – внешний ключ, связывающий id товара из таблицы items
price number – цена товара
)
Хоть нам и приходится делать запрос для предоставления данных о товарах и их ценах, используя обе таблицы, зато у отдела финансовой отчетности теперь есть возможность строить различные отчеты за разные промежутки времени.
Исправленный запрос:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) TOTAL_SALARY
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.MANAGER_ID IS NULL
AND D.LOCATION_ID IN (
SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000
С моральной точки зрения из-за совести бы не смог, лучше бы его поднять и отдать человеку, который его случайно уронил. С другой стороны, карандаш мог упасть так, что его физически не получится перепрыгнуть, например к стенке, так как мы находимся в комнате.",
36,129.txt,.txt,text,"1. 
 а) поменять тип поля client_id с number на INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY
 b) если поле city_id заполняестя только id города, поменял бы тип пна int unsigned, и создал бы таблицу cities c полями ID INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
 city_name VARCHAR(100)
со связью cities.id=clients.city_id
 c) тип поля age сменил бы на DATE, так как возраст меняется каждый год на +1

2.
 а) поменять тип поля item_id с number на INT UNSIGNED NOT NULL AUTO_INCREMENT
 b) поменять тип поля item_cost на DECIMAL(10, 2)
 с) для обеспечения хранения исторической стоимости я добавлю поля с датой начала действия цены и датой окончания действия цены. При изменении стоимости запись не должна обновляться, а добавляться новая запись с новой стоимостью и соответствующими датами начала и окончания действия. Таблица выглядит после изменения так:

item_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost DECIMAL(10, 2) –стоимость товара
start_date DATE,
end_date DATE

3. SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(E.SALARY) as TOTAL_SALARY добавил E. и as
FROM EMPLOYEE as E as убрал зпт
 JOIN DEPARTMENTS as D JOIN , as 
on E.DEPARTMENT_ID = D.DEPARTMENT_ID вместо WHERE - ON
 WHERE MANAGER_ID IS NULL AND на WHERE вместо = IS
JOIN locations as l добавил JOIN locations as l
ON l.DEPARTMENT_ID=D.DEPARTMENT_ID добавил связь таблиц (допустил что она есть, т.к. в условии задачи не прописаны архитектуры таблиц)
 WHERE LOCATION_ID = (SELECT LOCATION_ID AND на where 
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
 AND SUM(E.SALARY) > 100000 E. , убрал = (в условии больше 100000)
GROUP BY DEPARTMENT_NAME

4. Карандаш лежит вплотную к стене или в углу. 
 Из абсурдного: карандаш больше меня, меня нет в том же помещении, я и есть карандаш) и т.д.",
37,130.docx,.docx,docx,"I) Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить, корректна ли она или можно внести некоторые доработки. Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах). Таблица имеет следующую схему:
clients (
client_id number, -- уникальный id клиента
client_name varchar(255), -- имя клиента
client_surname varchar(255), -- фамилия клиента
login varchar(30), -- логин, который придумал клиент
city_id number, -- id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, -- возраст клиента
reg_date date -- дата регистрации на сайте
);
Поле client_id не PRIMARY KEY, отсутствует автоинкремент через GENERATED ALWAYS AS INDENTITY/ trigger/ DEFAULT nextval(‘seq_name’)
Использовать VARCHAR2 вместо VARCHAR
«VARCHAR Data Type
Do not use the VARCHAR data type. Use the VARCHAR2 data type instead. Although the VARCHAR data type is currently synonymous with VARCHAR2, the VARCHAR data type is scheduled to be redefined as a separate data type used for variable-length character strings compared with different comparison semantics (Data Types (oracle.com))»
Если отсутствует проверка на бэкенде, то следует добавить CHECK как минимум на возраст
II) Глядя на эту таблицу, вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Также вы знаете, что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различные отчёты (о доходах, например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года. Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
items (
item_id number, -- уникальный id товара
item_name varchar(255), -- наименование товара
item_cost number -– стоимость товара
);
Для обеспечения исторического хранения стоимости товара можно использовать SCD type 2. Например, добавив дополнительную таблицу, содержащую стоимость товаров в зависимости временного интервала
Также для более детальной аналитики необходимы и другие таблицы. Пример:
III) Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Отредактированный запрос:
SELECT d.department_id,
d.department_name
FROM departments d
JOIN employee e ON e.department_id = d.department_id
WHERE e.manager_id IS NULL
AND d.location_id = (SELECT location_id
FROM location
WHERE city = 'SEOUL')
GROUP BY d.department_id, d.department_name
HAVING SUM(e.salary) > 100000;
IV)
Карандаш упал в комнате, к которой нет доступа (например, она закрыта на ключ),
Неизвестно, в какой комнате он упал, если не было звука падения,
В полу была щель, в которую карандаш провалился и укатился куда-то под полом,
Потолок очень низкий, не позволяющий совершить прыжок,
Карандаш укатился к стене впритык (если мы рассматриваем вариант, что под «перепрыгнуть карандаш» мы подразумеваем перепрыгивание перпендикулярно),
Пол – это лава,
Карандаш был сделан из антиматерии и аннигилировался, вступив во взаимодействие со стандартной материей,
Пол в комнате с большим уклоном, при падении карандаш начинает катиться достаточно быстро для того, чтобы человек не успевал его догнать и перепрыгнуть.
Record_id | Item_id | Item_cost | Start_date | End_date
N | 1 | 100 | 2000-01-01 | 2000-03-01
N+1 | 1 | 120 | 2000-03-01 | NULL
N+2 | 2 | 50 | 2000-01-01 | NULL",
38,131.docx,.docx,docx,"Тестовое задание
по курсу Beginner Data Engineer
(осенний набор 2024)
by Neo study
1. Считаю что данный набор и смысл полей некорректным. Я поменял бы тип данных колонки client_id на bigserial (самоувеличивающийся номер), а у city_id на integer(int).
1) Убрал бы колонки name и surname, а вместо них сделал одну fio(varchar(50)).
2) Добавил бы колонку sex (varchar(6)).
3) Убрал бы колонку age, вместо нее добавил бы birth_date(date), так как возраст клиента можно узнать с помощью простого SQL-запроса.
2. Я бы добавил в базу данных, согласно типу 4 SCD, еще одну таблицу (items_arh), которая бы хранила старые данные о цене. Согласно концепции главная таблица перезаписывается новыми данными, что позволяет всегда иметь актуальные данные о цене на товар под рукой. А старые данные заносятся в таблицу items_arh, что позволяет отслеживать историчность.
3. Есть ряд ошибок:
1) MANAGER = NULL. Правильно будет MANAGER IS NULL
2) По условию задачи SALARY должно быть строго > 100000, а не >= 100000.
3) MAX(SALARY) нужно перенести в HAVING
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL AND D.LOCATION_ID = (
SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
4. Самое первое что пришло в голову – то что карандаш при падении неудачно откатился к стене и поэтому при попытке перепрыгнуть мы просто ударяемся о стену и возвращаемся на исходную.
Еще вариант – то что карандаш находится в комнате этажом(этажами) выше, а наше перемещение ограничено только площадью своей комнаты.
Еще вариант – то что при падении карандаш разломился на несколько частей и эти части оказались удалены друг от друга на достаточное расстояние не позволяющее перепрыгнуть их все одновременно.",
39,132.txt,.txt,text,"1.
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age DATE, --возраст клиента
reg_date date –дата регистрации на сайте

2.
Отдельая таблица 

3.
SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, 
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 AND MANAGER_ID = NULL
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS 
 WHERE CITY = 'SEOUL')
 AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME

4. 
Карандаш у стены",
40,133.doc,.doc,error,,Unsupported extension: .doc (file=133.doc)
41,134.docx,.docx,docx,"Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
выбирается название города, а в таблицу сохраняется id)
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему мнению некорректно и какие изменения внесли бы.
ОТВЕТ:
Я бы внес некоторые изменения такие как:
Добавил Not Null для всех полей.
Добавил Primary Key для id клиента
Добавил Unique для login
Добавил поле для хранения пароля
Изменил age на birth_date поскольку каждый год пришлось бы вручную менять число лет пользователя
Добавил связь с таблицей cities для поля city_id
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
ОТВЕТ:
Я бы создал вторую таблицу для цен с добавлением дат начала продажи по этой цене и ее конца.
item_prices (
item_id NUMBER REFERENCES items(item_id) NOT NULL, -- Внешний ключ
cost NUMBER NOT NULL, -- Стоимость на момент периода
start_date DATE NOT NULL, -- Дата начала действия цены
end_date DATE, -- Дата окончания (NULL для текущей цены)
PRIMARY KEY (item_id, start_date)
);
Так же я бы внес некоторые правки в первую таблицу items
Убрал стоимость
Добавил для поля item_name not null
Добавил для item_id primary key
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
ОТВЕТ:
Вот измененная версия:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
L.CITY = 'Seoul'
AND E.MANAGER_ID IS NULL
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
ОТВЕТ: Либо я нахожусь в другой комнате и не имею доступа к нужной, либо карандаш закатился под шкаф, стол или что-то иное, через что я не могу перепрыгнуть.
client_id | number, --уникальный id клиента
client_name | varchar(255), --имя клиента
client_surname | varchar(255), --фамилия клиента
login | varchar(30), --логин, который придумал клиент
city_id | number, --id города, который указал клиент (в интерфейсе
age | number, --возраст клиента
reg_date | date –дата регистрации на сайте",
42,135.docx,.docx,docx,"Задание 1
id SERIAL, либо INT UNSIGNED AUTO INCREMENT - в зависимости от СУБД
first_name VARCHAR(50),
last_name VARCHAR(50),
birth_date DATE - необходимо знать возраст клиента
login VARCHAR(30),
email VARCHAR(50),
phone VARCHAR(30),
city_id INT,
age INT,
red_date datetime - аналитикам иногда полезно знать не только дату, но и время регистрации
verification_phone_number boolean - прошел ли пользователь верификацию по мобильному телефону
verification_email boolean - прошел ли пользователь верификацию по электронной почте
Задание 2
Приведение таблицы к типу SCD2, с добавлением двух полей start_dttm и end_dttm, позволят отслеживать в какие дни изменялась цена.
id SERIAL, либо INT UNSIGNED AUTO INCREMENT - в зависимости от СУБД
product_name VARCHAR(128),
category_id INT, - внешний ключ на таблицу с категориями товаров
brand VARCHAR(128)
description VARCHAR(128),
price numeric,
count INT, - количество товара в наличии
start_dttm datetime
end_dttm datetime
Задание 3
SELECT D.DEPARTMENT_NAME AS department_name,
SUM(t1.SALARY) AS total_salary
FROM (
SELECT DEPARTMENT_ID,
SALARY
FROM EMPLOYEES AS e
JOIN LOCATIONS AS l ON e.location_id = l.id
WHERE MANAGER_ID IS NULL AND l.id IN (SELECT id
FROM LOCATIONS
WHERE CITY = 'SEOUL)
) t1
JOIN DEPARTMENTS AS d ON t1.DEPARTMENT_ID = d.id
GROUP BY D.DEPARTMENT_NAME
HAVING SUM(t1.SALARY) > 100000
Задание 4
Я не смогу перепрыгнуть карандаш в том случае, если карандаш будет лежать вплотную к стене.",
43,136.docx,.docx,docx,"Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите, что по Вашему мнению некорректно и какие изменения внесли бы.
Ответ:
Если это подразумевается вопросе, то добавить primary key и autoincrement для client_id.
Ограничить количество символов в client_name – 20 (для имени должно хватить), client_surname до 45-50 (подстраховка для двойных фамилий), так как 255 для них будет слишком много; а для логина 30 вероятнее всего хватит. Дату регистрации перевести в формат timestamp, если мы часто будем с ней взаимодействовать и что-то высчитывать; возможно какие-то бонусы за срок пользования услугами магазина, присвоение статуса/уровня для тех же бонусов и скидок, или значок-достижение как в Steam (если какая-то геймерская тематика/девайсы/магазин игровых ключей и т.д.), например.
Age – в формате date, чтобы знать день и месяц рождения пользователя, а возраст можно будет посчитать.
С City_id либо вписываем сразу название города, и делаем просто City, иначе будет непонятно, какой город означает цифра. Либо нужна новая таблица, где за каждым id будет закреплён город, и чтобы при выборке можно было сделать join городов. А city_id во втором случае в таблице clients сделать foreign_key.
Так как это интернет-магазин, хотелось бы ещё добавить номер телефона: phone_number – varchar(20). И почту, для разных рассылок, уведомлений о статусах покупки/доставки, или хотя бы электронных чеков: email – varchar(40). Сюда же пол: sex – varchar(10).
Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
);
item_id number, --уникальный id товара item_name varchar(255), --наименование товара item_cost number –стоимость товара
Глядя на эту таблицу, Вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете, что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различные отчёты (о доходах, например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое хранение стоимости товара?
Ответ:
Добавить primary key и autoincrement для item_id.
Удалить item_cost, цены и их изменения будут в отдельной таблице.
Добавить таблицу изменения цен – price_change. Item_id – указать как foreign key. Добавить дату изменения цены – price_change_date – date. И столбец с ценами – new_price – number. Чтобы найти последнюю цену, нужно применить фильтр по дате и соединить с таблицей items.
Item_name сократить до 100, чтобы длинные названия с деталями (граммы, кол-во в наборе, характеристики краткие) помещались, но и не слишком много ресурсов тратилось. И если название будет длиннее, то оно уже слишком длинное.
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations. Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS
WHERE CITY = 'SEOUL') AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Ответ:
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000
P.S. Возможно нужно убрать из SELECT - DEPARTMENT_ID и TOTAL_SALARY, т.к. «необходимо получить все отделы». Но для удобства чтения и понимания вывода оставил столбцы.
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Ответ:
Карандаш оказался в углу, из-за чего его не получится перепрыгнуть ни вдоль, ни поперёк.
Если просто у стены, то слева направо вдоль стены можно будет это сделать.",
44,137.pdf,.pdf,pdf,"Задание 1.
Данные в таблице cli(cid:7)nts избыточны. Для начала хотелось бы разделить
данную структуру на более конкретные таблицы, например:
– Персональная информация, где отражались бы поля с именем,
фамилией, возрастом и городом пользователя;
– Регистрационные данные, где отражалась бы такая информация как
логин и дата регистрации.
Затем хотелось бы изучить данные о поле cit(cid:34)_id и понять откуда
берутся данные идентификатора города. Правильно было бы иметь отдельную
таблицу,котораябысодержалаidгородаипрочуюнеобходимуюинформацию
о нем, в том числе и название города. Если такой таблицы нет, то данное поле
не представляет никакой полезной информации о клиенте. Если же подобная
таблица имеется, то поле cit(cid:34)_id должно быть помечено как внешний ключ.
Похожая ситуация и с полем cli(cid:7)nt_id, которое должно быть помечено
как первичный ключ. В добавок, если база данных позволяет, то неплохо было
бы добавить автоинкремент на данное поле.
Для поля (cid:3)g(cid:7) необходимо было добавить ограничения на возраст
клиента, хотя бы на запрет ввода отрицательных значений.
Аналогично и с полем r(cid:7)g_d(cid:3)t(cid:7). Для него хорошо было бы иметь триггер
на проверку добавления корректной даты регистрации иначе пользователь
может зарегистрироваться в будущем или в момент, когда регистрация еще не
работала, то есть в прошлом. Хорошей практикой было бы добавить
стандартное значение для этого поле на текущую дату.
Помимо выше перечисленного отсутствуют ограничения на NULL
значения, хотя в некоторых полях, таких как cli(cid:7)nt_n(cid:3)m(cid:7), cli(cid:7)nt_surn(cid:3)m(cid:7), l(cid:22)gin,
r(cid:7)g_d(cid:3)t(cid:7).
В рамках системы можно было бы также добавить указание
уникальностинаполеl(cid:22)gin,таккакданныедляавторизациивсистемедолжны
быть у каждого пользователя уникальными.
Ну и размер поля l(cid:22)gin в количестве 30 символов мне кажется может
быть недостаточным, поэтому я бы его увеличил бы хотя бы до 40-50
символов.
Задание 2.
Я бы предложил создать таблицу, хранящую исторические данные о
стоимости товаров, где для каждого изменения цены была бы прикреплена
своя временная метка. Так как эта таблица получилась бы очень огромной, то

можно было бы реализовать секционирование данной таблицы, чтобы
получать только данные из необходимых сегментов.
Для составлений различных отчетов для отделов компании можно
использовать витрину данных, чтобы в ней хранить только ту информацию,
которая будет нужна соответствующему отделу.
Для таблицы it(cid:7)ms я бы предложил не хранить стоимость товара, а
отражать ее только в таблице, где будут фиксироваться изменения цен на
товар. В самой таблице оставить только поля it(cid:7)m_id и it(cid:7)m_n(cid:3)m(cid:7). Данные
предложение будет полезно только в случае, если данных об изменении
стоимости товара не слишком много. В случае, если записей об изменении
будет храниться большое количество, то лучше оставить в таблице it(cid:7)ms поле
it(cid:7)m_c(cid:22)st, чтобы исключить j(cid:22)in для получения актуальной стоимости. Это
будет более производительное решение.
Задание 3.
В условии указано:
Здесь происходит присоединение данных из двух таблиц по ключевому
полю, а для этого необходимо использовать не запятую, а ключевое слово
JOIN, а из условия W(cid:73)(cid:55)R(cid:55) убрать: «(cid:55).D(cid:55)(cid:50)(cid:61)R(cid:81)M(cid:55)N(cid:81)_ID =
D.D(cid:55)(cid:50)(cid:61)R(cid:81)M(cid:55)N(cid:81)_ID», так как этому условию должно предшествовать
ключевое слово ON.
При указании в S(cid:55)L(cid:55)C(cid:81) столбца D(cid:55)(cid:50)(cid:61)R(cid:81)M(cid:55)N(cid:81)_ID может произойти
неоднозначное обращение, поэтому нужно точно указать из какой таблицы
(D(cid:55)(cid:50)(cid:61)R(cid:81)M(cid:55)N(cid:81) или (cid:55)M(cid:50)LOY(cid:55)(cid:55)) брать D(cid:55)(cid:50)(cid:61)R(cid:81)M(cid:55)N(cid:81)_ID.
ВусловииW(cid:73)(cid:55)R(cid:55)используетсяагрегатнаяфункция,котораяпритаком
формировании запроса выдаст ошибку о невозможности использования
агрегатной функции к конструкции W(cid:73)(cid:55)R(cid:55). Для этого необходимо либо
указать: «SUM(S(cid:61)L(cid:61)RY) >= 100000» в блоке (cid:73)(cid:61)VING, либо использовать
подзапрос.
В конструкцию GROU(cid:50) (cid:58)Y необходимо добавить столбец
D(cid:55)(cid:50)(cid:61)R(cid:81)M(cid:55)N(cid:81)_ID.
Итоговый запрос с исправлениями должен выглядеть следующим
образом:

Задание 4.
У меня есть несколько предположений:
1. Карандаш лежит либо рядом со стеной, либо где-то под таким
предметом,которыйневозможноперепрыгнуть,напримерхолодильник;
2. В задаче не сказано где я нахожусь и, возможно, я просто не нахожусь
в той же комнате.",
45,138.txt,.txt,text,"Задание 1
Обязательно:
1. client_id должен являться первичным ключем, то есть первую строку поменяем на ""client_id number primary key""
2. Поскольку логин, вероятнее всего, используется для входа в систему, отображения статистики и тд, то он должен быть уникальным, соответственно четвертую строку поменяем на ""login varchar(30) unique""
3. Вместо хранения возраста клиента нужно хранить дату его рождения, поменяем шестую строку на ""birth_date date""

Желательно:
1. Добавить поле поле email для связи с клиентом и возможностью восстановить доступ к сервису: ""email varchar(255) unique"", также возможно стоило бы добавить еще и поле для номера телефона.
2. Добавить поле ""male bool"", для того чтобы, к примеру, в личном кабинете были обращения на он / она. В нашем современном мире, возможно, стоило быть заменить это поле на ""gender varchar(255)""
3. Добавить поле ""last_login date"" для отслеживания активности пользователя.

Задание 2
Я бы добавил таблицу, в которой будут храниться все изменения цен на товары, к примеру, она могла бы выглядеть так:
item_price_history (
 item_id number,
 start_date date,
 end_date date,
 item_cost number,
 PRIMARY KEY (item_id, start_date),
 FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Таким образом мы не увеличим количество запросов к базе данных, когда обычные пользователи открывают каталоги, но добавим возможность аналитикам / бухгалтерам работать с историей изменения цен.
При изменении цен будут выполняться такие запросы:

UPDATE items 
SET current_cost = var
WHERE item_id = var;

UPDATE item_price_history
SET end_date = SYSDATE
WHERE item_id = var AND end_date IS NULL;

INSERT INTO item_price_history (item_id, start_date, end_date, item_cost)
VALUES (var, SYSDATE, NULL, var);

Задание 3
SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
 AND D.LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID,
HAVING SUM(E.SALARY) >= 100000;

Задание 4
Карандаш упал вдоль стены, соответственно перепрыгнуть через него (вперед) невозможно.
Или же можно рассмотреть кучу других вариантов, например: это был гигантский карандаш с диаметром 2 метра и среднестатистический челочек не сможет перепрыгнуть через него.",
46,139.pdf,.pdf,pdf,"1) Префикс ""client_"" для атрибутов избыточный (имхо, в коде на ооп яп
проектируя класс точно бы так не стал делать), название сущности понятно
из названия таблицы.
Для ""уникальный id клиента"" лучше выбрать тип на основе sequence или даже
uuid подумав еще над суррогатным ключом который не будет высвечивать из
базы данных вообще.
Для ""city_id"" спорное решение с опорой на клиентский интерфейс, нужно
уточнить откуда интерфейс берет информацию по городам, возможно хранить в
нашей таблице непосредственно название города.
Опционально для ""age"", если клиенты только представители рода
человеческого, то можно сэкономить на типе данных применив tinyint.
Не хватает контактной информации.
""reg_date"" не очень удачное сокращение и от суффикса date можно
изавиться. Опционально добавить дату последнего посещения.
Добавить булевый или битовый флаг неактивного (удаленного) пользователя
(пригодится что бы не терять ценную инфу о клиентах делая delete при
такой необходимости).
2) Вероятно, затеял бы еще таблицу ссылающуюся на идентификаторы товаров
для цен учитывая историчность и в товарах бы не хранил эту информацию.
Таблица items_costs (
id generated,
item_id number -- ссылка на ключ таблицы товаров, один товар ко
многим стоимостям
cost number,
started_at datetime
)
таким образом, получать информацию о товаре с актуальной ценой можно
соединяя таблицы в запросе с условием последней item_costs.started_at,
ну и в целом используя разные условия, группировки и агрегатные функции
получать необходимую аналитику.
3)
SELECT D.DEPARTMENT_ID
, D.DEPARTMENT_NAME
, SUM(E.SALARY) TOTAL_SALARY
FROM EMPLOYEE E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID
WHERE L.CITY = 'SEOUL' AND
E.MANAGER_ID IS NULL
GROUP BY D.DEPARTMENT_ID
, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
4) Карандаш упал возле препятствия, например вплотную к стене или
достаточно высокой мебели.",
47,140.docx,.docx,docx,"Изменения:
Вместо поля age следует сохранять дату рождения, т.к. возраст меняется, а также значения будут неуникальные.
Поле login следует сделать уникальным
Проверить является ли city_id внешним ключом для связи с таблицей городов.
Добавить поле email или phone в зависимости от того, как что используется для регистрации пользователей и контакта с ними.
client_name, client_surname можно объединить в одно поле или уменьшить длину строки.
Для исторического хранения стоимости товара стоит добавить таблицу
item_costs, в которой будут поля:
item_cost_id number,
item_cost_value number,
start_time timestamp,
end_time timestamp
В таблице items поле item_cost будет связано с таблицей item_costs по внешнему ключу.
Следует добавить триггер, чтобы при добавлении новой цены в таблицу item_costs, в предыдущем значении цены этого товара end_time заполнялось текущей датой и временем.
Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) AS TOTAL_SALARY
FROM DEPARTMENTS D
LEFT JOIN
EMPLOYEE E
USING(DEPARTMENT_ID)
WHERE MANAGER_ID IS NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(SALARY) > 100000
Карандаш расположен у стены",
48,141.pdf,.pdf,pdf,"Задание 1.
Предлагаю внести следующие корректировки:
1. Поле client_id сделать ключевым PRIMARY KEY, тип SERIAL
2. Добавить ограничения NOT NULL для полей client_name, client_surname, login
3. Сделать размеры полей client_name, client_surname меньше, например varchar(50)
4. Поле sity_id типа int
5. Поле age типа int4
6. Внешний ключ sity_id ссылается на city_id в таблице cities
Новая таблица выглядела бы так:
clients (
client_id SERIAL PRIMARY KEY, --уникальный id клиента
client_name varchar(50) NOT NULL, --имя клиента
client_surname varchar(50) NOT NULL, --фамилия клиента
login varchar(30) NOT NULL, --логин, который придумал клиент
city_id int, --id города, который указал клиент (в интерфейсе выбирается название города, а в
таблицу сохраняется id)
age int4, --возраст клиента
reg_date date –дата регистрации на сайте
FOREIGN KEY (city_id) REFERENCES cities(city_id)
);
Задание 2.
Предлагаю добавить поля start_date и end_date, что позволит хранить устаревшие версии цен. Для
актуальных цен установить end_date по умолчанию, например «01.01.9999».
Обновленная таблица имеет следующую схему:
items (
item_id int PRIMARY KEY, --уникальный id товара
item_name varchar(255) NOT NULL, --наименование товара
item_cost decimal –стоимость товара
start_date datetime – дата установления цены
end_date datetime – дата конца версии записи
);
Задание 3.
Для корректной работы запроса предлагаю:
1. Добавить JOIN для соединения таблиц E и D
2. Добавить условие соединения ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
3. «=NULL» заменить на IS NULL
4. Так как нужно получить зарплату в общей сложности по всему отделу,
SUM(E.SALARY) >= 100000 нужно вывести в HAVING после группировки
5. Ко всем названиям полей добавить ссылки на таблицы

Запрос со внесенными исправлениями:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000
Задание 4.
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него
перепрыгнуть?
Зависит от ситуации и контекста. Чтобы ответить на вопрос, нужно знать подробности
случившегося. Могу предположить следующие варианты:
1. Карандаш уронили в другой комнате, не в той, в которой я нахожусь;
2. Карандаш уронили на пол под столом, соответственно, физически затруднительно;
3. Возможно, я не умею прыгать.",
49,14172.txt,.txt,text,"1. По таблице clients вместо поля age с возрастом логичнее хранить дату рождения, так же я считаю не хватает полей с адресом электронной почты и адресом для доставки 
2. В таблицу items я бы добавила 2 поля: с датой начала и с датой завершения действия цены, при этом поле завершения действия цены должно быть nullable, потому что для актуальной на текущую дату цены дата завершения будет null 
3. SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY FROM EMPLOYEE E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID WHERE E.MANAGER_ID IS NULL AND D.LOCATION_ID IN ( SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL' ) GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME HAVING SUM(E.SALARY) >= 100000 
4. Нет уточнения, что и карандаш, и человек находятся в одной комнате",
50,142.pdf,.pdf,pdf,"Задание 1.
Можно внести следующие изменения:
- Поменять тип данных client_id на int либо serial и добавить идентификатор primary key.
- В зависимости от бизнес-требований вместо поля age можно добавить поле birth_date с типом
данных timestamp, чтобы можно было подсчитать возраст пользователя в будущем, либо оставить
age с типом данных smallint.
- Добавить к login ограничение unique, если это требуется.
- Тип данных city_id тоже стоит изменить с number на int.
- Если есть таблица с городами, добавить к city_id внешний ключ на id города в той таблице.
Задание 2.
Для того чтобы обеспечить доступ к данным об
изменении цен, можно создать новую таблицу
price_history с полями id, item_id, price, start_date,
end_date, которая будет содержать информацию
с промежутками времени, в которых цена была
фиксирована. В таблицe items же будет
храниться только действующая цена товара.
Задание 3.
SELECT d.department_id, d.department_name, SUM(salary) as total_salary
FROM
department d
JOIN employees e on d.department_id=e.department_id
WHERE location_id = (SELECT location_id FROM locations WHERE city = 'Seoul')
AND manager_id IS NULL
GROUP BY d.department_id, d.department_name
HAVING SUM(salary) > 100000
Задание 4.
- Комната слишком маленькая для прыжка
- Карандаш не видно на полу
- Карандаш слишком большой
- Карандаш провалился через пол
- Установлен запрет на прыжки через карандаши",
51,14223837.pdf,.pdf,pdf,"Представьте, что вы устроились работать Дата-инженером в некоторый интернет
магазин. До вас в этой компании уже работал один разработчик, который
придумал небольшую базу данных для этого магазина и потом неожиданно
уволился. Ваша задача провести проверку существующей архитектуры и решить
корректна ли она илиможно внести некоторые доработки. Вы обратили внимание
на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему: clients ( client_id number, --уникальный id
клиента client_name varchar(255), --имя клиента client_surname varchar(255), --
фамилия клиента login varchar(30), --логин, который придумал клиент city_id
number, --id города, который указал клиент (в интерфейсе выбирается название
города, а в таблицу сохраняется id) age number, --возраст клиента reg_date date –
дата регистрации на сайте ); Считаете ли вы данный набор и смысл полей
корректным? Если нет, то напишите что повашему мнению некорректно и какие
изменения внесли бы.
1. Поле login должно быть уникальным, чтобы избежать проблем с
дублированием и аунтификацией
2. Добавить внешний ключ, ссылающийся на таблицу городов.
3. Поле age, использовал бы дату рождения, а не возраст. Позволит создавать
вариативные и более сложные запросы с возрастом.
4. Добавить поле для отслеживания активности клиентов.
5. Добавил бы в поле reg_date еще и время регистрации.
Представьте, что вы устроились работать Дата-инженером в некоторый интернет
магазин. До вас в этой компании уже работал один разработчик, который
придумал небольшую базу данных для этого магазина и потом неожиданно
уволился. Ваша задача провести проверку существующей архитектуры и решить
корректна ли она илиможно внести некоторые доработки. Вы обратили внимание
на таблицу с информацией о товарах магазина. Таблица имеет следующую схему:
items ( ); item_id number, --уникальный id товара item_name varchar(255), --
наименование товара item_cost number –стоимость товара Глядя на эту таблицу вы
вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день,
то каждый месяц может меняться. К примеру, сезонные повышения цен или
наоборот скидки (перед началом учебного года или новым годом). Так же вы
знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам
нужно строить различные отчёты (о доходах например) за разные промежутки

времени, в том числе и за прошлые месяцы и даже прошлые года. Как бы вы
доработали архитектуру таблицы, что бы обеспечить историческое хранение
стоимости товара?
Чтобы обеспечить историческое хранение стоимости товара - необходимо
создать новую таблицу, которая будет хранить информацию о ценах, их
изменениях и временном диапазоне их действия.
item_prices ( price_id number PRIMARY KEY, -- уникальный идентификатор записи о
цене
item_id number, -- ссылка на товар
item_cost number, -- стоимость товара
start_date date, -- дата начала действия цены
end_date date, -- дата окончания действия цены
FOREIGN KEY (item_id) REFERENCES items(item_id) -- внешний ключ на таблицу
товаров );
Требуется проверить запрос на корректность и исправить там ошибки, если они
есть. Существует учебная схема HR, содержащая таблицы: employees,
departments и locations Необходимо получить все отделы0, расположенные в
Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей
сложности более 100000. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) TOTAL_SALARY FROM
EMPLOYEE E, DEPARTMENTS D WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND
MANAGER_ID = NULL AND LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS
WHERE CITY = 'SEOUL') AND SUM(SALARY) >= 100000 GROUP BY DEPARTMENT_NAME
SELECT
D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E

JOIN
DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE
E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY =
'SEOUL')
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
4. карандаш упал в угол комнаты.",
52,142275.docx,.docx,docx,"Задание 1.
Для client_id лучше сделать тип данных int или serial вместо number, city_id сделать типа int.
Хранить возраст числом не лучшая идея, поскольку он меняется каждый год, соответственно удобнее будет вместо age сделать поле birthday типа date.
Для имени и фамилии клиента 255 символов ‒ слишком много, можно уменьшить до 50-70.
Можно вместо логина использовать электронную почту, чтобы не проверять лишний раз уникальность, а также сохранить контактную информацию о клиенте.
Задание 2.
Чтобы обеспечить историческое хранение стоимости товара, можно вынести цены в отдельную таблицу, а в таблице items оставить общую информацию о товаре (item_id, item_name, по необходимости item_description).
Тогда в другой таблице будут поля: price_id, item_id (ссылается на items), price, date_from, date_to. Таким образом, будут видны даты, когда та или иная цена была актуальной, что позволит анализировать историю изменения цен.
Задание 3.
Исправленный запрос:
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E
JOIN DEPARTMENTS D ON E. DEPARTMENT_ID = D. DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000 ;
Задание 4.
Потому что карандаш лежит в углу/прямо у стены/под мебелью.
Или например потому что у меня сломана нога и я не могу прыгать…",
53,1422777.txt,.txt,text,"1. 
В целом таблица clients отражает почти всю нужную информацию о клиенте, но я бы сделала небольшие изменения в ней. 

- добавить пол клиента:

 ALTER TABLE clients
 ADD COLUMN gender VARCHAR(6);

- поменять поле age на birth_date, чтобы постоянно не обновлять поле age:

 ALTER TABLE clients
 DROP COLUMN age;

 ALTER TABLE clients 
 ADD COLUMN birth_date DATE;

- добавить ограничения PRIMARY KEY на столбец client_id:

 

2. 
Предлагаю следующие изменения в таблицу items:

- добавить поля valid_from и valid_to, чтобы указать в какой период данная цена была актуальной:

 ALTER TABLE items
 ADD COLUMN valid_from DATE NOT NULL -- дата, когда текущая цена была установлена 
 ADD COLUMN valid_to DATE; -- дата, когда текущая цена была изменена

- добавить поле record_id, чтобы в таблице был простой первичный ключ:
 
 ALTER TABLE items
 ADD COLUMN record_id int; -- идентификатор для каждой записи в таблице

 ALTER TABLE items
 ADD PRIMARY KEY (record_id);
 
- изменить тип данных поля item_cost на decimal:

 ALTER TABLE items 
 ALTER COLUMN item_cost TYPE decimal (10,2);
3.
SELECT D.DEPARTMENT_ID, -- уточнить неоднозначные поля
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) TOTAL_SALARY
 FROM EMPLOYEE E,
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND E.MANAGER_ID IS NULL -- для проверки остуствия значения используется IS NULL
 AND D.LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000 -- для ограничения с аггрегированными функциями используется HAVING

4. 
Я не могу перепрыгнуть через карандаш потому, что:
 - я не в этой комнате;
 - карандаш упал вплотную к стене;
 - карандаш закатился под шкаф.",
54,142427223.docx,.docx,docx,"Я бы добавил ограничения к типам данных. К примеру для поля client_id тип данных number можно поменять на integer/bigint, а также добавил бы автоинкремент для генерации уникальных идентификаторов(client_id serial primary key).
Для поля client_name и client_surname можно было бы уменьшить количество символов до 100, так как 255 слишком много (client_name varchar(100), client_surname varchar(100)).
Поле login сделал бы уникальным (login varchar(30) unique).
Поле age поменял бы на birth_date и хранил бы в нем дату рождения вместо количества полных лет, это дало бы больше гибкости при работе с возрастом (birth_date date).
Если есть отдельная таблица под города cities, тогда нужно добавить связь с этой таблицей через внешний ключ (foreign key (city_id) references cities(city_id)).
Возможно создал бы отдельную таблицу для городов, если такая не имеется.
Если осуществляется поиск по полям client_name и client_surname, то можно было бы создать индексы для ускорения поиска.
Можно было бы добавить новые поля, отталкиваясь от необходимости. К примеру поля для номера хранения номера телефона, почты, статуса клиента.
Для хранения историю изменения цен на товары, я бы создал отдельную таблицу вместо того, чтобы хранить ее в таблице items. В таблице добавил бы поле с уникальным id для записи о цене, поле внешний ключ с id товара, который ссылается на items, 2 поля даты для хранения временного интервала, в котором цена действовала, и поле для цены товара.
В таком случае, в таблице items нужно было бы убрать поле item_cost.
AND MANAGER_ID = NULL. Для проверки на Null нужно писать “is Null”.
Условие SUM(SALARY) >= 100000 нужно убрать из WHERE и добавить в HAVING после GROUP BY (HAVING SUM(E.SALARY) > 100000;).
Карандаш находится у стены.",
55,142727.pdf,.pdf,pdf,"1)
client_id – тип number может быть избыточен, можно использовать обычный integer;
client_name и client_surname – длина varchar(255) избыточна как для фамилии так и для
имени, можно уменьшить длину до более разумных занчений;
age – хранить непосредственно возраст не совсем корректно тк это значение устаревает со
временем, лучше хранить дату рождения birth_date и от неё считать текущий возраст;
также в качестве улучшений можно ввести в таблицу поля с контактной информацией,
например email varchar(255), phone varchar(25);
2)
Для отслеживания изменения цен в добавок к основной таблице items можно создать
таблицу для отслеживания изменения цен item_prices
CREATE TABLE item_prices (
price_id integer PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
item_id integer NOT NULL REFERENCES items(item_id),
cost numeric(12, 2) NOT NULL, -- стоимость с точностью до копеек
start_date date NOT NULL, -- дата начала действия цены
end_date date, -- дата окончания действия (NULL для текущей цены)
CONSTRAINT valid_period CHECK (end_date > start_date OR end_date IS NULL) –
период действия цены
);
3)
Скорректированный запрос:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
departments D
JOIN
locations L
ON D.LOCATION_ID = L.LOCATION_ID
JOIN
employees E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE
L.CITY = 'Seoul'
AND E.MANAGER_ID IS NULL
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME

HAVING
SUM(E.SALARY) > 100000
Исправления: явное соединение таблиц через join, явное соединение locations и
departaments для корректного поиска города отдела, условие с агрегатной функцией
помещено в having вместо where, производим группировку не только по
DEPARTMENT_NAME но и по DEPARTMENT_ID.
4)
Я не смогу перепрыгнуть через карандаш, лежащий на полу комнаты, если карандаш будет
лежать достаточно близко к стене так, что места для его перепрыгивания будет
недостаточно. Также потолок комнаты может быть достаточно низок, чтобы иметь
возможность полноценно перепрыгнуть карандаш в таких условиях. Но основным
вариантом ответа является всё-таки карандаш, лежащий вплотную к стене.",
56,14272752.docx,.docx,docx,"В целом рабочая структура,но можно её улучшить. Плохо хранить логин в открытом виде,лучше хранить хеш,что бы не произошла утечка данных. Так же можно добавить таблицу о стране и регионе,если это крупный интернет магазин,что бы не было путаницы.
2. Первоначальная таблица хранит текущую цену товара, не сохраняя историю изменений. Из-за этого невозможен анализ изменения цен во времени и затрудняет построение финансовых отчетов за прошлые периоды.Можно добавить отдельную таблицу для хранения истории цен. Это позволит сохранить все изменения стоимости товара с указанием периода действия цены.Новая архитектура:
Таблица items (основная таблица товаров):
items (
item_id number PRIMARY KEY, - уникальный id товара
item_name varchar(255) - наименование товара
);
Таблица item_prices (история цен):
item_prices (
item_price_id number PRIMARY KEY, - уникальный id записи об изменении цены
item_id number REFERENCES items(item_id), - ссылка на товар
item_cost number, --стоимость товара
valid_from timestamp, - дата начала действия цены
valid_to timestamp --дата окончания действия цены
);
3.Исправленный вариант:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME
FROM
DEPARTMENTS D
JOIN
LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
JOIN
EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE
L.CITY = 'Seoul'
AND E.MANAGER_ID IS NULL
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
Ошибки предыдущего кода:
Устаревший синтаксис JOIN
Условие на MANAGER_ID: Для проверки, является ли значение NULL, нужно использовать оператор IS NULL.
Агрегация и HAVING:
Нельзя использовать SUM(SALARY) в секции WHERE. Условия на агрегированные значения должны быть указаны в секции HAVING, которая применяется после группировки данных.
Так как требуется суммировать зарплаты сотрудников без менеджера в каждом отделе и сравнивать эту сумму с 100000, агрегация должна выполняться после фильтрации по MANAGER_ID IS NULL.
Необходимость вывода DEPARTMENT_ID: В задаче указано, что нужно получить все отделы, удовлетворяющие условиям. Поэтому, кроме названия отдела (DEPARTMENT_NAME), стоит выводить и его ID (DEPARTMENT_ID), чтобы однозначно идентифицировать отдел.
Регистр: В условии WHERE CITY = 'SEOUL' регистр может быть важен, а в базе данных может быть 'Seoul'. Лучше использовать 'Seoul'.
Потому что карандаш слишком маленький и его можно просто перешагнуть.",
57,142735.docx,.docx,docx,"Задание 1
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Поле client_id number:
Тип number обычно используется для хранения числовых значений с заданной точностью. Для уникального id это нецелесообразно, так как id удобнее представлять уникальным целым числом.
Возможные типы данных для id:
INT (4 байта, диапазон: ~±2.1 млрд)
BIGINT (8 байта, диапазон: ~±9.2 квинтиллиона)
SMALLINT (2 байта, диапазон: -32,768 до 32,767)
Тип данных нужно выбрать относительно количества клиентов и размера магазина (учитывается множество факторов, в том числе насколько планируется расширение магазина). В данном случае я бы выбрала тип SMALLINT для небольшого магазина и тип INT для магазина побольше. Остановимся на типе INT.
Так же id в данном случае будет уникальным. Нужно установить PRIMARY KEY AUTO_INCREMENT.
2) Поля client_name varchar(255) и client_surname varchar(255):
Можно рассмотреть два варианта: 1) магазин ориентирован чисто на русскую аудиторию; 2) клиентами магазина также являются иностранцы.
Для первого варианта для поле client_name varchar(255) нужно сделать внешним ключом (хранить id из другой таблицы, в которой будет ограниченный список имен).
Если клиентами являются иностранцы, то стоить добавить еще одно поле для второго имени.
Здесь остановимся на первом варианте.
3) Поле login varchar(30):
Поле должно быть уникальным и не должно быть нулевым. Также стоит добавить поле email с такими же ограничениями и поле phone_number (тип данных - VARCHAR(30), может содержать символы), так как сейчас часто используется верификация по номеру телефона.
4) Поле age number и reg_date:
Возраст меняется, поэтому хранить его нецелесообразно. Лучше хранить дату рождения типа DATE.
Поле даты регистрации лучше добавлять автоматически при вставке записи в таблицу.
ER-диаграмма
Итоговая таблица:
Задание 2
Текущая таблица items хранит только текущую цену товара, что не позволяет: отслеживать изменения цен во времени, строить корректные финансовые отчеты за прошлые периоды, анализировать динамику цен и восстанавливать историческую картину продаж.
Нужно создать отдельную таблицу items со списком товаров.
Также стоить создать таблицу category для разделения товаров по категориям.
Для хранения истории цен создаем таблицу item_price_history, в которой будут храниться записи об изменении цены: поле start_date - дата, когда запись была добавлена (момент изменения цены на price), end_date - дата установки следующей цены (null для текущей цены)
4) Изменение поле end_date можно реализовать через триггер - при добавлении записи о цене для конкретного item_id end_date(предыдущей)=start_date(текущей).
Задание 3
Ошибки:
Соединение таблиц должно быть через inner join (join). Также нужно добавить явное соединение таблиц employees, departments с locations.
MANAGER_ID = NULL - неверно, нужно сравнивать через IS.
Группировку лучше проводить по DEPARTMENT_ID.
Агрегатнвя функция SUM используется с оператором HAVING.
Задание 4
Карандаш упал и оказался у стены.
Комната находится в космосе на космическом корабле в невесомости.
Все происходит в компьютерной игре.",
58,143.pdf,.pdf,pdf,"Гаденов Данила / Направление Data Engineer
ЗАДАНИЕ 1
Думаю что стоит использовать дату рождения вместо возраста клиента,
хоть и для аналитики возраста клиентов например потребуется делать доп.
вычисления, но так точность данных будет выше (день и месяц), а также что
самое важное – данные о возрасте не придется постоянно обновлять, иначе
данные возраста потеряют свою актуальность.
Также стоит сделать логин уникальным значением, дабы избежать
путаницы между клиентами. Не знаю стоит ли тогда оставлять два уникальных
значения: login и client_id, но думаю что можно их как то свести к одному
столбцу.
ЗАДАНИЕ 2
Как по-моему, таблица товаров может содержать больше информации о
товаре, да и item_id является уникальным id товара во всей таблице. Поэтому
возможно стоит создать отдельную таблицу истории цен, таким образом
данные о изменении цен на разные товары не будут захламлять основную
таблицу товаров и не приведут к дублированию данных в основной таблице.
Для повышения эффективности аналитики возможно стоит создать
отдельную таблицу с агрегированными данными, которые часто вызываются
для аналитики (например, с теми же месячными итогами по ценам товаров).
Также можно попробовать использовать индексы для ускорения запросов
выборки. Но с данными методами лучше быть знакомым на практике, так как
у каждого есть как минусы, так и плюсы, в данном случае мне тяжело
рассуждать в теории.
ЗАДАНИЕ 3
Запрос очень витиеватый и местами неправильный.
- Для связи таблиц можно просто использовать JOIN, а не сравнивать id
значения двух таблиц.
- В WHERE нельзя указывать какое-либо сравнение функций агрегаций,
в данном случае это SUM(SALARY) >= 100000, для этого используется
HAVING.
- DEPARTMENT_ID тоже следует указать в GROUP BY для
правильности работы запроса.
- Для проверки значения на NULL используют IS, а не ‘=’.

Мой запрос выглядит так:
SELECT d.department_id,
d.department_name, SUM(e.salary) AS TOTAL_SALARY
FROM dapartments AS d
INNER JOIN locations AS l ON l.location_id = d.location_id
INNER JOIN employees AS e ON e.department_id = d.department_id
WHERE l.city = 'Seoul'
AND e.manager_id IS NULL
GROUP BY d.department_id, d.department_name
HAVING SUM(e.salary) >= 100000;
ЗАДАНИЕ 4
Ни карандаша, ни комнаты, ни меня там нет)",
59,145277.txt,.txt,text,"1) 
 a) client_name, client surname слишком большой объем допустимого кол-ва символов, может плохо влиять на оптимизацию. Я бы уменьшил данное значение до 30 или чуть-чуть больше до 50

 b) так как это магазин, то целесообразно добавить в эту структуру поля по типу e-mail и/или номер телефона, для рассылку предложений и акций 
 
 с) также можно добавить поле, которое будет формировать персональную скидку для определенного id в зависимости от частоты покупок 

 d) если речь зашла про частоту покупок, то можно создать признак активность пользователя или признак удаления если профиль был удален + дата последнего входа для проведения анализа и подведения статистики
 

2) 
 а) для каждого item добавить сток - кол-во товара, которое есть на складе 
 b) так же для добавить поле стоимости всего запаса для регулировки и планирования запаса товаров 
 с) так же сделать разделение на разные типы цен: добавить закупочную цену для того, чтобы видеть по какой цене закупаем, добавить продажную цену 

 d) если есть возможность, то создать отчет движения товаров, этот отчет будет отображать движение товара при его закупке или продажи, чтобы была видна история 

3) 
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
AND SUM(E.SALARY) >= 100000
GROUP BY D.DEPARTMENT_NAME

4) Если эта комната в которой я не нахожусь или комната, где я нахожусь, но карандаш лежит вплотную к стене",
60,14752275.docx,.docx,docx,"Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она илиможно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему мнению некорректно и какие изменения внесли бы.
ОТВЕТ:
Я считаю, что данный набор не совсем корректный, т. к. он имеет несколько проблем:
Для поля ‘age’ наиболее подходящим типом данных будет ‘integer’, так возраст, скорее всего, будет целым числом.
Можно добавить поле для хранения пола клиента ‘gender’ (тип данных ‘varchar’ c ограниченным набором значений “женский”/”мужской”), оно поможет персонализировать предложения.
В таблице необходимо создать поля с номером телефона ‘client_phone’ и email-адресом клиента ‘client_email’ , ведь связь с клиентом все-таки немало важна. С помощью таких полей можно отправлять уведомления о статусе заказа, отправлять рекламу и прочие рассылки и т.д.
Добавить дополнительное поле с датой рождения клиента ‘birthday’, чтобы делать персональные скидки на праздник.
И возможно добавления поля ‘country’, если интернет магазин осуществляет доставку и в другие страны.
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она илиможно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
);
item_id number, --уникальный id товара item_name varchar(255), --наименование товара item_cost number –стоимость товара
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различные отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
ОТВЕТ:
Можно разделить таблицу ‘items’ на две:
‘Items’: будет хранить неизменяемые характеристики товара ‘item_id’ и ‘item_name’
‘items_price’ будет хранить исторические данные о цене товара:
item_price (
item_id number, -- идентификатор товара (внешний ключ)
price_date date, -- дата изменения цены
item_cost number -- стоимость товара на эту дату
);
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS
WHERE CITY = 'SEOUL') AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
ОТВЕТ:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM employees E
JOIN departments D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN locations L ON D.LOCATION_ID = L.LOCATION_ID
WHERE L.CITY = 'SEOUL'
AND E.MANAGER_ID IS NULL
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
ОТВЕТ:
Здесь можно выделить следующие причины:
- карандаш укатился под диван или шкаф (которые мы не в состоянии перепрыгнуть);
- высота комнаты слишком маленькая;
- а может быть и такое, что карандаш упал в комнате, в которой нет меня.",
61,1478.pdf,.pdf,pdf,"1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она или можно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему
мнению некорректно и какие изменения внесли бы.
Ответ:
clients (
client_id int primary key, -- уникальный ID клиента
client_name varchar(20), --имя клиента
client_surname varchar(30), --фамилия клиента
email varchar(40) not null, -- email клиента
login varchar(32) not null, --логин, который придумал клиент
password varchar(130) not null, -- пароль
phone varchar(20) not null, -- номер телефона
gender_id int references gender on delete set null, -- ID пол клиента из таблицы gender
city_id int references cities on delete set null, -- ID города из таблицы cities
birthdate date not null, -- дата рождения клиента
reg_date date not null -- дата регистрации на сайте
);
gender (
gender_id serial primary key,
gender char unique not null
);
cities (
city_id int primary key, -- уникальный ID города
city_name varchar(30) -- название города
);

Добавлена возможность хранения email, пароля, телефона, пола и даты рождения клиента. Добавлено
использование внешних ключей для связей с таблицами gender и cities. Удален возраст клиента, вместо
этого теперь используется дата рождения. Изменены размеры переменной varchar().
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она или можно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости
товара?
Ответ:
Можно добавить столбец item_cost_date в таблицу items, который будет хранить дату, когда была
установлена текущая цена.
items (
item_id int primary key, --уникальный id товара
item_name varchar(255) not null, --наименование товара
item_cost numeric not null check(item_cost >0), --стоимость товара
item_cost_date date not null -- дата установки текущей цены
);

3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Ответ:
SELECT d.DEPARTMENT_ID, d.DEPARTMENT_NAME
FROM DEPARTMENTS D
JOIN LOCATIONS l ON d.LOCATION_ID = l.LOCATION_ID
JOIN EMPLOYEES E ON d.DEPARTMENT_ID = e.DEPARTMENT_ID
WHERE l.CITY = 'SEOUL' AND e.MANAGER_ID IS NULL
GROUP BY d.DEPARTMENT_ID, d.DEPARTMENT_NAME
HAVING SUM(e.SALARY) > 100000;
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?
Ответ:
Карандаш упал у стены.",
62,152727.docx,.docx,docx,"1 задание.
Предлагаемые изменения выделены жирным шрифтом, пояснения в комментариях.
clients (
client_id number(10) PRIMARY KEY, -- id указать, как первичный ключ, длину и точность id стоит ограничить
client_name varchar(100), --длину имени можно сократить
client_surname varchar(100), --длину фамилии можно сократить
login varchar(30) UNIQUE NOT NULL, --логин должен быть уникальным и не может повторяться, также не может быть NULL
password_hash varchar(255) NOT NULL, -- если данные регистрации не хранятся в другой таблице, то для регистрации нужно хранить хэш пароля, пароль не может быть NULL
city_id number(5), -- длину и точность id стоит ограничить
birth_date DATE, -- хранить возраст не корректно, так как он будет меняться, лучше хранить дату рождения и при необходимости можно будет получить возраст
reg_date date
FOREIGN KEY (city_id) REFERENCES cities(city_id) –- должна быть связь с таблицей городов через внешний ключ
);
Также NOT NULL можно добавить к остальным полям, если они должны быть обязательно заполнены.
2 задание.
Таблицу товаров стоит исправить так:
items (
item_id number(10) PRIMARY KEY, --уникальный id товара
item_name varchar(255) NOT NULL, --наименование товара
);
Из данной таблицы мы убираем стоимость, оставляя только информацию о товаре, которая не будет так часто меняться. Для хранения истории цен следует создать новую таблицу:
item_prices (
price_id number(10) PRIMARY KEY,--id записи
item_id number(10) NOT NULL, --id товара
price number(10,2) NOT NULL, --цена товара
start_date date NOT NULL, --дата, с которой вступает в силу новая цена
FOREIGN KEY (item_id) REFERENCES items(item_id) – указание внешнего ключа
);
Таким образом, чтобы узнать текущую цену, можно будет использовать запрос на выборку цены с максимальной датой start_date. Если start_date можем указывать заранее для будущих изменений, тогда при выборке понадобится дополнительное условие, что start_date не больше текущей даты. Кроме того, это позволит видеть изменения цены во времени.
3 задание.
Ниже представлен исправленный запрос, исправленные ошибки подписаны в комментариях.
SELECT D.DEPARTMENT_ID, --использование псевдонимов
D.DEPARTMENT_NAME,
SUM(E.SALARY) TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID –- лучше соединять таблицы через JOIN
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID –-соединить таблицу локаций через join вместо подзапроса – более оптимальный и гибкий вариант
WHERE E.MANAGER_ID IS NULL –- Ошибка: «= NULL», нужно использовать IS NULL
AND L.CITY = 'SEOUL' –-условие для присоединенной таблицы вместо подзапроса
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME –- нужно группировать по всем столбцам из SELECT
HAVING SUM(E.SALARY) >= 100000; --для фильтрации по агрегатным функциям (например SUM)нужно использовать HAVING вместо WHERE, HAVING используется после группировки
4 задание.
Варианты, почему я не могу через него перепрыгнуть:
1) В комнате низкие потолки
2) Габариты комнаты не позволяют прыгать
3) Я нахожусь не в этой комнате и могу даже не знать расположения этой комнаты
4) Карандаш лежит близко к стене
5) Карандаш под столом/стулом/диваном и тд.
6) Карандаш очень большой и его невозможно перепрыгнуть
7) Я не могу прыгать по медицинским показаниям
8) В комнате очень скользкий пол
9) В комнате хрупкий пол
10) В комнате идет совещание
11) Я на каблуках
12) Карандаш не видно или в комнате темно
13) Я очень тороплюсь на работу и мне некогда прыгать
14) Время после 23:00 и соседи снизу спят
15) Это нарушает технику безопасности
16) Карандаш в данный момент поднимают
А также поднять карандаш или просто перешагнуть через него будет менее энергозатратно.",
63,1527752.docx,.docx,docx,"Анализ таблицы ‘clients’ и предложения по улучшению
Оценка текущей схемы:
При детальном рассмотрении можно выделить несколько потенциальных проблем и предложить улучшения:
Положительные стороны:
Ясная структура: Поля имеют четкие названия и описания.
Основные данные: Содержит необходимую информацию о клиентах для большинства бизнес-задач интернет-магазина.
Недостатки и предложения:
Отсутствие уникальности логина:
Проблема: Логин не является уникальным идентификатором клиента, что может привести к дубликатам при регистрации.
Решение: Добавить поле email и сделать его уникальным. Электронная почта обычно является уникальным идентификатором пользователя в современных системах и может использоваться для восстановления пароля, рассылки уведомлений и т.д.
Отсутствие поля для пароля:
Проблема: Пароль клиента является критически важной информацией, но он отсутствует в таблице.
Решение: Добавить поле password_hash для хранения хэшированного пароля.
Недостаточное представление адреса:
Проблема: Использование только ID города ограничивает возможности анализа данных по географическим признакам.
Решение: Добавить поля address, postal_code для более полного представления адреса клиента.
Отсутствие информации о покупках:
Проблема: Если цель состоит в анализе покупательского поведения, то необходимо хранить информацию о совершенных покупках в отдельной таблице, связанной с таблицей клиентов.
Решение: Создать таблицу orders с полями order_id, client_id, order_date, total_amount и др., и связать ее с таблицей clients по полю client_id.
Тип данных для возраста:
Проблема: Тип данных number для возраста может быть неточным, особенно для пользователей, которым еще не исполнилось 1 год.
Решение: Использовать тип данных DATE для даты рождения и вычислять возраст при необходимости.
Нормализация: Рассмотрите возможность создания отдельной таблицы для городов, чтобы избежать дублирования данных.
Индексация: Создайте индексы на часто используемых полях (например, email, client_id).
Аналитика: Для более глубокого анализа данных о клиентах можно добавить поля, связанные с их поведением на сайте (например, количество посещений, средний чек).
Вывод:
Предложенные изменения таблицы ""clients"" более полно отражают потребности современного интернет-магазина и обеспечивает более надежное хранение данных о клиентах. Внедрение этих изменений позволит улучшить качество данных, повысить безопасность системы и расширить возможности для аналитики.
Анализ существующей схемы и предложение по доработке
Проблема текущей схемы:
Отсутствие истории цен: Текущая схема хранит только текущую стоимость товара, что не позволяет анализировать изменения цен во времени и строить точные отчеты.
Предлагаемое решение:
Для хранения исторических данных о стоимости товара предлагается добавить новую таблицу:
item_price_history (
item_id number, -- внешний ключ на таблицу items
price number,
effective_date date
);
Пояснение полей:
item_id: Уникальный идентификатор товара, связывающий запись с основной таблицей товаров.
price: Стоимость товара на конкретную дату.
effective_date: Дата, с которой начинает действовать указанная цена.
Преимущества предложенной схемы:
Хранение истории цен: Каждая запись в таблице item_price_history будет представлять собой ""снимок"" стоимости товара на конкретную дату. Это позволит отслеживать изменения цен во времени.
Гибкость: Такая схема позволяет легко добавлять новые записи о ценах при изменении стоимости товара.
Эффективность отчетов: Имея историю цен, можно строить разнообразные отчеты, например:
Изменение цены конкретного товара за определенный период.
Средняя цена товара за месяц/год.
Анализ сезонных колебаний цен.
Расчет выручки за прошлые периоды с учетом изменений цен.
Дополнительные соображения:
Индексация: Для ускорения запросов рекомендуется создать индексы по полям item_id и effective_date в таблице item_price_history.
Очистка данных: Необходимо определить правила очистки старых данных, чтобы избежать неограниченного роста таблицы.
Триггеры: Можно рассмотреть возможность использования триггеров для автоматического обновления таблицы item_price_history при изменении цены товара в основной таблице.
Вывод:
Предложенная схема позволяет эффективно хранить и анализировать исторические данные о стоимости товаров, что является важным требованием для построения точных финансовых отчетов в интернет-магазине.
Анализ запроса и предложения по улучшению
Понимание запроса:
Задача: найти все отделы в Сеуле, где суммарная зарплата сотрудников без менеджера превышает 100000.
Проблемы в существующем запросе:
Некорректное использование SUM(SALARY): Функция SUM не может быть использована в условии WHERE, так как она агрегирует данные и применяется после группировки.
Отсутствие корреляции подзапроса: Подзапрос, вычисляющий LOCATION_ID для Сеула, не связан с основной таблицей employee, что может привести к некорректным результатам.
Неэффективность соединения: Использование запятой для соединения таблиц считается устаревшим и менее читаемым, чем синтаксис JOIN.
Исправленный запрос:
SELECT d.DEPARTMENT_ID, d.DEPARTMENT_NAME, SUM(e.SALARY) AS TOTAL_SALARY
FROM employees e
JOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN locations l ON d.LOCATION_ID = l.LOCATION_ID
WHERE e.MANAGER_ID IS NULL
AND l.CITY = 'SEOUL'
GROUP BY d.DEPARTMENT_ID, d.DEPARTMENT_NAME
HAVING SUM(e.SALARY) >= 100000;
Этот запрос корректно выводит все отделы в Сеуле, где суммарная зарплата сотрудников без менеджера превышает 100000.
Этот исправленный запрос предоставляет более точный и эффективный способ решения поставленной задачи.
Не смогу перепрыгнуть через карандаш, так как я не знаю в какой комнате он находится.",
64,155322.docx,.docx,docx,"Задание 1
Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки. Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите, что по вашему мнению некорректно и какие изменения внесли бы.
Решение:
clients (
client_id INT PRIMARY KEY AUTO_INCREMENT,
login VARCHAR(30) UNIQUE NOT NULL,
reg_date DATE NOT NULL DEFAULT CURRENT_TIMESTAMP()
);
clients_info (
client_id INT,
client_name VARCHAR(100) NOT NULL,
client_surname VARCHAR(100) NOT NULL,
city_id INT NOT NULL,
birth_date DATE NOT NULL
client_id INT
FOREIGN KEY (client_id) REFERENCES clients (client_id)
FOREIGN KEY (city_id) REFERENCES cities (city_id)
);
cities (
city_id INT PRIMARY KEY AUTO_INCREMENT,
city_name VARCHAR(100) NOT NULL
);
Задание 2
Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки. Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу, вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете, что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различные отчёты (о доходах, например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года. Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое хранение стоимости товара?
Решение
Для удобства можно создать отдельную таблицу item_prices, которая будет хранить информацию об истории цен. Поля start_date и end_date позволяют определить период действия каждой цены. Текущая цена будет иметь end_date со значением NULL.
Таблица items (информация о товарах)
items (
item_id INT PRIMARY KEY AUTO_INCREMENT,
item_name VARCHAR(255) NOT NULL
);
Таблица item_prices (история цен)
item_prices (
price_id INT,
item_id INT NOT NULL,
price DECIMAL (10,2) NOT NULL,
start_date DATE NOT NULL,
end_date DATE,
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Задание 3
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations. Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100 000. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID =
(SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Решение
SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
 FROM EMPLOYEES E
 INNER JOIN DEPARTMENTS D USING(DEPARTMENT_ID)
 INNER JOIN LOCATIONS L USING(LOCATION_ID)
WHERE E.MANAGER_ID IS NULL AND AND LOCATION_ID =
(SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_NAME, D.DEPARTMENT_ID
HAVING SUM(E.SALARY) > 100000;
Задание 4
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Решение:
Если в комнате на пол уронили карандаш и через него нельзя перепрыгнуть, вероятно, его положили вплотную к стене или в угол.",
65,1742238.docx,.docx,docx,"Neoflex. Задания учебного центра
Задание №1
Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах). Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите, что по-вашему мнению некорректно и какие изменения внесли бы.
Исходная таблица:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Решение:
clients (
client_id number PRIMARY KEY IDENTITY,
client_name nvarchar(40) NOT NULL,
client_surname nvarchar(40) NOT NULL,
login nvarchar(30) UNIQUE NOT NULL,
city_id number NOT NULL,
birth_date date NOT NULL,
gender CHAR(1) CHECK (gender IN ('M','F')) NOT NULL,
reg_date date DEFAULT GETDATE() NOT NULL
);
Первичный ключ и автоинкремент
Экономия используемой памяти за счёт уменьшения выделяемого места для хранения имени и фамилии
Т.к это интернет-магазин, я предположу, что заказ и доставка товаров может осуществляться на территории нескольких стран, что поднимает необходимость использования NVARCHAR для хранения многоязычных данных.
NOT NULL в каждом поле для отсутствия пустых записей, все данные обязательны к заполнению
Логин должен быть уникальный
Возраст меняется каждый год, чтобы не обновлять таблицу каждый день рождения каждого клиента лучше использовать запрос для вычисления возраста (если есть в этом необходимость)
Поле пола может быть полезно для анализа данных о клиентах и маркетинга, обозначения пола (M и F) здесь использованы английские, т.к. английский сейчас является крайне распространённым языком и у людей из разных стран не возникнет проблем с пониманием значение
Теперь дата регистрации устанавливается автоматически
Задание №2
Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Глядя на эту таблицу, вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различные отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое хранение стоимости товара?
Исходная таблица:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Решение:
items (
item_id number PRIMARY KEY IDENTITY,
item_name nvarchar(255) NOT NULL,
);
Item_prices(
id_price_change number PRIMARY KEY IDENTITY,
item_id number NOT NULL,
price decimal(10,2) NOT NULL,
change_date date DEFAULT GETDATE() NOT NULL
);
Первичный ключ и автоинкремент
Допустим, что названия товаров длинные и не будем изменять длину хранимой строки (как и увеличивать её до MAX), только добавим возможность хранить многоязычные данные с помощью NVARCHAR
NOT NULL в каждом поле для отсутствия пустых записей, все данные обязательны к заполнению
Удалим поле стоимости, вынесем его в отдельную таблицу
Создадим новую таблицу специально для хранения истории изменения цен на товары
Первичный ключ и автоинкремент
Внешний ключ на таблицу-справочник items
Стоимость с типом decimal, а не number или money для большей точности и возможности конвертации валют, а (10,2) т.к. стоимость товаров в интернет-магазине вряд ли превысит миллиард
Дата изменения цены автоматически создаётся в день создания записи
Задание №3
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations.
Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
Исходный код:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Решение:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) AS TOTAL_SALARY
FROM (DEPARTMENTS D INNER JOIN LOCATION L ON D.LOCATION_ID = L.LOCATION_ID)
INNER JOIN EMPLOYEE E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE
E.MANAGER_ID = NULL
AND
L.CITY = 'SEOUL'
GROUP BY DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000
Добавила INNER JOIN для корректной связи таблиц друг с другом, а также для скорости выполнения запроса (Убрала запрос в середине)
В GROUP BY добавила DEPARTMENT_ID, т.к. без указания всех полей программа выдаст ошибку (Опираюсь на свой опыт с MS SQL Server)
Функцию SUM() нельзя использовать с WHERE, только с HAVING.
В условии задачи было сказано ""зарабатывают в общей сложности более 100000"", а не ""100000 или больше"", следовательно надо изменить знак больше или равно на знак больше
Задание №4
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Не знаю где комната
Не могу добраться до комнаты
Не могу войти в комнату
Комната может быть маленькая, не смогу прыгнуть в комнате или вообще поместиться
Карандаш может быть крайне большим
Карандаш также может быть крайне маленьким и вероятность перепрыгнуть через него настолько мала, что приближается к нулю
Карандаш закатился под мебель и его не достать
Пол очень липкий, от него нельзя оторваться
Пол – батут, карандаш сам через меня перепрыгнет
Карандаш упал, но потом его могли поднять и сделать с ним что угодно, например, сжечь, после чего через него не перепрыгнуть
Помимо карандаша и комнаты условия не известны, я могу в этой задаче быть улиткой. Улитки прыгать не могут.
Карандаш мог быть роботом, выдвинуть спрятанные ранее ножки и убежать, ведь также не указывалось является ли карандаш простым деревянным пишущим устройством с грифелем.
Упавший карандаш в комнате – арт-инсталляция в музее. Это неприлично
Упавший карандаш в комнате – абстракция. Конкретного карандаша, через который можно перепрыгнуть, не существует
Упавший карандаш в комнате – событие произошедшее не в этой версии реальности
Карандаш находится в квантовой суперпозиции
Мне не разрешили
Пол в комнате дырявый, карандаш просто провалился куда-то и теперь его не найти
Даже если я не улитка, у меня может быть аллергия на карандаши, а это очень серьёзно
Это плохая примета. В какой-то части мира определённо
Карандаш проклят. Или я. Или комната
Я могу бояться лежачих на полу карандашей
Перепрыгивание карандашей без актуальной лицензии на прыжки может являться нарушением закона. Опять-таки изначальные условия не ясны
Перепрыгивать через карандаш - проявление неуважения к карандашам!",
66,17578.pdf,.pdf,pdf,"client_id должен быть типа INTEGER PRIMARY KEY
login UNIQUE VARCHAR(50) -- к логину добавили уникальность.
Для city_id, есть ограничение FOREIGN KEY, он связывает две таблицы по внешнему ключу
Нужно заменить age на birth_date DATE , нет смысла указывать возраст, который меняется.
Возможно, нужно сохранять зашифрованный пароль, тогда ещё password VARCHAR(255)
Добавить поле для ввода номера (опционально), phone VARCHAR(12)
Дата регистрации reg_date по умолчанию будет.

Создаём две таблицы, товар и цена_товара.
В Таблице items убираем item_cost и эту сущность выносим в отдельную таблицу items_price.
В таблице items_price связываем через внешний ключ item_id с таблицей items
Сущность price будет дробной

4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него
перепрыгнуть?
Где сказано, что карандаш и я находимся в одной комнате? Может его упустили в некоторой
комнате N , а я нахожусь в комнате M, тогда и не смогу перепрыгнуть его.",
67,2024020.txt,.txt,text,"1. client_id изменить тип данных на integer
 client_name в зависимости от клиентской базы рассмотреть ограничение максимального размера строки до 50 символов
 client_surname в зависимости от клиентской базы рассмотреть ограничение максимального размера строки до 50 символов
 login вынести в отдельную таблицу с ограничением доступа, должен быть уникальным 
 city_id изменить тип данных на integer, хранить уникальное значение города, добавить связанную таблицу с названиями городов 
 age заменить столбец на birth_date тип данных date
 reg_date для сбора данных может понадобиться время регистрации изменить тип данных на datetime

2. item_id изменить тип данных на integer
 item_name - без изменений
 item_cost изменить тип данных на decimal(10, 2)
 добавить столбец created_date в таблицу ITEMS

 добавить связанную по item_id таблицу PRICE_HISTORY(
 price_id integer PRIMARY KEY
 item_id integer
 price decimal(10, 2)
 begin_date timestamp
 end_datetimestamp
 );

3. SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) TOTAL_SALARY
 FROM EMPLOYEE E
 JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 JOIN LOCATIONS L ON L.LOCATION_ID = D.LOCATION_ID
 WHERE 
 E.MANAGER_ID IS NULL
 AND L.CITY = 'SEOUL'
 GROUP BY
 D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME
 HAVING SUM(E.SALARY) >= 100000

4. a) я не нахожусь в этой комнате и не могу попасть в нее.
 б) в комнате есть разлом который человек не может перепрыгнуть, а карандаш на другой стороне
 в) карандаш размером больше 2 метров
 г) на моих ногах ботинки весом 100 и более кг
 д) в комнате создана гравитация, которая не дает человеку совершить прыжок
 е) карандаш упал в угол",
68,2052524.docx,.docx,docx,"Тестовое задание DE Маев Максим
Набор данных корректный, но можно добавить поля email, phone для связи с клиентом.
Типы: можно поменять тип для поля age на date, чтобы вносить дату рождения, а не возраст, который необходимо обновлять.
Ограничения: нужно установить ограничения на поля client_id (Primary key), чтобы гарантировать уникальность записей в таблице. Установить city_id (Foreign key), чтобы использовать id городов из таблицы с городами. Можно установить NOT NULL на поля login, client_name, client_surname, чтобы гарантировать целостность бд. UNIQUE на login.
Декомпозиция: нужно выделить таблицу city, как измерение для основной таблицы, чтобы избежать избыточности. (экономия памяти)
Еще можно добавить индекс для таблицы для более быстрого поиска.
Чтобы хранить историю цен я бы ввел еще одну таблицу, где будут поля item_id item_cost(нужно будет удалить поле из таблицы items или заполнять его текущей ценой из price_history), start_date, end_date (даты действия цены)
price_history (
id number, -- уникальный идентификатор записи
item_id number, -- ссылка на уникальный id товара из таблицы items
item_cost number, -- стоимость товара на определенный период
start_date date, -- дата начала действия этой цены
end_date date -- дата окончания действия этой цены
);
При изменении цены мы добавляем запись в таблицу price_history c датой начала и датой конца будет по умолчанию 9999-01-01 (SCD2), дата конца для прошлой записи для этого товара будет перезаписана в той же транзакции, в которой мы будем добавлять новую цену. Так у нас будет доступ ко всей истории цен, а актуальная цена будет с полем end_date 9999-01-01.
Можно использовать и другие подходы, но этот один из самых простых для получения актуальных цен.
Исходный запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME;
Исправленный запрос:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) as TOTAL_SALARY
FROM EMPLOYEE as E JOIN DEPARTMENTS as D USING(DEPARTMENT_ID)
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID , D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000; -- в условии более(>)
Добавил JOIN по полю DEPARTMENT_ID, убрал E.DEPARTMENT_ID = D.DEPARTMENT_ID из условия
E.MANAGER_ID IS NULL вместо = NULL
Сделал группировку по всем не агрегирующим полям
Перенес условие после группировки в HAVING
Карандаш мог упасть вплотную к стене.",
69,205275.pdf,.pdf,pdf,"Задание 1.
1. У client_id установил автоинкремент и первичный ключ.
2. Уменьшил длину полей client_name и client_surname.
3. Увеличил длину поля login и добавил уникальность логина.
4. Добавил поле password_hash для хранения хэша паролей для безопасности
5. Добавил поле phone для хранения номера телефона
6. Добавил поле email для хранения почты
7. Добавил внешний ключ для поля city_id(если таблица с городами существует)
8. Заменил поле age на date_of_birth, т.к. age должно каждый год меняться, а дата
рождения остается неизменной.
9. reg_date теперь заполняется автоматически при создании записи.
CREATE TABLE IF NOT EXISTS cities (
city_id INT AUTO_INCREMENT PRIMARY KEY, - пример таблицы с городами!
city_name VARCHAR(50) NOT NULL
);
CREATE TABLE clients (
client_id INT AUTO_INCREMENT PRIMARY KEY,
client_name VARCHAR(50) NOT NULL,
client_surname VARCHAR(50) NOT NULL,
login VARCHAR(50) NOT NULL UNIQUE,
password_hash VARCHAR(255) NOT NULL,
phone VARCHAR(20) NOT NULL UNIQUE,
email VARCHAR(255) NOT NULL UNIQUE,
city_id INT,
date_of_birth DATE,
reg_date DATE DEFAULT CURRENT_DATE,
FOREIGN KEY (city_id) REFERENCES cities(city_id)
);

Задание 2.
Я бы разделил данные на несколько таблиц(items, items_prices и discounts)
1. Таблица items хранит основную информацию о товарах
2. Таблица items_prices хранит историю изменений стоимости товаров с
указанием временных периодов
3. Таблица discounts для управления скидками
4. Также добавил код для расчета скидок(фиксированных(1500р и т.п.) и
процентных(10% и т.п.))
CREATE TABLE items (
item_id INT AUTO_INCREMENT PRIMARY KEY,
item_name VARCHAR(255) NOT NULL
);
CREATE TABLE item_prices (
price_id INT AUTO_INCREMENT PRIMARY KEY,
item_id INT NOT NULL,
price DECIMAL(10, 2) NOT NULL,
discounted_price DECIMAL(10, 2),
start_date DATE NOT NULL,
end_date DATE,
FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE CASCADE
);
CREATE TABLE discounts (
discount_id INT PRIMARY KEY AUTO_INCREMENT,
item_id INT NOT NULL,
discount_type ENUM('percent', 'fixed') NOT NULL,
discount_value DECIMAL(5, 2) NOT NULL,
start_date DATE NOT NULL,
end_date DATE NOT NULL,
FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE CASCADE
);

-- Рассчет цены с учетом скидки
UPDATE item_prices ip
JOIN discounts d ON ip.item_id = d.item_id
SET ip.discounted_price =
CASE
WHEN d.discount_type = 'percent' THEN ip.price * (1 - d.discount_value / 100)
WHEN d.discount_type = 'fixed' THEN ip.price - d.discount_value
END
WHERE d.start_date <= '2025-01-01' AND d.end_date >= CURDATE();
Задание 3.
1. MANAGER_ID = NULL неправильно, IS NULL правильно
2. SUM(SALARY) >= 100000 в блоке WHERE недопустимо, только в HAVING
3. FROM EMPLOYEE E, DEPARTMENTS D вместо запятой JOIN(читабельнее)
4. В GROUP BY не указано поле DEPARTMENT_NAME
5. Псевдонимы не были использованы
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN
LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
L.CITY = 'SEOUL'
AND E.MANAGER_ID IS NULL
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
Задание 4.
1. Непонятно что за комната(какого она размера и реально ли туда поместиться
человеку).
2. Непонятно точное расположение карандаша, но если он в нормальной комнате, то
он может лежать у стены и через него не перепрыгнешь из-за стены.

3. Непонятны размеры карандаша(возможно он настолько большой, что
невозможно перепрыгнуть).
В остальном трудностей нет, чтобы перепрыгнуть карандаш",
70,215525.pdf,.pdf,pdf,"1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она или можно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему
мнению некорректно и какие изменения внесли бы.
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она или можно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости
товара?

3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?",
71,222.docx,.docx,docx,"Во-первых, непонятно, откуда возраст: его заполняет сам пользователь или он рассчитывается, исходя из даты рождения, находящейся в какой-то другой таблице. Если сам пользователь, я бы заменила age number на birth_date date, чтобы было удобнее пользоваться этим столбцом при запросах или добавить скидку в день рождения. Можно также добавить проверку: birth_date DATE CHECK (birth_date >= '1900-01-01' AND birth_date <= CURRENT_DATE) (CURRENT_DATE можно при необходимости заменить на дату рождения, с которой можно регистрироваться).
В-вторых, нет контактной информации, даже электронной почты. Можно добавить (email VARCHAR(255) NOT NULL UNIQUE).
В-третьих, есть логин, но нет пароля (password_hash VARCHAR(255)).
Для изменения таблицы можно создать копию таблицы, изменить копию, а затем заменить старую таблицу на измененную в процессе транзакции, например:
CREATE TABLE clients_new (LIKE clients INCLUDING CONSTRAINTS);
ALTER TABLE clients_new DROP COLUMN age;
ALTER TABLE clients_new ADD COLUMN birth_date DATE NOT NULL;
INSERT INTO clients_new (client_id, client_name, client_surname, login, city_id, reg_date, birth_date)
SELECT
client_id, client_name, client_surname, login, city_id, reg_date,
(reg_date - (age * INTERVAL '1 year'))::DATE
FROM clients;
BEGIN;
ALTER TABLE clients RENAME TO clients_old;
ALTER TABLE clients_new RENAME TO clients;
COMMIT; -- или ROLLBACK при ошибках
DROP TABLE clients_old;
Можно создать дополнительную таблицу с историей изменений цены и таблицу с причинами изменений цены, например:
-- Таблица причин изменения цен
CREATE TABLE price_change_reasons (
reason_id SERIAL PRIMARY KEY,
reason_name VARCHAR(100) NOT NULL UNIQUE,
description TEXT,
is_active BOOLEAN DEFAULT TRUE
);
-- Таблица истории изменения цен
CREATE TABLE item_price_history (
history_id SERIAL PRIMARY KEY,
item_id INT NOT NULL REFERENCES items(item_id),
price NUMERIC(10,2) NOT NULL CHECK (price > 0),
valid_from TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
valid_to TIMESTAMP WITH TIME ZONE,
changed_by VARCHAR(100),
reason_id INT REFERENCES price_change_reasons(reason_id)
);
-- Индексы для быстрого поиска
CREATE INDEX idx_price_history_item ON item_price_history(item_id);
CREATE INDEX idx_price_history_period ON item_price_history(valid_from, valid_to);
CREATE INDEX idx_price_history_reason ON item_price_history(reason_id);
-- Примеры причин
INSERT INTO price_change_reasons (reason_name, description) VALUES
('seasonal_increase', 'Сезонное повышение цен'),
('seasonal_discount', 'Сезонная скидка'),
('promotion', 'Акция/распродажа'),
('inflation', 'Инфляционная корректировка'),
('supplier_change', 'Изменение цены поставщика'),
('competitor_price', 'Корректировка под конкурентов'),
('new_product', 'Новый товар'),
('clearance', 'Распродажа остатков'),
('other', 'Иная причина');
Исправленный запрос:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN
LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
E.MANAGER_ID IS NULL
AND L.CITY = 'Seoul'
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
Ошибки в исходном запросе и исправления:
1) Проверка на NULL:
MANAGER_ID = NULL исправлено на E.MANAGER_ID IS NULL, т.к. в SQL сравнение с NULL всегда возвращает NULL, нужно использовать IS NULL.
2) Условие SUM в WHERE:
AND SUM(SALARY) >= 100000 перенесено в HAVING, т.к. агрегатные функции нельзя использовать в WHERE, для этого есть HAVING.
3) Неправильное имя таблицы:
FROM EMPLOYEE E (без 'S' на конце) исправлено на FROM EMPLOYEES E, т.к. согласно условию, таблица называется EMPLOYEES.
4) Проверка местоположения:
Подзапрос для LOCATION_ID исправлен на явное соединение с таблицей LOCATIONS, т.к. JOIN читается лучше и обычно работает эффективнее подзапроса.
5) GROUP BY:
Было только по DEPARTMENT_NAME, добавлен DEPARTMENT_ID, т.к. в GROUP BY должны быть все неагрегированные столбцы из SELECT.
6) Сравнение суммы:
>= 100000 исправлено на > 100000, т.к. по условию задачи нужно ""более 100000"" (строго больше)
7) Дополнительные улучшения:
- добавлен явный JOIN вместо декартова произведения;
- добавлено ключевое слово AS для псевдонима столбца;
- использовано соглашение об именах таблиц (L для LOCATIONS);
- указана таблица для каждого столбца (E.MANAGER_ID, D.DEPARTMENT_ID и т.д.).
Во-первых, я могу находиться не в этой комнате. Во-вторых, карандаш может лежать у стены или под мебелью.",
72,2222222.pdf,.pdf,pdf,"1. Вынести дату регистрации и логин в отдельную таблицу, так как эти данные
относятся к личному кабинету клиента и чтобы не перегружать таблицу
данными необходимо вынести отдельною
Получаем 2 таблицы:
Clients(
Client_id,
Client_name,
Client_surname,
City_id,
Age
)
Users (
Client_id,
Client_login,
Reg_date)
2. Создать отдельную таблицу для хранения старых данных, где будет храниться
id товара, цена и дата начала действия цены.
3. SELECT D.department_id,
D.department_name,
SUM(salary) TOTAL_SALARY
FROM employees E,
departments D
WHERE E.department_id = D.department_id
AND manager_id ISNULL
AND location_id= (SELECT location_id
FROM locations
WHERE city = 'SEOUL')
GROUP BY D.department_id
HAVING SUM(salary) >= 100000
4. Карандаш шириной и длиной с комнату
Карандаш закатился под шкаф",
73,2235.pdf,.pdf,pdf,"1
Для первичных и внешних ключей( client_id, city_id ) лучше ипользовать INTEGER или BIGINT,
number обычно используется для чисел с плавающей точкой
Строку login лучше сделать больше, т.к логин может быть больше чем 30 символов
Возраст клиента лучше хранить в типе DATE, так легче вычислить возраст на данный момент
времени, если оставить возраст числовым, то при повышении возраста это никак не отследить

2
Чтобы обеспечить историчекое хранение стоимости можно создать либо 2 таблицу с ценами на
товар и, либо доработать эту таблицу
Т.к в задании написано доработать архитектуру этой таблицы, сделаем так:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number, --стоимость товар
start_date date NOT NULL, – дата начала действия цены
end_date date, -- дата конца действия цены
is_current boolean NOT NULL – флаг, указывающий цена на данный момент актуальная или нет
);

3
Для более читабельного запроса лучше использовать JOIN
MANAGER_ID неправильно проверяется, заместо NULL нужен IS NULL
Неправильное применение агрегированной функции SUM, в Where она используется до
группировки, хотя должна применяться после неё, нужно записать ее в HAVING
В GROUP BY нужно включить DEPARTMENT_ID, без него будет ошибка, т.к SQL не будет понимать
что делать с DEPARTMENT_ID
Исправленный запрос:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) as ‘TOTAL_SALARY’
FROM EMPLOYEE E
JOIN DEPARTMENTS D ON E. DEPARTMENT_ID = D. DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE MANAGER_ID IS NULL
AND L.CITY = ‘SEOUL’
GROUP BY DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(salary) >= 100000

4
Через него нельзя перепрыгнуть если он упал у края стены или закатился под какой-либо большой
предмет, через который невозможно перепрыгнуть",
74,2255.txt,.txt,text,"A

Age - вместо него целесообразно хранить дату рождения (date)
Добавить поля с информацией для связи - электронная почта (varchar) и/или телефон
Опционально - добавить поле с датой последнего входа на сайт (datetime)
Поле city_id - насколько я знаю, для определения города можно использовать и другие методы, но зависит от потребностей. Но формат number ему не нужен, id города - это целое число (обычно). На мой взгляд, лучше подойдет tinyint(33 или 4, зависит от количества покрываемых городов).
Добавить поле для хранения хэша пароля пользователя (зависит от того, каким образом происходит вход на сайт, но если с паролем, то надо).
 

B

Добавить поле start_price - datetime (либо date, если стоимость гарантированно не меняется в течение дня). Тогда item_cost - цена товара, которая действует со start_price до следующего изменения.

 

C

Пропущено AS в select (total_salary)
Условие SUM(SALARY) >= 100000 вынести в HAVING (проверка уже после группировки)
Опционально - GROUP BY не по DEPARTMENT_NAME, а по DEPARTMENT_ID - но если ограничение уникальности по названию отдела есть, то не так важно
Опционально - вместо where для объединения таблиц join (в общем случае - employees right join departments using(department_id))
 

SELECT DEPARTMENT_ID,

DEPARTMENT_NAME,

SUM(SALARY) AS TOTAL_SALARY

FROM EMPLOYEE E,

DEPARTMENTS D

WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID

AND MANAGER_ID = NULL

AND LOCATION_ID = (

SELECT LOCATION_ID

FROM LOCATIONS

WHERE CITY = 'SEOUL')

GROUP BY DEPARTMENT_ID

HAVING SUM(SALARY) >= 100000

 

 

 

D

База:

Карандаш упал в угол (если он упал вплотную к стене, то его можно перепрыгнуть вдоль стены. Потенциально можно подняться, например, на этаж выше и перепрыгнуть карандаш там).
I had some time, so:

Его уже подняли
Карандаш не долетел до пола (например, поймали в процессе)
У меня нет ног
За прыжки в компании увольняют
Пол это лава
Я нахожусь не в той комнате, в которой на пол уронили карандаш
Я не знаю, в какой комнате уронили карандаш
Не представляется возможным определить, где именно на полу карандаш (цвет сливается/я слепой)
Я могу через него перепрыгнуть
Потолок слишком низкий для прыжка
В комнате не работает гравитация (комната на мкс/в космосе) - прыгнуть не получится, да и карандаш где-то в невесомости плавает - вариация - комната под водой, смысл тот же
Карандаш после падения сломался на 2 части, соответственно перепрыгнуть его как один карандаш концептуально невозможно, он перестал существовать как карандаш и продолжил как два обломка карандаша
Карандаш упал и вонзился мне в ногу, соответственно карандаш во мне, и невозможно перепрыгнуть через него, не вытащив из ноги
Нет задокументированной инструкции перепрыгивания карандаша",
75,2277.txt,.txt,text,"1. Я считаю некорректным хранение возраста, потому что максимум через год данные в этом поле полностью устареют. Лучше хранить даты рождения клиентов. 

2. Я бы убрала item_cost из таблицы items, и создала бы новую таблицу prices. Новые таблицы выглядели бы так:

items(
item_id number,
item_name varchar(255)
)

prices(
item_id number,
date_begin date,
date_end date,
cost number)

Таблица prices будет иметь внешний ключ на таблицу items. Также в таблице будет дата начала стоимости, дата конца и сама стоимость. Таким образом, мы сможем найти все предыдущие цены на каждый товар за любой промежуток времени.

3.
Исправленный запрос:

SELECT E.DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) TOTAL_SALARY

FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID 
AND E.MANAGER_ID IS NULL 
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')

GROUP BY DEPARTMENT_NAME
HAVING SUM(SALARY) >= 100000

1) DEPARTMENT_ID есть в двух таблицах, поэтому в SELECT нужно добавить из какой таблицы мы его берем
2) NULL нельзя ни с чем сравнивать, поэтому для проверки отсутствия данных нужно писать IS NULL
3) Агрегирующую функцию SUM() нельзя использовать в WHERE, поэтому для фильтрации по SUM(SALARY) нужно добавить оператор HAVING

4. Потому что карандаш упал вплотную к стене",
76,25383.pdf,.pdf,pdf,"1. clients (
client_id INT PRIMARY KEY, - - первичный ключ в связи с уникальностью
значения
client_name VARCHAR(255) NOT NULL, - - добавление ограничения not null
client_surname VARCHAR(255) NOT NULL,
login VARCHAR(50) UNIQUE NOT NULL, -- добавление ограничения
уникальности
password_hash VARCHAR(255) NOT NULL, --пользователь вводит не только логин,
но и пароль. В БД пароли хранятся в хэшированном виде
email VARCHAR(255) UNIQUE NOT NULL, --добавление дополнительных полей
для связи с клиентом
phone_number VARCHAR(20), -- поле, которое может быть необязательным для
заполнения
birthdate DATE, - - замена поля age, тк возраст ежегодно меняется
city_id INT,
reg_date DATE,
FOREIGN KEY (city_id) REFERENCES cities(city_id)
);
В таблице есть city_id, если нет таблицы с указанием города и его id,
дополнительно ее создать
cities (
city_id INT PRIMARY KEY,
city_name VARCHAR(255) UNIQUE NOT NULL
);
2.
Данная таблица может остаться в таком же виде, но использовать ее для
хранения текущей стоимости товара
items (
item_id number
item_name varchar(255),
item_cost number
);
Но необходимо создать таблицу, которая будет хранить истории изменения цен
item_price_history (

item_id number,
price_change_date date,
item_cost number,
PRIMARY KEY (item_id, price_change_date)
);
Далее создаем триггер для автоматического обновления цены, то есть, если
меняется item_cost в таблице items, то будет автоматически добавляться запись в
таблицу item_price_history.
CREATE OR REPLACE TRIGGER update_item_price_history
AFTER UPDATE OF item_cost ON items
FOR EACH ROW
BEGIN
INSERT INTO item_price_history (item_id, price_change_date, item_cost)
VALUES (:OLD.item_id, SYSDATE, :OLD.item_cost);
END;
Далее создадим процедуру для обновления цены товара, которая будет
использовать триггер для добавления записи в историю
CREATE OR REPLACE PROCEDURE update_item_price (
p_item_id NUMBER,
p_new_cost NUMBER
) IS
BEGIN
UPDATE items
SET item_cost = p_new_cost
WHERE item_id = p_item_id;
END;
3. SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE L.CITY = 'SEOUL'
AND E.MANAGER_ID IS NULL
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME

HAVING SUM(E.SALARY) > 100000;
4.Потому что нахожусь в другой комнате",
77,2725727.txt,.txt,text,"Задача 1

1. Ограничить имя и фамилию клиента меньшим кол-вом символов. Но хорошо, что они раздельные по умолчанию.
2. Нет проверки уникальности логина, он может быть одинаковый у разных пользователей, это плохо.
3. Возраст заменить на дату рождения(?), но может быть полезно, условно, если продаются товары 18+, например(?) или мы хотим разбить пользователей на разные группы быстро. Возраст не меняется, но, теоретически можно по рег. дейту обновлять, не точно, но примерно ок. Но лучше дату рождения.
4. Мы не видим таблицу с городами(?).
5. Дата регистрации - генерить автоматически, зачем пользователю её вводить? Нужно ли это нам в целом(?)

Я бы сделал логин имейлом - так он будет уникальный и сразу прибавится способ связи с покупателем. Возможно, номер телефона бы добавил еще и адрес (он всё равно понадобится для заказа же?).
Можно добавить, например, дату последнего заказа, чтобы понимать, ""живой"" пользователь или нет.

Задача 2

Обеспечить сохранение истории цен на какую-либо дату можно, создав отдельную таблицу, в которой мы будем это хранить. Например, items_price, из которой мы на заданную дату могли бы выгрузить цену конкретной позиции, задав промежуток (начало действия цены и конец действия цены) дат для конкретной позиции по её уникальному item_id.

Задача 3

Ошибки:
- SUM(SALARY) нужно перенести в HAVING после GROUP BY
- MANAGER_ID = NULL исправить на MANAGER_ID IS NULL
- Нет JOINа с LOCATIONS. Неявный JOIN EMPLOYEE с DEPARTMENTS, хотя так можно, в принципе.
- Не хватает полей в GROUP BY, в SELECT их указано больше.",
78,27272.pdf,.pdf,pdf,"1 задание
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите
что по вашему мнению некорректно и какие изменения внесли бы.
Структура логичная, но есть несколько недостатков:
1. Нет первичного ключа (PRIMARY KEY)
Необходимо добавить ключ PRIMARY KEY к полю client_id, для гарантии отсутствия
дубликатов или NULL.
2. Нет ограничений на обязательные поля (NOT NULL)
Поля client_name, client_surname, login, reg_date должны быть обязательными (NOT
NULL), так как они критичны для идентификации клиента (city_id и age можно оставить
необязательными)
3. Нет внешнего ключа (FOREIGN KEY) на city_id
Если есть таблица городов, нужно добавить FOREIGN KEY (city_id) REFERENCES
cities(city_id). (чтобы избежать некорректных названий городов)
4. Поле login не уникально
Необходимо добавить UNIQUE ограничение, чтобы исключить дубликаты.
5. Поле age может устаревать
Лучше заменить age на birth_date, чтобы не обновлять каждый год.
Также можно добавить дополнительные поля в таблицу:
- email/phone для связи с клиентом
- last_activity_date для анализа активности клиентов
2 задание
Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое
хранение стоимости товара?
есть 2 варианта
1. цену убрать из таблицы, завести 2 таблицу
cost_id number -- уникальный Id цены
item_id number -- ссылка на item
dt_cost date -- цена на определенную дату
item_cost number --цена
2. убрать цену и добавить ""коллекцию""
collect_cost number
завести 2 таблицу
collect_cost -- уникальный Id цены
item_id number -- ссылка на item
dt_cost date -- цена на определенную дату
item_cost number --цена
Преимущество 2 метода, в том что по полю collect_cost можно построить индекс и
тогда запрос узнать цену товара в определённую дату будет работать быстрее (что
важно когда базе будет несколько лет массив цен каждого товара будет измеряться 10
тысяч)

3 задание
Требуется проверить запрос на корректность и исправить там ошибки, если они
есть
1. ошибка нельзя сравнивать с NULL нужно писать AND MANAGER_ID IS NULL
2. в WHERE нельзя использовать SUM нужно делать подзапрос
3. в group by нужно указывать все поля которые не групповые
в данном случае group by DEPARTMENT_ID, DEPARTMENT_NAME
4. выполнение запроса AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS WHERE CITY = 'SEOUL') выполняется над каждой записью выборки
что тормозит запрос
исправленный вариант
select s.DEPARTMENT_ID,s.DEPARTMENT_NAME,s.TOTAL_SALARY
from
(
SELECT DEPARTMENT_ID as DEPARTMENT_ID,
DEPARTMENT_NAME as DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E
GROUP BY DEPARTMENT_NAME,DEPARTMENT_ID
) s,
DEPARTMENTS D,
LOCATIONS l
WHERE s.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID is NULL
AND d.LOCATION_ID = l.d.LOCATION_ID
and l.CITY = 'SEOUL'
AND S.TOTAL_SALARY >= 100000
4 задание
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете
через него перепрыгнуть?
1. он закатился под стол/шкаф
2. он лежит в углу
3. в комнате выключен свет
4. цвет карандаша = цвету покрытия (его просто не видно)
5. перелом ноги, не могу прыгать",
79,272733.txt,.txt,text,"Задание 1

Произведем разделение даннх клиента на 2 таблицы, а также сделаем минимальную таблицу городов к данным которой мы обращаемся. Основная таблица clients теперь хранит постоянную информацию о клиенте (ФИО, телефон, адрес и т.д.). Эти данные редко меняются и относятся конкретно к самому человеку. Регистрационная информация (логин, пароль, IP-адрес и дата регистрации) помещены в отдельную таблицу client_registrations. Эта информация специфична для процесса регистрации и может подвергаться частым операциям чтения и записи.

Таблица городов

CREATE TABLE cities 
( 
city_id SERIAL PRIMARY KEY, -- уникальный идентификатор города 
city_name VARCHAR(100) NOT NULL -- название города 
)

Таблица будет содержать персональную информацию о клиенте, такую как ФИО, контактная информация и прочие постоянные характеристики.

CREATE TABLE clients 
(
client_id SERIAL PRIMARY KEY, -- уникальный идентификатор клиента 
first_name VARCHAR(100) NOT NULL, -- имя клиента 
last_name VARCHAR(100) NOT NULL, -- фамилия клиента 
birth_date DATE, -- дата рождения клиента 
phone_number VARCHAR(20) NOT NULL, -- телефон клиента 
address VARCHAR(255), -- адрес доставки 
city_id INT, -- id города, выбранного клиентом 
FOREIGN KEY(city_id) REFERENCES cities(city_id) -- внешняя ссылка на таблицу городов 
);

Таблица будет содержать информацию о процессе регистрации клиента на сайте

CREATE TABLE client_registrations 
( 
registration_id SERIAL PRIMARY KEY, -- уникальный идентификатор регистрации 
client_id INT NOT NULL, -- внешний ключ на клиента 
login VARCHAR(100) NOT NULL UNIQUE, -- логин клиента, обязателен и уникален 
password_hash VARCHAR(255) NOT NULL,-- хэш пароля 
registration_ip VARCHAR(45), -- IP-адрес регистрации 
reg_date TIMESTAMP DEFAULT NOW(), -- точная дата и время регистрации 
FOREIGN KEY(client_id) REFERENCES clients(client_id) -- внешняя ссылка на основного клиента 
)

Задание 2

Создание второй таблицы item_prices_history обусловленно необходимостью учета истории изменения цены каждого товара. Это позволит легко получать актуальные и архивные сведения о цене товаров за любые временные интервалы.

CREATE TABLE items
( 
item_id SERIAL PRIMARY KEY, -- уникальный id товара 
item_name VARCHAR(255) NOT NULL, -- наименование товара обязательно
); 

CREATE TABLE item_prices_history
 (
price_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, -- уникальный идентификатор строки автоматически генерируемый
item_id NUMBER REFERENCES items(item_id), -- внешний ключ на основной товар 
price_item NUMERIC(9,2) NOT NULL, -- стоимость товара с 2 знаками после запятой
valid_from DATE DEFAULT CURRENT_DATE, -- начало действия данной цены 
valid_to DATE DEFAULT TO_DATE('9999-12-31', 'YYYY-MM-DD') -- конец действия данной цены 
);

Задание 3

Некоторые ошибки которые были выявлены: SUM нельзя применять внутри условия WHERE, проверка отсутсвия менеджера некоретна, неправильная группировка при вычислении зп.

SELECT d.department_id, d.department_name, sum(e.salary) as sum_salary
FROM employees e
INNER JOIN departments d ON e.department_id = d.department_id -- объединение таблиц
INNER JOIN locations l ON d.location_id = l.location_id -- объединение таблиц
  and l.city = 'SEOUL'-- фильтрация по городу Сеул
WHERE e.manager_id IS NULL -- отбор сотрудников без менеджеров
GROUP BY d.department_id, d.department_name -- группировка по отделам
HAVING SUM(e.salary) > 100000; -- выбор отделов, где общая зарплата превышает 100000

Задание 4

В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?

Если в вопросе имелось в виду про карандаш, то можно предположить, что это из-за того, что он находится в углу комнаты.
Если же имелся в виду пол, то нельзя перепрыгнуть то, на чём стоишь",
80,27275727.txt,.txt,text,"1. 
В целом таблица clients отражает почти всю нужную информацию о клиенте, но я бы сделала небольшие изменения в ней. 

- добавить пол клиента:

 ALTER TABLE clients
 ADD COLUMN gender VARCHAR(6);

- поменять поле age на birth_date, чтобы постоянно не обновлять поле age:

 ALTER TABLE clients
 DROP COLUMN age;

 ALTER TABLE clients 
 ADD COLUMN birth_date DATE;

- добавить ограничения PRIMARY KEY на столбец client_id:

 ALTER TABLE clients
 ADD PRIMARY KEY (client_id); 

2. 
Предлагаю следующие изменения в таблицу items:

- добавить поля valid_from и valid_to, чтобы указать в какой период данная цена была актуальной:

 ALTER TABLE items
 ADD COLUMN valid_from DATE NOT NULL -- дата, когда текущая цена была установлена 
 ADD COLUMN valid_to DATE; -- дата, когда текущая цена была изменена

- добавить поле record_id, чтобы в таблице был простой первичный ключ:
 
 ALTER TABLE items
 ADD COLUMN record_id int; -- идентификатор для каждой записи в таблице

 ALTER TABLE items
 ADD PRIMARY KEY (record_id);
 
- изменить тип данных поля item_cost на decimal:

 ALTER TABLE items 
 ALTER COLUMN item_cost TYPE decimal (10,2);
3.
SELECT D.DEPARTMENT_ID, -- уточнить неоднозначные поля
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) TOTAL_SALARY
 FROM EMPLOYEE E,
 DEPARTMENTS D
 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND E.MANAGER_ID IS NULL -- для проверки остуствия значения используется IS NULL
 AND D.LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
 GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME -- все поля без агрегатных функций должны быть указаны в GROUP BY
 HAVING SUM(E.SALARY) >= 100000 -- для ограничения с агрегированными функциями используется HAVING

4. 
Я не могу перепрыгнуть через карандаш потому, что:
 - я не в этой комнате;
 - карандаш упал вплотную к стене;
 - карандаш закатился под шкаф.",
81,27527878.docx,.docx,docx,"Задание 1.
Поле client_id - поставил бы ограничение PRIMARY KEY(первичный ключ) , которое бы обеспечивало гарантию уникальности записей в таблице, а также GENERATED BY DEFAULT AS IDENTITY, для автоинкремента значений в этом поле.
Поля client_name, client_surname - varchar(255) кажется избыточным я бы наверное пос varchar(100), а так же бы поставил ограничение NOT NULL.
Поле login - varchar(30) кажется недостаточным, увеличил бы значение до varchar(70), поставил ограничение, NOT NULL, а также UNIQUE для гарантии уникальных логинов.
Поле city_id - в конце таблицы бы описал ограничение - FOREIGN KEY которое бы указывало что это внешний ключ к таблице где хранятся города или адреса клиентов, для сохранения целостности данных в таблице.
Поле age - изменил бы название и тип данных поля, так как хранить возраст в числовом формате не очень логично, так как он меняется со временем. я бы переименовал поле в - birth_date, тип данных сделал бы - date, ограничение - NOT NULL и хранил бы дату рождения, чтобы потом была возможность динамически вычислять возраст.
Поле reg_date - оставил бы без изменений.
Пример исправленной таблицы:
CREATE TABLE clients (
client_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
client_name VARCHAR2(100) NOT NULL,
client_surname VARCHAR2(100) NOT NULL,
login VARCHAR(70) NOT NULL UNIQUE,
birth_date DATE NOT NULL,
city_id NUMBER,
reg_date DATE,
CONSTRAINT fk_city/address FOREIGN KEY (city_id) REFERENCES cities/addresses(city_id)
);
Задание 2.
В данном случае для обеспечения отчетности для других отделов и нормализации БД
из первоначальной таблицы я бы убрал поле item_cost и ввел отдельную таблицу в которой бы хранил историю цены товара.
Пример двух таблиц:
CREATE TABLE items (
item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
item_name VARCHAR2(255) NOT NULL
);
CREATE TABLE item_price_history (
price_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
item_id NUMBER NOT NULL,
item_cost NUMBER NOT NULL,
item_cost_start_date DATE NOT NULL, -- дата, с которой действует эта цена
CONSTRAINT fk_item FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Задание 3.
Ошибки:
Нельзя выбирать после слова FROM сразу из нескольких таблиц, таблицы соединяются JOIN-ами
После соединения таблиц JOIN-ами после ключевого слова SELECT в результирующих полях которые мы хотим получить необходимо указывать краткое название таблицы например SELECT e.* FROM employees e.(в данном примере e.* -’e’ указывает на короткое название таблицы из которой мы хотим получить данные)
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID - я бы объединил таблицы через JOIN, не уверен что так будет работать.
AND MANAGER_ID = NULL, в случае если мы объединили таблицы достаточно написать MANAGER_ID IS NULL через ‘=’ сравнивать с NULL нельзя.
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS WHERE CITY = 'SEOUL') излишне усложнено я бы написал просто таблица_с_локациями.city = 'SEOUL'
так как используется агрегирующая функция sum() необходимо поле department_id добавить в блок GROUP BY
условие AND SUM(SALARY) >= 100000 необходимо убрать из блока WHERE так как в нем есть агрегирующая функция, такие условия работают только в блоке HAVING
Пример корректного запроса:
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
Задание 4.
Не могу перепрыгнуть карандаш потому что:
Он у стены или в углу
Он выше меня размером
Он под кроватью",
82,275377.pdf,.pdf,pdf,"Вопрос 1
В первую очередь я бы выделил ошибку с city_id, так как будет ошибка
нормализации. Надо будет добавить справочную таблицу с городами, которая
будет связана с клиентом, где первичным ключом будет являться city_id.
Дальше, я бы добавил отчество клиента, его тоже было бы полезно хранить для
будущих запросов, но на него не накладывать ограничение NOT NULL, тк бывает
отсутствие отчества у человека.
Если говорить об ограничениях, то написал бы NOT NULL на все столбцы, кроме
отчества.
Дальше добавил бы email, для рассылки акций и информации клиентам.
Добавил бы еще хэш пароля, потому что надо где-то хранить пароль клиента в
закрытом доступе.
Изменил бы атрибут возраст на дату рождения и убрал бы атрибут даты
регистрации. Потому что он нецелесообразен, только для подсчета возраста, но
это как будто ненужная избыточность и проще работать с фильтрами на дату,
высчитывать возраст в запросах по дате рождения.
Также по ограничениям, уникальность на хэш, на логин, на emailв обязательном
порядке.

Вопрос 2
Сделал бы табличку с архивными данными, в которой первичный ключ дата
начала торговли товара по определенной цене и сам предмет торговли, который
определял бы эту архивную сущность. Также сделал бы атрибут дата конца срока
ценника, которая может и отсутствовать, если по текущий день используется
цена. Также атрибут цена, название акции, если в какой-то срок проходила акция,
что требуется по заданию. Значение может быть нулевым и количество
проданных товаров для финансовой отчетности.

Вопрос 3

Вопрос 4
1. Потому что я не знаю, что это за комната
2. Карандаш в углу или у стены
3. Возможно, в комнате другая система координат и он приклеился к потолку,
где пол это потолок, а потолок это пол и я хожу по потолку)",
83,2777577.pdf,.pdf,pdf,"1.
Если «number» тут не просто схематичное рандомное слово, а использованный тип данных, то нет
такого типа в SQL. Есть NUMERIC, но тут он явно не нужен. В столбце client_id тип данных должен
быть INT (целое число) с указанием того, что это ключевое поле PRIMARY KEY и автозаполнением
AUTO_INCREMENT.
Тип данных city_id нужно указать INT и указать свойство «внешний ключ» FOREIGN KEY, тк таблица
очевидно связана с некой таблицей «cities».
Тип данных для «age» соответственно INT.
В reg_date добавить DEFAULT NOW() после «DATE» или DEFAULT CURRENT_DATE() для
автоматической простановки даты.
Насчет вопроса о смысле полей. Логин есть, а пароля нет. Странно. Для авторизации на сервисе
добавить еще столбец пароль с типом данных VARCHAR.
Не знаю об этом ли задание, но вместо возраста я бы сделал дату рождения. Так и возраст
высчитать не проблема без создания полей под это, и магазин будет знать дату рождения, чтобы
допустить к товарам с ограничением по возрасту или чтобы предлагать скидки по случаю ДР. В
плане памяти мы всё равно занимаем одно поле, но функций получаем больше.
2.
Сразу снова исправлю тип данных item_id с number на INT с указанием PRIMARY KEY
AUTO_INCREMENT
Тип данных item_cost - DECIMAL(8, 2) если размера будет достаточно, 8 для примера, я не знаю
какого порядка цены у инет-магаза.
Для ведения указанной в задании статистики необходимо фиксировать ценообразование с датой
установки цены. Как минимум нужна таблица с ценами и датами.
prices (
price_id INT PRIMARY KEY AUTO_INCREMENT,
item_id INT,
price DECIMAL(8, 2),
date_price DATE CURRENT_DATE(),
FOREIGN KEY (item_id) REFERENCES items (item_id)
);
Актуальная цена товара будет доставаться по id товара и последней дате изменения.
3.
7я строка: надо manager_id IS NULL, а не «= NULL».
4я строка: таблица называется не «employee», a «employees».

сумма зарплаты по условию строго больше 100000, значит знак >, а не >=.
выборку по зарплате надо осуществить после группировки в части «HAVING»
скорректированный запрос из задания:
SELECT department_id, department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id
AND manager_id IS NULL
AND location_id IN (SELECT location_id FROM locations WHERE city = 'SEOUL')
GROUP BY department_id, department_name
HAVING SUM(salary) > 100000;
Я бы написал:
SELECT department_id, department_name
FROM
employees e
INNER JOIN departments d
ON e.department_id = d.department_id
WHERE manager_id IS NULL
AND location_id IN (SELECT location_id FROM locations WHERE city = 'SEOUL')
GROUP BY department_id, department_name
HAVING SUM(salary) > 100000;
4.
Потому что он упал вплотную к стене и, пытаясь прыгнуть, я в неё врежусь.
Потому что карандаш будут пытаться перепрыгнуть все студенты, придумывающие ответ на это
задание, мне не хватит места для прыжка.
Потому что я у себя дома сейчас.

Потому что карандаш уронили в пространстве, доступ к которому физически ограничен (уронили
под стол, под кресло).
Чтобы через него перепрыгнуть, нужно знать, где находится комната.
Потому что отец учил не прыгать через карандаш.
Потому что когда роняют канцелярский предмет, его, как правило, сразу подбирают в основном
от чувства «чем быстрее подберёшь, тем чище он будет», тк его используют в любом случае
руками и лежит он где-то на столе. А стол не пол, там должно быть плюс-минус чисто. Поэтому
если его уронил не я, то я скорее всего не успею, даже если буду находиться в той самой комнате -
его подберут.
Потому что оцепенел от заданного вопроса и не могу двигать ногами.",
84,277777.docx,.docx,docx,"Задание 1.
Поле client_id должно стать первичным ключом и быть тогда уникальным, в скрипте ниже это непрописанно, поэтому требуется добавить для этого поля ограничения.
Поле age может быть не самым лучшим выбором для хранения возраста. Вместо этого лучше хранить дату рождения клиента (birth_date date). Это позволит более точно вычислять возраст и избежать проблем с обновлением данных (например, когда клиенту исполняется 18 лет).
Поле login должно иметь уникальное ограничение, чтобы избежать дублирования логинов среди клиентов.
Также стоит рассмотреть возможность добавления поля для хранения хешированного пароля и самого пароля, если это еще не предусмотрено в другой части системы.
Поля client_name и client_surname могут быть объединены в одно поле full_name varchar, если это допустимо в контексте приложения. Однако если необходимо разделение на имя и фамилию, то текущая структура вполне приемлема. Также можно добавить поле для второго имени или отчества.
Поле city_id предполагает наличие отдельной таблицы с городами. Нужно убедится, что такая таблица существует и что она правильно связана с таблицей клиентов через внешний ключ.
Также можно добавить поля для хранения номера телефона клиента и поле для электронной почты клиента.
Поле reg_date имеет смысл, но стоит добавить автоматическое заполнение этого поля текущей датой при создании записи (например, с помощью триггера или по умолчанию).
Задание 2.
Для обеспечения исторического хранения стоимости товара в таблице items, необходимо изменить архитектуру базы данных, чтобы можно было отслеживать изменения цен на товары с течением времени.
Один из подходов - создание отдельной таблицы для хранения исторических данных о ценах. Это позволит сохранять информацию о каждой цене товара вместе с датами, когда эта цена была актуальна.
Как можно изменить архитектуру:
Создание таблицы для хранения исторических цен: Например, history_item_prices, которая будет содержать информацию о ценах товаров и периодах их действия.
CREATE TABLE history_item_prices (
history_price_id PRIMARY KEY, -- уникальный идентификатор записи о цене
item_id NUMBER, -- идентификатор товара
price_item NUMBER, -- стоимость товара
start_date DATE, -- дата начала действия цены
end_date DATE, -- дата окончания действия цены (может быть NULL для текущей цены)
);
Изменение таблицы items: В таблице items можно оставить только основную информацию о товаре, без поля для стоимости. Вместо этого мы будем ссылаться на актуальную цену в таблице history_item_prices.
При изменении цены товара необходимо будет добавлять новую запись в таблицу item_prices, устанавливая дату начала новой цены и обновляя дату окончания предыдущей цены.
Задание 3.
Неправильное имя таблицы:
Было: FROM EMPLOYEE (пропущена буква S)
Нужно: FROM EMPLOYEES
Неправильное условие для NULL:
Было: MANAGER_ID = NULL
Нужно: E.MANAGER_ID IS NULL
В SQL сравнение с NULL всегда возвращает NULL, нужно использовать IS NULL
Неправильное использование агрегатной функции:
Было: AND SUM(SALARY) >= 100000 в WHERE
Нужно: перенести в HAVING
Агрегатные функции нельзя использовать в WHERE, они применяются после GROUP BY
Лучше использовать оператор JOIN для соединения таблиц, чтобы сделать запрос более читаемым.
Неполный GROUP BY:
Было: только DEPARTMENT_NAME
Нужно: добавить DEPARTMENT_ID
Задание 4.
Вопрос интересный и неоднозначный.
Слово «некоторая» может подразумевать, что я даже не нахожусь в этой комнате и могу не знать где она находится. Также карандаш может лежать у стены или находится в таком месте, где физически не возможно перепрыгнуть (например, по столом или под стулом).",
85,3573.docx,.docx,docx,"1 задание: набор полей в таблице клиентов
Рекомендуется сделать city_id внешним ключом (FOREIGN KEY), который будет ссылаться на таблицу городов (например, cities), чтобы обеспечить целостность данных. Это необходимо для того, чтобы избежать путаницы в номерах городов и возможных ошибок со стороны системы.
Параметр age не является корректным, поскольку возраст каждого клиента меняется, что усложняет поддержание актуальности данных. Логичнее заменить поле на birth_date формата date. Дополнительно можно ввести булевое поле, например is_adult, чтобы проверять совершеннолетие клиента, если в этом есть необходимость.
Пусть в условиях задания конкретизирован используемый диалект SQL, мы не можем быть точно уверены, что используется Oracle, в котором существует тип данных number. Если используется Oracle,то тип данных client_id необходимо изменить на int, так как number включает в себя множество чисел, в том числе и числа с плавающей точкой. Однако если используется не он - типа данных number может вовсе не существовать, из-за чего необходимо изменить его на целочисленный тип int.
Рекомендуется сократить длину полей client_name и client_surname до 100-150 символов.
Пусть в задании не указаны ограничения полей, считаю необходимым указать ограничитель unique для login клиента, и primary key ограничение для поля client_id.
2 задание: историческое хранение стоимости товара
Так как построить отчёт о доходах, используя лишь таблицу со списком товаров, может быть достаточно неудобно, предлагаю ввести в архитектуру базы данных две таблицы заказов:
orders (мы намеренно жертвуем 1 Нормальной формой, чтобы упростить привязку товаров и скидок к заказу). Таким образом, структура новой таблицы выглядит так:
orders (
order_id int PRIMARY KEY, -- уникальный id заказа
client_id int, -- id клиента, который сделал заказ
order_cost float, -- общая стоимость заказа с учётом всех товаров и скидок
discount_id int[], -- внешний ключ на таблицу скидок (если есть скидка)
order_date date, -- дата заказа
item_ids int[], -- массив id товаров (вторичные ключи на таблицу items)
);
discounts. Эта таблица необходима для учёта всех скидочных предложений:
discounts (
discount_id varchar(50) PRIMARY KEY, -- уникальный код скидки
discount_name varchar(255), -- название скидки
discount_percentage float -- процент скидки
);
Из доработок:
Опять же, тип данных number меняем на int, исходя из 3 пункта в 1 задании.
В таблицу items рекомендовано добавить поле count типа int для упрощения проведения инвентаризации и подсчета оставшегося товара.
3 задание: исправление запроса
Исправленный вид запроса:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
Во избежание проблем из-за группировки будем группировать запрос не только по полю DEPARTMENT_ID, но и по полю DEPARTMENT_NAME
Для повышения читаемости заменим подзапрос JOINом (допустим, мы работаем в условиях где позволительно использовать более тяжеловесный вариант)
Проверку на соблюдение условия >100000 реализуем через HAVING так как работаем с агрегатной функцией
Проверку является ли поле NULLом заменим корректным синтаксисом (заменим = на выражение IS NULL)
Так как работаем с несколькими таблицами, то обязательно привяжем каждое из полей к той таблице, данные из которой нам необходимы, для этого используем псевдонимы
4 задание: В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Возможные причины:
Высота стен может быть недостаточной для совершения рывка.
Освещение в комнате может помешать перепрыгнуть карандаш – мы можем его не увидеть или некорректно нащупать.
Карандаш упал не в той же комнате, в которой я нахожусь, а перейти между комнатами мне не позволяют возможные обстоятельства.
Карандаш может быть больше меня, что делает его невозможным для совершения прыжка.
Моя подвижность может быть ограничена, например, инвалидным креслом или костылями.
Стены могут быть расположены слишком близко, что делает прыжок невозможным.
Мои ноги могут быть приклеены к полу или любой другой поверхности.
Это противоречит моим должностным инструкциям, NDA или указаниям ТимЛида.",
86,3673778.docx,.docx,docx,"Смысл перечисленных в задании полей корректен (можно только уточнить, что age – это возраст на момент регистрации). Но атрибутивный состав можно скорректировать:
- добавить дату рождения, а лучше заменить ей поле age;
- добавить пол;
- добавить контактные данные (почта, телефон);
- добавить маркер - откуда клиент пришел впервые на сайт (если есть реферальная программа).
Необходимо дополнить атрибутивный состав:
- добавить категорию товара; 
- добавить период актуальности цены (date_from, date_to).
Запрос не корректен. Правильно так:
select
 d.department_id,
 d.department_name, 
 sum(e.salary) as total_salary
from departments d
 join employee e
 on d.department_id = e.department_id
 join locations l
 on d.location_id = l.location_id
 and l.city = ‘SEOUL’
group by d.department_id, d.department_name
having sum(e.salary) > 100000;
Помехой может быть, например:
- карандаш оказался под объектом, который невозможно перепрыгнуть (например, большой холодильник);
- карандаш оказался в углу;
- я не нахожусь в той комнате;
- я физиологически не имею возможности прыгать;
- я не успел, т.к. карандаш подняли.",
87,3737.docx,.docx,docx,"Набор и смысл полей таблицы clients, представленной в задании считаю некорректным. Создала бы следующую архитектуру:
Таблица cities, которая хранит:
id (number) - id города
city_name (varchar) - название города
Таблица clients, которая хранит:
id (number) - уникальный id клиента;
client_name (varchar(255)) - имя клиента;
client_surname (varchar(255)) - фамилия клиента
born_date (date) – дата рождения клиента
login (varchar(30))- логин, который придумал клиент
reg_date date - дата регистрации на сайте
city_id - id города из таблицы cities, который указал клиент
Чтобы обеспечить историческое хранение стоимости товара нужно использовать следующую архитектуру таблиц:
Таблица items:
id (number) - уникальный id товара
item_name (varchar(255)) - наименование товара
Таблица orders:
Id (number) – идентификатор покупки
item_id (number) – id из таблицы items
count_item (number) – количество товара
data_item (date) – дата покупки
Таблица costs:
id (number) – идентификатор стоимости товара
Item_id (number) - id из таблицы items
item_cost (decimal) - стоимость товара
sale (decimal) – sale из таблицы sales
Таблица sales:
sale (decimal) – коэффициент скидки на стоимость товара
sale_start_date (date) – дата начала действия скидки
sale_finish_date (date) – дата окончания действия скидки
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000. Для решения задачи был написан следующий запрос:
SELECT DISTINCT
D.DEPARTMENT_NAME
FROM DEPARTMENTS D
JOIN LOCATIONS L ON (L. LOCATION_ID=D. LOCATION_ID AND L. CITY = 'SEOUL')
WHERE D.DEPARTMENT_ID = (SELECT
DEPARTMENT_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_ID)
4. В некоторой комнате на пол уронили карандаш. Я не могу через него перепрыгнуть, т.к. :
неизвестно нахождение комнаты.",
88,373873.docx,.docx,docx,"Тип данных для client_id. Использование типа number может быть неявным, особенно если это идентификатор, который должен быть уникальным. Лучше использовать INTEGER или BIGINT, чтобы явно указать тип данных.
Отсутствие ограничения на уникальность логина. Логин (login) должен быть уникальным для каждого клиента. В текущей схеме отсутствует такое ограничение. Нужно добавить уникальное ограничение (UNIQUE) на поле login.
Отсутствие информации о поле city_id. Поле city_id должно ссылаться на отдельную таблицу городов, чтобы обеспечить целостность данных. Если города хранятся в другой таблице, необходимо добавить внешний ключ.
Поле age. Сохранение возраста в виде числа может привести к проблемам с актуальностью данных, так как возраст меняется со временем. Вместо возраста лучше хранить дату рождения (birth_date DATE), что позволит более точно рассчитать возраст при необходимости.
Проверка на NULL значений. Не указаны ограничения на наличие значений в определенных полях, что может привести к неконсистентным данным. Следует установить ограничения NOT NULL для критически важных полей, таких как client_name, client_surname, login, и reg_date.
Дополнительные поля. Рассмотреть возможность добавления дополнительных полей, таких как:
email VARCHAR(255) – для хранения адреса электронной почты.
phone_number VARCHAR(15) – для номера телефона клиента.
is_active BOOLEAN DEFAULT TRUE – поле для отслеживания активности клиента.
Пример обновленной схемы таблицы:
CREATE TABLE clients (
client_id INTEGER PRIMARY KEY,
client_name VARCHAR(255) NOT NULL,
client_surname VARCHAR(255) NOT NULL,
login VARCHAR(30) UNIQUE NOT NULL,
city_id INTEGER REFERENCES cities(city_id),
birth_date DATE NOT NULL,
reg_date DATE NOT NULL,
email VARCHAR(255) UNIQUE,
phone_number VARCHAR(15),
is_active BOOLEAN DEFAULT TRUE
);
Для того чтобы обеспечить историческое хранение стоимости товара, необходимо изменить архитектуру таблицы товаров таким образом, чтобы можно было отслеживать изменения стоимости товара на разных временных промежутках. В текущей схеме, где цена товара хранится в единственном значении, мы теряем информацию о том, как цена изменялась со временем.
Доработка схемы
Создание отдельной таблицы для истории изменения цен. Можно добавить дополнительную таблицу, которая будет хранить историю изменения цен на товары с привязкой к конкретным датам.
Изменение схемы таблицы товаров. Таблица товаров останется с основной информацией о товаре, а вся история цен будет сохраняться отдельно. Это позволит хранить актуальную цену товара в таблице товаров и отслеживать изменения в отдельной таблице с историей.
Обновленная структура базы данных:
1. Таблица items (товары):
CREATE TABLE items (
item_id INTEGER PRIMARY KEY, -- уникальный id товара
item_name VARCHAR(255) NOT NULL -- наименование товара
);
2. Таблица item_prices (история цен товара):
CREATE TABLE item_prices (
item_id INTEGER, -- внешний ключ на товар
price DECIMAL(10, 2) NOT NULL, -- стоимость товара
start_date DATE NOT NULL, -- дата, с которой действует эта цена
end_date DATE, -- дата, до которой действует эта цена (может быть NULL для текущей цены)
PRIMARY KEY (item_id, start_date), -- уникальная пара товар/дата начала
FOREIGN KEY (item_id) REFERENCES items(item_id) -- внешний ключ на таблицу товаров
);
Пояснение:
Таблица items
Содержит только основную информацию о товаре, такую как item_id и item_name.
Поле стоимости товара было удалено, так как информация о стоимости теперь хранится в отдельной таблице.
Таблица item_prices:
item_id — внешний ключ, который связывает цену товара с конкретным товаром из таблицы items.
price — цена товара в момент времени.
start_date — дата, с которой эта цена начала действовать.
end_date — дата, до которой эта цена действовала. Для текущей цены можно оставить NULL, если она актуальна на данный момент.
Первичный ключ составной, состоящий из полей item_id и start_date, чтобы каждая цена была уникальной для товара и времени.
Ошибки и недочеты в запросе:
Условие проверки на NULL. Для проверки на NULL нужно использовать IS NULL, а не =.
Агрегация и фильтрация. Условие SUM(SALARY) >= 100000 должно находиться в условии HAVING, так как оно относится к результату агрегирования.
Отсутствие соединения таблиц. Следует использовать явное соединение таблиц вместо старого синтаксиса с запятой.
Недостаток группировки. При использовании GROUP BY необходимо добавить DEPARTMENT_ID в список полей для группировки, иначе это может привести к ошибке.
Местоположение. Нужно правильно соединить таблицы, чтобы корректно фильтровать по местоположению Сеул, используя связь между таблицами DEPARTMENTS и LOCATIONS через поле LOCATION_ID.
Исправленный запрос:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
Объяснение изменений:
Заменён MANAGER_ID = NULL на MANAGER_ID IS NULL.
Добавлено условие HAVING, чтобы отфильтровать по сумме зарплаты после группировки.
Используется явное соединение таблиц через JOIN, чтобы соединить EMPLOYEES, DEPARTMENS и LOCATIONS.
Для фильтрации по городу Сеул используется правильное соединение с таблицей LOCATIONS, где мы проверяем, что город равен 'SEOUL'.
В GROUP BY добавлен D.DEPARTMENT_ID для соответствия выборке.
Карандаш уронили под стенкой?",
89,375373.docx,.docx,docx,"Задание 1
clients (
client_id NUMBER PRIMARY KEY,
client_name VARCHAR(255) NOT NULL,
client_surname VARCHAR(255) NOT NULL,
login VARCHAR(100) UNIQUE NOT NULL,
city_id NUMBER REFERENCES cities(city_id),
age NUMBER CHECK (age BETWEEN 1 AND 120),
reg_date DATE DEFAULT CURRENT_DATE NOT NULL,
);
Нет ограничений на поля client_name, client_surname (могут быть пустыми)
Хотя client_id описан как ""уникальный id клиента"", в схеме не указано, что это PRIMARY KEY
Логин ограничен 30 символами, что может быть мало для современных систем
Нет ограничения на уникальность (два клиента могут иметь одинаковый логин)
Поле age может содержать нереалистичные значения (например, 200)
Добавить FOREIGN KEY для city_id (если есть соответствующая таблица городов)
Поле reg_date может быть NULL или содержать даты из будущего, по дефолту ставим текущую дату
Задание 2
Текущая структура таблицы items не подходит для хранения истории изменения цен, так как:
Содержит только текущую цену товара.
Не сохраняет историю изменений цен.
Не позволяет анализировать динамику цен во времени
Нужно создать отдельную таблицу для истории цен
-- Основная таблица товаров (текущие данные)
CREATE TABLE items (
item_id NUMBER PRIMARY KEY,
item_name VARCHAR(255) NOT NULL,
current_cost NUMBER NOT NULL
);
Что изменил и зачем:
Переименовал item_cost в current_cost для ясности
Добавил NOT NULL ограничения для обязательных полей
-- Таблица истории изменений цен
CREATE TABLE item_price_history (
history_id NUMBER PRIMARY KEY,
item_id NUMBER REFERENCES items(item_id),
old_cost NUMBER NOT NULL,
new_cost NUMBER NOT NULL,
change_date TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
changed_by VARCHAR(100),
change_reason VARCHAR(255)
);
`history_id` NUMBER Первичный ключ для однозначной идентификации записи
`item_id` NUMBER Связь с товаром (внешний ключ)
`old_cost` NUMBER Цена до изменения (позволяет сравнить ""было/стало"")
`new_cost` NUMBER Новая цена после изменения
`change_date` TIMESTAMP Точное время изменения
`changed_by` VARCHAR(100) Кто внес изменение (админ, система, скрипт)
`change_reason` VARCHAR(255) Причина изменения (акция, инфляция и т.д.)
Задание 3
select
d.department_id,
d.department_name,
sum(e.salary) as total_salary
from
employees e
join
departments d on e.department_id = d.department_id
join
locations l on d.location_id = l.location_id
where
e.manager_id is null
and l.city = ' SEOUL'
group by
d.department_id, d.department_name
having
sum(e.salary) > 100000;
Ошибки в запросе:
Неправильное условие для NULL:
Было: MANAGER_ID = NULL
Исправлено: E.MANAGER_ID IS NULL
Неправильное имя таблицы:
Было: FROM EMPLOYEE (не хватает буквы S)
Исправлено: FROM EMPLOYEES
Неправильное использование агрегатной функции:
Было: AND SUM(SALARY) >= 100000 в WHERE
Исправлено: перенесено в HAVING
Неполный GROUP BY:
Было: GROUP BY DEPARTMENT_NAME
Исправлено: GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
Неявное соединение таблиц:
Было: неявное соединение через запятую
Исправлено: явное JOIN с условиями
Проверка местоположения:
Было: подзапрос для LOCATION_ID
Исправлено: прямое соединение с таблицей LOCATIONS
Задание 4
Его уронили в угол или в нескольких сантиметрах от стены, единственный логичный ответ для меня.",
90,3783783.docx,.docx,docx,"Задание 1.
CREATE TABLE cities (
city_id NUMBER UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
city_name VARCHAR(100) NOT NULL
);
CREATE TABLE clients (
client_id NUMBER NOT NULL PRIMARY KEY AUTO_INCREMENT,
client_name VARCHAR(100) NOT NULL,
client_surname VARCHAR(100) NOT NULL,
clietn_patronymic VARCHAR(100) NOT NULL,
login VARCHAR(30) UNIQUE,
city_id NUMBER NOT NULL,
birth_date DATE,
reg_date DATE NOT NULL,
FOREIGN KEY(city_id) REFERENCES cities(city_id)
);
client_id добавили NOT NULL, PRIMARY KEY, AUTO_INCREMENT
client_name изменили VARCHAR(100) и добавили NOT NULL
client_surname изменили VARCHAR(100) и добавили NOT NULL
Добавил в таблицу client_patronymic для того, чтобы легче находить людей, так как имя и фамилия могут повторяться.
login добавили UNIQUE для уникальности
city_id добавили NOT NULL
age поменяли на birth_date с DATE, чтобы видеть полностью дату рождения
reg_data добавили NOT NULL
для city_id создали внешний ключ и создали для него таблицу cities.
Задание 2.
CREATE TABLE items (
item_id NUMBER NOT NULL AUTO_INCREMENT PRIMARY KEY, -- уникальный id товара
item_name VARCHAR(255) NOT NULL, -- наименование товара
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- дата создания записи
);
CREATE TABLE item_prices (
price_id NUMBER NOT NULL AUTO_INCREMENT PRIMARY KEY, -- уникальный идентификатор записи о цене
item_id NUMBER NOT NULL, -- идентификатор товара
price DECIMAL(10, 2) NOT NULL, -- стоимость товара (с двумя знаками после запятой)
effective_date DATE NOT NULL, -- дата, с которой эта цена была актуальна
FOREIGN KEY (item_id) REFERENCES items(item_id) -- внешний ключ, ссылающийся на items
);
Задание 3.
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
Использование JOIN для соединения таблиц EMPLOYEES и DEPARTMENTS
Проверка на NULL для MANAGER_ID с помощью IS NULL
Включены оба поля (D.DEPARTMENT_ID и D.DEPARTMENT_NAME) в GROUP BY, чтобы соответствовать правилам SQL
Условие для фильтрации по сумме зарплат теперь находится в HAVING, что позволяет фильтровать результаты после агрегации
Задание 4
На ум приходит два варианта:
Карандаш уронили у стены, и из-за этого не можем его перепрыгнуть.
Карандаш настолько маленький, что не превышает высоты шага. Таким образом, перепрыгнуть через карандаш, который находится на уровне пола, не имеет смысла.",
91,39983.docx,.docx,docx,"Задание 1.
Я считаю что данный набор вполне корректен, но есть и места которые бы я улучши:
-поле client_id сделал бы primary_key int и добавил бы auto increment
-уменьшил бы количество символов в полях client_name и client_surname
-поле age настроил бы от даты дня рождения что бы можно было следить за измененением возраста
-так же для городов создал отдельную таблицу с привязкой к city_id и названию города
- добавил бы проверку уникальности login
так же можно было бы добавить дополнительные поля такие как email, pass и т.д. зависимости от запроса потребителя
Задание 2.
Для обеспечения исторического храненения стоимости данных стоит добавить дополнительную таблицу в которой будет храниться внешний ключ товара,
дата старта определенной цены и дата её смены.
SQL:
create table items(
item_id int Primary Key,
item_name VARCHAR(100) NOT NULL
)
create table price(
price_id int PRIMARY KEY,
item_id int FORIGEN KEY (item_id) PEFERENCES item(item_id),
item_cost decimal(6, 2),
start_date date,
finish_date date
)
Задание 3.
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE
E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
Задание 4.
Есть несколько ситуаций в которых я не смогу перепрыгнуть карандаш:
1) Я не нахожусь в той комнате где карандаш уронили на пол
2) Карандаш таких размеров которые я не смогу преодалеть
3) Комната находиться на обьекте притежение которого больше чем  та сила которую я могу приложить для  того что бы совершить прыжок
4) Я или кто то опередив меня поднимет этот карандаш
5) Карандаш мог упасть рядом со стеной и поэтому его не возможно перепрыгнуть",
92,417423.docx,.docx,docx,"В целом выглядит нормально, но можно просто кое что поправить.
В логине можно уточнить UNIQUE. Или вообще убрать его если мы, например, добавим информацию о номарх телефонов (phone VARCHAR(11)) и регистрироваться можно будет через него. Ещё можно добавить хэш пароля если решили оставить логин.
С id городов я так поняла, подразумевается, что есть отдельная таблица с городами на которую можно сослаться.
Age number я бы поменяла на birth_date DATE CONSTRAIN (birth_date BETWEEN TO_DATE (’01-01-1900, DD-MM-YYYY ‘’) AND CURRENT_DATE).
DATE в reg_date можно изменить на DATETIME или TIMESTAMP DEFAULT CURRENT_DATE. (если нужно точно знать, когда произошла регистрация).
В строках имени и фамилии уточнить NOT NULL (зачем нам пользователь без имени), а ещё можно ввести ограничения что бы в строках содержались только буквы.
Добавить уточнение PRIMARY KEY в строчку client_id.
И вроде принято писать ключевые слова заглавными буквами, но на самой работе таблицы это никак не отразиться)
Легче всего просто создать новую таблицу с ценами. Можно конечно и в одной, но будет лишком загружено. Уберём тогда item_cost в основной и перенесём в новую.
CREATE TABLE prices (
price_id NUMBER PRIMARY KEY,
item_id NUMBER NOT NULL,
item_cost NUMBER NOT NULL,
start_date DATE NOT NULL,
end_date date,
FOREING KEY (item_id) REFERENCES items(item_id)
);
SELECT 
DEPARTMENT_ID, DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM
EMPLOYEES E,
DEPARTMENTS D
WHERE
E. DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.MANAGER_ID IS NULL
AND D.LOCATION_ID = ( SELECT LOCATIO_ID 
 FROM LOCATIONS 
 WHERE CITY = ‘SEOUL’)
 GROUP BY DEPARTMENT_ID, DEPARTMENT_NAME
 HFVING SUM(SALARY) > = 100000
 ;
Вопрос в том, кто сказал, что я не могу через него перепрыгнуть.",
93,422725.pdf,.pdf,pdf,"Задание 1.
Я бы поменял поле age - возраст клиента, на поле birth_date - дата
рождение клиента. Это будет лучше, потому что возраст меняется
каждый год и данные будут устаревать, а менять каждый год всем
пользователям возраст неудобно, поэтому и лучше поменять
возраст на дату рождения - возраст можно будет посчитать через
запрос.
Задание 2.
items(
item_id number, --первичный ключ
item_name varchar(255) --наименование товара
);
item_prices(
price_id number, --первичный ключ
item_id number, --ссылка на товар(внешний ключ)
item_cost number, --цена товара
start_date date, --начало действия цены
end_date date --конец действия цены
);
Задание 3.
Исправленный запрос:
SELECT d.department_id, d.department_name, SUM(salary) as
total_salary
FROM employee e, departments d
WHERE e.department_id = d.department_id
AND d.manager_id IS NULL
AND d.location_id = (
SELECT l.location_id
FROM locations l
WHERE l.city = 'SEOUL')
GROUP BY department_id, department_name
HAVING SUM(salary) >= 100000

Исправления:
1. Добавлены “d.”, “e.” для явного указания таблиц, к которым
относятся столбцы.
2. Проверка manager_id на NULL - сравнения с NULL происходят
через IS NULL, а не через “=”.
3. SUM(salary)>=100000 перенесён в HAVING, так как агрегатные
функции нельзя использовать в WHERE.
Задание 4.
Не могу перепрыгнуть карандаш, потому что его положили
вплотную к стене",
94,4228728.docx,.docx,docx,"Ответ на 1 вопрос:
После анализа структуры таблицы clients, я могу предложить несколько улучшений. Вот основные проблемы и рекомендации:
Проблемы с primary key:
client_id должен быть объявлен как PRIMARY KEY
Рекомендую использовать SEQUENCE для автоматической генерации client_id
Проблемы с полем login:
Недостаточная длина (30 символов) для современных логинов
Отсутствие UNIQUE constraint, что может привести к дублирующимся логинам
Рекомендую увеличить длину до 100 символов и добавить UNIQUE constraint
Проблемы с полем age:
Хранение возраста как number не является оптимальным решением
Возраст может устареть, лучше хранить дату рождения (date_of_birth)
Это позволит рассчитывать точный возраст в любой момент времени
Проблемы с датами:
reg_date должен быть объявлен как NOT NULL, так как дата регистрации обязательна
Рекомендую добавить TIMESTAMP вместо DATE для более точного отслеживания времени регистрации
Проблемы с именем и фамилией:
Длина 255 символов для имени и фамилии может быть избыточной
Рекомендую уменьшить до 100 символов для каждого поля
Добавить NOT NULL constraint, так как это обязательная информация
Отсутствующие важные поля:
email (для связи с клиентом)
phone (для связи с клиентом)
last_login (для отслеживания активности)
status (активен/заблокирован)
Проблемы с внешним ключом:
Поле city_id должно быть объявлено как FOREIGN KEY, ссылающийся на таблицу городов
Необходимо добавить NOT NULL constraint, так как город - важная информация
Рекомендуемая структура таблицы:
CREATE TABLE clients (
client_id NUMBER PRIMARY KEY,
client_name VARCHAR2(100) NOT NULL,
client_surname VARCHAR2(100) NOT NULL,
login VARCHAR2(100) NOT NULL UNIQUE,
email VARCHAR2(255) NOT NULL UNIQUE,
phone VARCHAR2(20),
date_of_birth DATE NOT NULL,
city_id NUMBER NOT NULL,
reg_date TIMESTAMP NOT NULL,
last_login TIMESTAMP,
status VARCHAR2(20) DEFAULT 'active',
CONSTRAINT fk_clients_city_id
FOREIGN KEY (city_id)
REFERENCES cities(city_id),
CONSTRAINT chk_status
CHECK (status IN ('active', 'blocked', 'deleted'))
);
CREATE SEQUENCE clients_seq
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;
Дополнительные рекомендации:
Добавить индексы для полей, которые часто используются в поиске (login, email)
Рассмотреть создание партиционирования таблицы по дате регистрации для оптимизации производительности
Добавить аудит-поля (created_by, updated_by, created_at, updated_at) для отслеживания изменений
Рассмотреть создание дополнительных таблиц для хранения истории изменений (если это необходимо)
Эти изменения сделают структуру более надежной, производительной и соответствующей современным требованиям к хранению данных клиентов.
Ответ на 2 вопрос:
Для обеспечения исторического хранения стоимости товара в таблице items, необходимо изменить архитектуру базы данных, чтобы учитывать изменения цен на товары с течением времени. Вот несколько предложений по доработке архитектуры:
1. Создание отдельной таблицы для исторических цен
Создайте новую таблицу, которая будет хранить исторические данные о ценах на товары. Эта таблица может выглядеть следующим образом:
item_prices (
price_id NUMBER PRIMARY KEY, -- уникальный id записи о цене
item_id NUMBER, -- id товара (внешний ключ на таблицу items)
price NUMBER, -- стоимость товара
start_date DATE, -- дата начала действия этой цены
end_date DATE -- дата окончания действия этой цены (может быть NULL для текущей цены)
);
2. Обновление таблицы items
Таблица items останется без поля item_cost, поскольку вся информация о ценах будет храниться в новой таблице item_prices. Однако, возможно, стоит добавить поле для текущей цены, чтобы упростить доступ к актуальной информации:
items (
item_id NUMBER PRIMARY KEY, -- уникальный id товара
item_name VARCHAR(255), -- наименование товара
current_price_id NUMBER, -- id текущей цены (внешний ключ на таблицу item_prices)
-- другие поля, если необходимо
);
3. Логика работы с ценами
При изменении цены товара, вместо обновления поля item_cost в таблице items, Вы будете добавлять новую запись в таблицу item_prices, указывая новую цену, дату начала действия и, при необходимости, дату окончания действия для предыдущей цены.
Например, если цена товара изменяется 1 января, Вы можете обновить предыдущую запись в item_prices, установив end_date на 31 декабря и добавив новую запись с start_date равной 1 января.
4. Пример использования
Для получения текущей цены товара можно использовать следующий SQL-запрос:
SELECT ip.price
FROM item_prices ip
JOIN items i ON ip.price_id = i.current_price_id
WHERE i.item_id = :item_id
AND (ip.end_date IS NULL OR ip.end_date > SYSDATE);
Заключение
Такой подход позволит Вам хранить исторические данные о ценах товаров, а также обеспечит гибкость для отчетности и анализа ценовых изменений с течением времени.
Ответ на 3 вопрос:
Давайте проанализируем и исправим запрос. Вот основные проблемы и исправления:
Неправильное сравнение с NULL - нужно использовать IS NULL
Неправильная агрегация - SUM(SALARY) не может быть в WHERE
Неполный GROUP BY - нужно добавить DEPARTMENT_ID
Неправильное соединение таблиц - лучше использовать JOIN
Неправильное использование агрегатной функции в WHERE
Исправленный запрос:
SELECT DEPARTMENT_NAME
FROM EMPLOYEES
JOIN DEPARTMENTS ON DEPARTMENT_ID = DEPARTMENT_ID
WHERE MANAGER_ID IS NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(SALARY) >= 100000;
Основные изменения:
Использование JOIN вместо запятой для соединения таблиц
Использование IS NULL для проверки отсутствия менеджера
Перемещение агрегатной функции SUM в HAVING
Добавление DEPARTMENT_ID в GROUP BY
Использование правильных алиасов для таблиц
Запрос возвращает только имя отдела, а не индекс, имя и сумму зарплат
Этот запрос вернет все отделы в Сеуле, где сотрудники без менеджера зарабатывают в сумме более 100000.
Ответ на 4 вопрос:
Предположим, что я нахожусь в одной комнате, а карандаш в другой. В таком случае можно предположить, что у меня нет прав на доступ в комнату, где находится карандаш, таким образом я в данный момент не могу его перепрыгнуть.",
95,42324.docx,.docx,docx,"Захаров Кирилл Сергеевич

Тестовое задание, data engineer
Задание 1.

1. В первую очередь, поменял бы client_id с number на integer primary key, так как это уникальный идентификатор
2. Client_name и client_surname ограничил бы до хотя бы 100 символов
3. Login наоборот увеличил бы, так же хотя бы до 100 символов.
4. Этим трем полям также поставил бы not null значения, если есть возможность
5. Полям age и city_id поменял значения на integer, так как они целочисленные. (не уверен, что в логике этой некой базы данных есть возможность для city_id это сделать, но было бы неплохо)
6. Не знаю, нужно ли добавлять поля, но логичными выглядят: пароль (т.к. есть логин) и пол (для аналитики интернет-магазина)

Задание 2.
Item_id поменять с number на integer primary key, как и в первом задании.
Поменять item_cost на decimal (10, 2)
3. Самым логичным для выполнения задачи будет создать отдельную таблицу, в которой будет именно «хроника» изменения цен (айди, цена, дата, ключ на эту таблицу)
4. Если обязательно нужно оставить все данные внутри одной таблицы, то можно добавить n-ное количество полей для каждого изменения цены.
Либо если позволяет база данных, то хранить историю изменения цен и дату этих изменений в виде списка json, например, либо использовать сериализацию.
Задание 3.

SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000

Использую join вместо =, использую on для определения связи таблиц, исправил ошибку с IS NULL, добавил указания таблиц для использования manager_id и location_id, добавил в group_by поле id и наконец перенес sum(e.salary) в having.

Задание 4.
Я не могу перепрыгнуть через карандаш, так как я нахожусь в определенной комнате, в которой не роняли карандаш. У меня нет информации о том, в какой комнате уронили карандаш (по крайней мере, я не услышал звука). Собственно, и информации о расположение точном либо относительном этой комнаты у меня тоже нет. При наличии всей необходимой информации, я бы смог попасть (или как минимум построить план попадания меня в эту комнату) в эту комнату и тогда появилась возможность его перепрыгнуть, опять же, если это обычный по размерам карандаш и он не закатился в какой-нибудь угол или щель.",
96,4272782.pdf,.pdf,pdf,"Ответы на тестирование Кечкин И. А., специальность «Дата инженер»
1. Набор атрибутов и их параметры указаны верны, можно по клиентам только
добавить еще Отчество, как необязательное поле (не всех оно есть). Название
атрибута «client_middlename» - varchar(255).
2. Добавить в витрину новый атрибут «rep_date_cost» - дата с ценой товара, формат
date (благодаря этому можно будет подтягивать изменение цены во времени).
3. Исходный запрос с исправлениями (красным и жирным шрифтом внесены
исправления):
SELECT
DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = .
AND LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) > 100000
GROUP BY DEPARTMENT_NAME
4. Самый простой и логичный ответ, так как карандаш лежит плотно к стене и
поэтому невозможно его перепрыгнуть.
Как альтернативный ответ, не получается перепрыгнуть так как он лежит под
неподвижным предметом (шкаф, диван и прочее).",
97,42782723.txt,.txt,text,"Задание 1.
Изменения:
1) Добавить элемент phone с номером телефона.
2) Добавить условия NOT NULL для имени, фамилии, почты и номера телефона.
3) Добавить UNIQUE для элементов client_id и login.
4) Уменьшить количество символов для имени и фамилии до 60.
5) Для возраста использовать integer вместо number. Добавить ограничения для возраста от 14 до 110.

Задание 2.
Нужно создать для дополнительную таблицу, в которой записываются изменённые цены товара и даты этих изменений.
Пример таблицы:
price_history(
 price_change_id NUMBER PRIMARY KEY, 
 item_id NUMBER,
 price NUMBER,
 date DATE,
 FOREIGN KEY (item_id) REFERENCES items(item_id)
);

Задание 3.
1) Неправильное имя таблицы: EMPLOYEE нажно заменить на EMPLOYEES.
2) Всесто условия MANAGER_ID = NULL должно быть условие MANAGER_ID IS NULL.
3) SUM(SALARY) в WHERE - агрегатные функции нельзя использовать в WHERE
4) Нет DEPARTMENT_ID в GROUP BY
5) Нет связи с таблицей locations

Исправленный запрос:
SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE L.CITY = 'SEOUL'
 AND E.DEPARTMENT_ID IN (
 SELECT DEPARTMENT_ID
 FROM EMPLOYEES
 WHERE MANAGER_ID IS NULL
 )
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;

Задание 4.
Я не могу перепрыгнуть через карандаш, потому что:
1) не могу попасть в комнату, так как она может быть заперта.
2) карандаш поднимут до того как я окажусь в комнате.
3) карандаш, если это обычный карандаш, является слишком маленьким объектом, чтобы прыжок для перемещения над ним был применим и необходим.",
98,43.pdf,.pdf,pdf,"1. Данная схема таблицы clients в целом выглядит разумно, но у неё
есть несколько важных недочётов и потенциальных улучшений, как с точки
зрения нормализации данных, так и практического использования. Ниже
привожу анализ по каждому полю и рекомендации:
Анализ полей
• client_id number: всё хорошо, но первичный ключ, должен быть
уникальным. Лучше явно обозначить как primary key.
• client_name varchar(255) и client_surname varchar(255): можно
объединить в одно поле full_name, если нет сценариев, где имя и
фамилия используются по отдельности. Также стоит ограничить
длину: 255 — избыточно. Например, varchar(63) будет более
уместным.
• login varchar(30): должен быть уникальным, это важно. Нужно
добавить unique.
• city_id number: должно быть явно указано, что это foreign key на
таблицу cities(id).
• age number: лучше хранить дату рождения (birth_date date), чтобы в
любой момент можно было рассчитать актуальный возраст.
• reg_date date: желательно убедиться, что по умолчанию ставится
sysdate или current_date.
Предлагаемая улучшенная структура таблицы
clients (
client_id number primary key,
full_name varchar(63),
login varchar(30) unique,
city_id number references cities(city_id),
birth_date date,
reg_date date default current_date
);

2. Решение: вынести цены в отдельную таблицу
Предлагается разделить данные о товарах и их стоимости на две
таблицы:
Таблица товаров (items)
items (
item_id number primary key,
item_name varchar(255) not null
);
Таблица истории цен (item_prices)
item_prices (
price_id number primary key,
item_id number references items(item_id),
price number not null,
valid_from date not null,
valid_to date default null,
check (valid_to is null or valid_to > valid_from)
);
Пояснение
item_id: связь с товаром
price: стоимость на данный период
valid_from: дата начала действия этой цены
valid_to: дата окончания действия этой цены (если NULL, значит это
текущая цена)
Пример использования
item_id price valid_from valid_to
1 100 2023-01-01 2023-08-31
1 120 2023-09-01 2024-01-15
1 150 2024-01-16 (NULL)

3. Исправленный корректный запрос
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID =
D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) >= 100000;
4. Ответ: потому что перепрыгивать карандаш просто незачем, его
можно легко переступить, обойти или, в конце концов, поднять.",
99,4424278.pdf,.pdf,pdf,"1)
 Тип client_id можно поменять на int (этот тип обеспечивает быструю
индексации, легко настраивается для автоинкремента, также обеспечивает
эффективное использование памяти по сравнению с number) . Если он является
первичным ключом, то нужно убедиться, что он автоматически
инкрементируется и является уникальным.
 client_name и client_surname: можно ограничить длину до более разумного
значения, например varchar(30), это поможет избежать избыточности
использования места
 login: всё в порядке
 city_id: нужно убедиться, что существует таблица городов, на которую
ссылается этот идентификатор
 age: Так как возраст меняется каждый год, то лучше хранить дату рождения
клиента (типа date), что поможет вычислять возраст клиента на текущий момент
 reg_date: нужно проверить, что поле автоматически заполняется при
регистрации клиента
2)
 В таблице items item_cost нужно заменить на current_item_cost(типа
decimal(10,2) для лучшей точности цены), так как цены время от времени
меняются, а нам нужно знать текущую стоимость товара.
 Тип item_id лучше поменять на int для облегчения настройки автоинкремента.
 Нужно добавить таблицу, которая будет хранить историю цен, например,
item_price_history. Она будет состоять из:
o item_id(int) - идентификатор товара, на который ссылается запись
o price(decimal(10,2)) - стоимость товара на определенную дату. Хранит
историческую стоимость товара
o day_date(date) - дата, с которой начинает действовать данная стоимость
 Логика работы:
o При изменении стоимости товара в таблице items обновляется
поле current_item_cost, в таблицу item_price_history добавляется новая
запись с item_id, новой стоимостью (price) и датой изменения (day_date).
o Для построения отчетов за определенный период используется
таблица item_price_history. Можно определить, какая стоимость была
актуальна в любой момент времени, используя поле day_date.
3)
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'Seoul'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
 Для соединения таблиц используем JOIN, это делает запрос более читаемым, а
также он необходим для соединения с таблицей LOCATIONS

 Агрегатная функция SUM не может использоваться в WHERE, поэтому используем
её в HAVING, ведь она применяется к результатам группировки
 Используем IS NULL для проверки отсутствия менеджера
 Группировка данных должна быть по DEPARTMENT_ID, а не только по
DEPARTMENT_NAME, иначе данные могут агрегироваться некорректно
4) Если карандаш положили вплотную к стене, то как бы человек не старался,
перепрыгнуть у него не получится",
100,442535652.docx,.docx,docx,"№1
Я бы внёс следeдующие доработки:
Сделал бы поле login уникальным
Поменял поле age на birthday_date так как возраст каждый год меняется и лучше хранить дату рождения
Добавил бы дополнительные поля с информацией о пользователях, если их нет в других таблицах
Для имени и фамилии можно было бы сделать тип varchar(100) так как 250 символов это слишком много.
№2
Я бы оставил в этой таблице колонки item_id и item_name, и создал бы отдельную таблицу с ценами на товары, которая была б ы связана через item_id с исходной. В новой таблице были бы поля для хранения уникального id цены, id товара (foreign key), дата начала действия цены, конца действия цены и самой цены.
№3
Основные ошибки в том что в where нельзя использовать агрегатные функции, и в “=null”, в group by. Вот правильный запрос:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.LOCATION_ID = L.LOCATION_ID
AND L.CITY = 'SEOUL'
AND E.MANAGER_ID IS NULL
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
№4
Я могу через него перепрыгнуть, как и любой человек. Если искать причины, которые могут помешать это сделать, то можно сказать, что это просто бессмысленно, и может показаться странным для того, кто его уронил.",
101,452324528.pdf,.pdf,pdf,"1. Тестовое задание № 1
Исходную таблицу clients можно разбить на таблицу clients, accounts, cities.
Таблица clients будет содержать все информацию о клиенте. В нее могут быть
добавлены и дополнительные колонки, содержащие паспортные данные, пол, адрес, дату
рождения, номер телефона и т.д. Итоговый вариант мог бы выглядеть таким образом:
clients (
client_id serial, -- primary key id клиента
client_name varchar(20), --имя клиента
client_surname varchar(20), --фамилия клиента
client_patronymic varchar(20), -- отчество клиента
city_id serial, -- id города, foreign key (связан с city_id
таблицы cities)
address varchar(255), --адрес регистрации/проживания
date_of_birth date, -- дата рождения
passport_number varchar(20), -- пасспорт клиента
phone_number varchar(20) -- телефон
);
Таблица accounts будет содержать login, client_id, дату о регистрации аккаунта.
accounts (
account_id serial, -- primary key id аккаунта
client_id serial, -- foreign key ( связан с client_id таблицы clients)
login varchar(20), -- логин пользователя UNIQUE (должна быть
проверка на уникальность в столбце и NOT NULL)
password varchar(20), -- пароль NOT NULL
reg_date date --дата регистрации
);
Таблица cities будет содержать id города, название, почтовый индекс.
cities (
city_id serial, -- primary key id номер города

city_name varchar(20), -- название города
city_code integer -- почтовый индекс города
);
Таким образом, при удалении из таблицы accounts записей, данные в таблице clients
останутся. То есть даже при удалении аккаунта вся персональная информация о клиенте
будет храниться в БД.
2. Тестовое задание № 2
Таблицу items можно модифицировать следующим образом:
Items (
item_id serial, -- уникальный id товара
item_name varchar(255), -- наименование товара
purchase_price decimal(10,2), -- закупочная цена с двумя знаками после
запятой
extra_charge decimal(5,2), -- наценка на товар продавцом в % с 2 знаками
после запятой
retail_price decimal(10,2), -- цена товара с учетом наценки продавца
(retail_price = extra_charge/100 * purchase_price)
description varchar(255) -- описание товара (характеристики и тд)
);
Таблица клиентов.
clients (
client_id serial, -- primary key id клиента
client_name varchar(20), --имя
client_surname varchar(20), --фамилия
client_patronymic varchar(20), -- отчество
city_id serial, -- id города, foreign key (связан с city_id
таблицы cities)
address varchar(255), -- адрес регистрации/проживания
date_of_birth date, -- дата рождения

passport_number varchar(20), -- паспорт
phone_number varchar(20), -- телефон
personal_discount decimal(4,2), -- скидка по программе лояльности
ограничение >=0 и <100
);
Таблица продаж.
sales(
id serial, --primary key id заказа
client_id serial, -- foreign key (связан с client_id таблицы clients)
order_id serial, -- foreign key состав заказа (связан с order_id таблицы
orders)
total_price decimal(10,2), -- стоимость заказа без учета скидок
date date, -- дата заказа
delivery_cost decimal(6,2), -- default самовывоз ( 0 ) или стоимость доставки
final_price decimal(10,2), -- расчетное поле, в котором формируется
итоговая цена с учетом всех товаров (в т.ч. одинаковых позиций) и при учете всех
скидок
status varchar(20) -- статус заказа исполнен / отменен / в процессе
исполнения
);
Таблица скидок/акций.
discounts (
id_discount serial, -- primary key номер скидки/акции
discount_name varchar(20), -- наименование скидки/акции
discount decimal(4,2), -- величина скидки (ограничение >=0 и
<100)
description varchar(255) -- описание скидки
);
Таблица заказов.

orders (
order_id serial, --foreign key (связан с total_items таблицы sales)
item_id serial, --foreign key (связан с item_id таблицы items)
quantity integer – кол-во однотипных товаров
);
Таблица clients содержит основную информацию о клиенте, а также величину
персональной скидки на товар.
Таблица items содержит информацию о товаре, его закупочной цене.
Таблица discounts содержит названия скидки, номер скидки, описание. Имеет
внешний ключ столбца с % скидки для итогового расчёта цены товара.
В таблице sales основные данные для построения отчета.
В таблице orders данные по заказам (отношение многий ко многим items-sales). В
этой таблице будет расписан заказ с входящими в него позициями.
Для сохранения исторической стоимости товара можно добавить таблицу
hist_items, где item_id был бы внешним ключом, взятый из таблицы items. При добавлении
нового товара в items, price_start_dt фиксирует дату и цену товара (retail_price в таблице
items), а price_stop_dt при этом указываем равным бесконечности (условно 31-12-2999).
При изменении же цены (retail_price в таблице items), в таблицу hist_items добавляется
новая запись, где фиксируется price_stop_dt момент изменения цены(уже не
бесконечность), а в качестве нового price_start_dt берется ""старое"" price_stop_dt + 1
секунда. Таким образом будет четко зафиксирован момент изменения цены, при этом не
будет конфликта времени.
hist_items (
item_id serial, -- id товара (foreign key связан с item_id таблицы items),
price_start_dt date, -- стартовая цена/новая цена
price_stop_dt date, -- дата, в которую изменилась цена
retail_price decimal(10,2) -- цена товара (foreign key связан с retail_price
таблицы items)
);
Дополнительно нужно было бы написать скрипт, который отслеживал бы
изменение поля цены (retail_price) товара в таблице items и делал бы соответствующую
запись в таблицу hist_items. В дальнейшем можно было бы отследить изменение цены в

произвольном интересующем нас интервале времени или найти цену в конкретную дату.
Для полноты информации можно добавить сезонные скидки/акции, чтобы понимать, как
формировалась цена в конкретном временном интервале.
3. Тестовое задание №3
Блок кода с исправлениями.
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID =D.DEPARTMENT_ID
JOIN LOCATIONS L
ON D.LOCATION_ID=L.LOCATION_ID
WHERE L.CITY = ‘SEOUL’
AND E.MANAGER_ID IS NULL
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
4. Тестовое задание №4
Карандаш лежит у стены или в углу комнаты.",
102,452345.pdf,.pdf,pdf,"1.
a) изменил бы client_id, сделав PRIMARY KEY и AUTO_INCREMENT, чтобы являлся первичным
ключом и автоматически заполнялся
б) добавил бы в поля client_name, client_surname, login NOT NULL, чтобы поля обязательно были
заполнены
в) в login добавил бы UNIQUE чтобы не было дубликатов
г) age заменил на birth_date с типом DATE, для того чтобы через год не считали, что клиент остался
такого же возраста
д) reg_date добавил DATE DEFAULT CURRENT_DATE, чтобы автоматически проставлялась дата
регистрации
Вот пример запроса:
CREATE TABLE clients (
client_id INT PRIMARY KEY AUTO_INCREMENT,-- уникальный id клиента, автоинкрементируемый
client_name VARCHAR(255) NOT NULL, -- имя клиента
client_surname VARCHAR(255) NOT NULL, -- фамилия клиента
login VARCHAR(30) UNIQUE NOT NULL, -- логин, уникален
city_id INT NOT NULL, -- id города
birth_date DATE, -- дата рождения клиента
reg_date DATE DEFAULT CURRENT_DATE, -- дата регистрации на сайте с текущей датой по
умолчанию
);
--------------------------------------------------------------------------------------------------------------------------------------
2.
a) Нужно сделать item_id INT PRIMARY KEY AUTO_INCREMENT, чтобы он являлся первичным ключом
и автоматически заполнялся.
б) Поле item_cost следует сделать DECIMAL, поскольку цена может быть с копейками.
в) Нужно добавить поля date_receipt и date_sale, чтобы формировать финансовые отчеты.
Например, можно узнать, сколько и по какой цене были проданы товары. Если разница между
date_sale и date_receipt составит количество дней, это даст понимание оборачиваемости товара и
позволит узнать, за сколько дней продаётся конкретный товар. Таким образом, мы сможем
понимать, какие товары пользуются большим спросом.
Вот пример запроса:

items (
item_id INT PRIMARY KEY AUTO_INCREMENT, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost DECIMAL(8, 2), –стоимость товара
date_receipt DATE, – дата поступления в магазин/склад
date_sale DATE – дата продажи
);",
103,452345225.pdf,.pdf,pdf,"Вопрос №1
1) Нет ограничений для первичного ключа (client_id) — это
нарушение сущностной целостности;
Необходимо добавить обозначение, что данное поле является первичным
ключом (PRIMARY KEY). Ещё нужно добавить ограничение, чтобы
первичный ключ никогда не мог быть пуст (NOT NULL).
2) Нет ограничений для внешнего ключа — это будет нарушение
ссылочной целостности;
Должны быть добавлены ограничения для внешнего ключа: внешний ключ
должен обязательно вести на существующую запись в связанной таблице
или быть неопределенным.
3) Не добавлены ограничения для возраста — это нарушение
доменной целостности;
Должно быть быть добавлено ограничение для возраста (чтобы он был
больше нуля или какого-то значение, принятого в компании) при помощи
предиката CHECK.
4) Не установлено значение по умолчанию для даты — это нарушение
доменной целостности;
Должно быть быть установлено значение по умолчанию для столбца
reg_date при помощи атрибута DEFAULT.
5) У пользователя нет пароля — это нарушение бизнес-целостности;
Для дальнейшей аутентификации пользователя, должны иметься
соответствующие данные, например логин и пароль.
6) Не установлены ограничения на пустые поля — нарушение
доменной целостности;
В данной таблице все поля, кроме фамилии и внешнего ключа
(client_surname, city_id), не могут быть пустыми и должны быть
установлены ограничения NOT NULL.
1

clients (
client_id number PRIMARY KEY UNIQUE NOT
NULL, --уникальный id клиента
client_name varchar(255) NOT NULL, --имя
клиента
client_surname varchar(255), --фамилия клиента
login varchar(30) NOT NULL, --логин,
который придумал клиент
password varchar(255) NOT NULL, --пароль,
который придумал клиент
city_id number, --id города, который
указал клиент (в интерфейсе выбирается название города, а
в таблицу сохраняется id)
age number NOT NULL, --возраст клиента
reg_date date DEFAULT date.now, --дата
регистрации на сайте
CHECK (age> 0)
)
2

Вопрос №2
Для начала необходимо изменить тип данных для стоимости товара с
number на decimal (этот тип данных используется для величин, для
которых необходимо сохранить повышенную точность) или другие,
например, smallmoney (decimal(10, 4)) или money (decimal(19, 4)) в
Transact-SQL (Microsoft SQL Server), а также money в PostgreSQL.
Естественно необходимо добавить необходимые ограничения для всех
полей, чтобы не было нарушений целостности.
Хранение истории изменений стоимости товара можно сделать
двумя вариантами:
1) С точки зрения реляционной алгебры лучше хранить цену в
таблице с историей:
items (
item_id number PRIMARY KEY NOT NULL,
--уникальный id товара
item_name varchar(255) NOT NULL,
--наименование товара
)
history_cost (
history_id number PRIMARY KEY UNIQUE NOT NULL,
--уникальный id записи
item_id number, -- id товара
item_cost number NOT NULL, --стоимость товара
date_changed date NOT NULL, --дата изменении цены
на товар
)
2) С точки зрения производительности актуальную цену можно
хранить в таблице товаров (items), а историю в отдельной таблице.
Этот вариант оправдан только в случае, если соединение (join) с
таблицей истории сильно влияет на производительность:
3

items (
item_id number PRIMARY KEY UNIQUE NOT NULL,
--уникальный id товара
item_name varchar(255) NOT NULL,
--наименование товара
item_cost number NOT NULL, --стоимость товара
)
history_cost (
history_id number PRIMARY KEY UNIQUE NOT NULL,
--уникальный id записи
item_id number, -- id товара
date_changed date NOT NULL, --дата изменении цены
на товар
)
4

Вопрос №3
SELECT D.DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEES AS E JOIN DEPARTMENTS AS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE MANAGER_ID = NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(SALARY) >= 100000;
5

Вопрос №4
Карандаш положили вплотную к стене или в комнату с карандашом
не возможно попасть, поэтому и перепрыгнуть через карандаш не
возможно.
6",
104,4523452455.docx,.docx,docx,"Я считаю, что таблицу с информацией о зарегистрировавшихся
покупателях (клиентах) необходимо разбить на несколько таблиц для нормализации базы данных.
Предлагаю таблицы registrations, clients, cities:
registrations (
registration_id number, -- уникальный id регистрации, primary key
client_id number, -- уникальный id клиента, foreign key
login varchar(30), --логин, который придумал клиент
reg_date date --дата регистрации на сайте
);
clients (
client_id number, --уникальный id клиента, primary key
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
birth_date date –дата рождения клиента (! Не age (возраст), так как возраст – величина, изменяемая во времени)
city_id number,-- уникальный id города, foreign key
);
cities (
city_id number,-- уникальный id города, primary key
city_name varchar(255), --имя города
)
Предлагаю вместо одной таблицы items сделать две items и prices:
items (
item_id number, --уникальный id товара, primary key
item_name varchar(255), --наименование товара
);
prices (
price_history_id number, --уникальный id исторической цены, primary key
item_id number, --уникальный id товара, foreign key
price number, --стоимость товара
price_data data, -- дата
)
3.
WITH source_data AS
(SELECT *
FROM HR.EMPLOYEE E,
HR.DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
)
SELECT
DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM source_data
WHERE MANAGER_ID IS NULL
AND LOCATION_ID IN (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) >= 100000
4. Не могу перепрыгнуть через карандаш, так как он лежит на полу у одной из стен, либо у двух стен (в углу) комнаты.",
105,4523453.docx,.docx,docx,"Задача 1
Ответ:
В данной структуре таблицы имеется несколько моментов, которые можно улучшить:
Атрибут «age» является неинформативным, т.к. отражает возраст на момент регистрации. Со временем данные будут терять актуальность, если их не обновлять ежегодно. 
Решение:
Необходимо заменить поле «age» на поле «birthdate» с типом date, в котором будет храниться дата рождения клиента
Атрибут «client_id» использует тип данных NUMBER, что избыточно, учитывая, что первичные ключи являются целочисленными.
Решение:
Необходимо заменить тип данных на INT или BIGINT, в зависимости от предполагаемого числа клиентов.
Атрибут «client_name» и «client_surname» используют тип данных VARCHAR(255), что может быть избыточным для имени\фамилии.
Решение:
С целью экономии памяти нужно заменить на VARCHAR(100) – этого должно быть достаточно для имени\фамилии
Атрибут «city_id» является внешним ключом для таблицы городов. Используется тип данных NUMBER, что избыточно, учитывая, что первичные ключи являются целочисленными.
Решение:
Необходимо заменить тип данных на INT.
Задача 2
Ответ:
Для хранения исторической стоимости товара можно применить несколько подходов:
Если мы не ограничиваемся одной таблицей, то вместо атрибута item_cost number использовать внешний код cost_id BIGINT для связи с таблицей costs. В таблице costs создать следующие атрибуты:

cost_id BIGINT – первичный ключ цены
cost_value NUMBER – цена в у.е.
currency_id INT – внешний код валюты (если торговля в нескольких валютах)
item_id BIGINT – внешний код товара, чтобы можно было найти все цены, когда они поменяются
date_active_start DATE – дата начала активности
date_active_end DATE – дата окончания активности
reason VARCHAR(255) – причина установки цены

Данная таблица позволит провести анализ по каждому товару в какой период, какая цена была установлена и по какой причине.
Если мы ограничиваемся одной таблицей, то можно использовать дополнительный атрибут, который будет хранить информацию о цена в формате JSON
Считаю первый способ более правильным, т.к. сохраняется целостность данных и нет необходимости парсинга JSON.
Задача 3
Ответ:
Используем JOIN для присоединения таблицы DEPARTMENTS
Используем JOIN для присоединения таблицы LOCATIONS вместо подзапроса
Используем правильное название таблицы EMPLOYEES вместо EMPLOYEE
Исправляем проверку на отсутствие менеджера с E.MANAGER_ID = NULL на E.MANAGER_ID IS NULL
В группировку добавляем недостающий атрибут DEPARTMENT_ID
Фильтрацию по сумме выносим в HAVING, т.к. нам нужно профильтровать сгруппированную сумму Заработной платы по отделу.
Исправленный запрос:

SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'Seoul'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
Задача 4
Ответ:
Есть несколько вариантов:
Неопределенность пространства – карандаш уронили в «некоторой» комнате, означает, что нам точно неизвестно в какой именно комнате находится карандаш
Физические ограничения – карандаш может занимать положение, которое мешает прыжку, например возле стены или другого предмета. Также, комната может быть ограничена пространством.",
106,452352245.pdf,.pdf,pdf,"Вопрос №1
1) Нет ограничений для первичного ключа (client_id) — это
нарушение сущностной целостности;
Необходимо добавить обозначение, что данное поле является первичным
ключом (PRIMARY KEY). Ещё нужно добавить ограничение, чтобы
первичный ключ никогда не мог быть пуст (NOT NULL).
2) В зависимости от используемой БД, необходимо либо использовать
тип данных SERIAL (в postgresql), либо устанавливать
AUTO_INCREMENT (в таких БД как MySQL) для первичного
ключа;
В PostgreSQL ключевое слово SERIAL используется для автоматической
генерации возрастающих числовых значений в столбце.
3) Не указано, что поле city_id является внешним ключом — это
нарушение ссылочной целостности;
Необходимо указать имя связанной таблицы и имя столбца из этой
таблицы, на который будет указывать внешний ключ.
4) Также для внешнего ключа не установлено действие при удалении
или изменении связанной строки из главной таблицы — это будет
нарушение ссылочной целостности;
По умолчанию устанавливается опция NO ACTION, которая выдаст
ошибку при удалении связанной строки в главной таблице. Необходимо
установить null (SET NULL) в поле внешнего ключа или значения по
умолчанию (SET DEFAULT) при удалении записи из главной таблицы.
5) Поле ввода возраста лучше заменить на дату рождения;
Для даты рождения должны быть установлены ограничения, например,
чтобы нельзя было поставить дату больше сегодняшней.
6) Не установлено значение по умолчанию для даты регистрации
(reg_date) — это нарушение доменной целостности;
1

Должно быть быть установлено значение по умолчанию для столбца
reg_date при помощи атрибута DEFAULT.
7) Не установлено ограничения уникальности для поля login —
нарушение пользовательской (бизнес-целостности);
Поле login должно иметь уникальное значение, этого можно достичь,
например при помощи атрибута UNIQUE в postgresql;
8) Поле login лучше переименовать в client_username, так как
некоторые системы могут интерпретировать login как специальное
слово;
9) У пользователя нет пароля — это нарушение пользовательской
(бизнес-целостности);
Для дальнейшей аутентификации пользователя, должны иметься
соответствующие данные, например логин и пароль.
10) Не установлены ограничения на пустые поля — нарушение
доменной целостности.
В данной таблице все поля, кроме фамилии и внешнего ключа
(client_surname, city_id), не могут быть пустыми и должны быть
установлены ограничения NOT NULL.
2

Пример исправленной схемы БД:
clients (
client_id SERIAL PRIMARY KEY NOT NULL,
--уникальный id клиента
client_name varchar(255) NOT NULL, --имя
клиента
client_surname varchar(255), --фамилия клиента
client_username varchar(30) UNIQUE NOT NULL,
--логин, который придумал клиент
client_password varchar(255) NOT NULL, --пароль,
который придумал клиент (храним в виде хэша с
добавлением соли)
FOREIGN KEY city_id number REFERENCES
City (Id) ON DELETE SET NULL, --id города, который указал
клиент
date_of_birth date NOT NULL, --дата рождения
reg_date date DEFAULT date.now, --дата
регистрации на сайте
CONSTRAINT valid_birth_date CHECK (date_of_birth <=
CURRENT_DATE)
)
3

Вопрос №2
Для начала необходимо изменить тип данных для стоимости товара с
number на decimal (этот тип данных используется для величин, для
которых необходимо сохранить повышенную точность) или другие,
например, smallmoney (decimal(10, 4)) или money (decimal(19, 4)) в
Transact-SQL (Microsoft SQL Server), а также money в PostgreSQL.
Естественно необходимо добавить необходимые ограничения для всех
полей, чтобы не было нарушений целостности.
Хранение истории изменений стоимости товара можно сделать
двумя вариантами:
1) С точки зрения реляционной алгебры лучше хранить цену в
таблице с историей:
items (
item_id SERIAL PRIMARY KEY NOT NULL,
--уникальный id товара
item_name varchar(255) NOT NULL, --наименование
товара
)
history_cost (
history_id SERIAL PRIMARY KEY UNIQUE NOT NULL,
--уникальный id записи
FOREIGN KEY item_id number REFERENCES items
(item_id) ON DELETE SET NULL, -- id товара
item_cost number NOT NULL CHECK (item_cost > 0),
--стоимость товара
date_changed date NOT NULL, --дата изменении цены
на товар
CONSTRAINT valid_date_changed CHECK (date_changed <=
CURRENT_DATE)
)
4

2) С точки зрения производительности актуальную цену можно
хранить в таблице товаров (items), а историю в отдельной таблице.
Этот вариант оправдан только в случае, если соединение (join) с
таблицей истории сильно влияет на производительность:
items (
item_id SERIAL PRIMARY KEY UNIQUE NOT NULL,
--уникальный id товара
item_name varchar(255) NOT NULL, --наименование
товара
item_cost number NOT NULL CHECK (item_cost > 0),
--стоимость товара
)
history_cost (
history_id SERIAL PRIMARY KEY UNIQUE NOT NULL,
--уникальный id записи
FOREIGN KEY item_id number REFERENCES items
(item_id) ON DELETE SET NULL, -- id товара
date_changed date NOT NULL, --дата изменении цены
на товар
CONSTRAINT valid_date_changed CHECK (date_changed <=
CURRENT_DATE)
)
5

Вопрос №3
SELECT D.DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEES AS E JOIN DEPARTMENTS AS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE MANAGER_ID = NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(SALARY) > 100000;
6

Вопрос №4
Карандаш положили вплотную к стене или в комнату с карандашом
не возможно попасть, поэтому и перепрыгнуть через карандаш не
возможно.
7",
107,4523524525.pdf,.pdf,pdf,"1 Задание
Изменить тип атрибута login на числовой, а название на login_id, к
примеру, чтобы эта была ссылка на другую таблицу. Т.к. информация в нем не
относится к информации о клиенте и он может быть ключевым атрибутом,
хотя у нас уже определен client_id и при сохранении данной структуры, как
мне кажется, может получиться ситуация, при которой есть 2 разных ключа в
таблице.
Заменить тип и название у поля age на хранение даты и birthday(пример),
соответственно, т.к. изменение возраста клиентов повлечет необходимость
постепенной перезаписи всего столбца.
Опционально: Добавить столбец gender типа Boolean, например, для
более простого отличения клиентов по полу, а не проверки женских или
мужских имен отдельно, например.
2 Задание
Для выполнения поставленной задачи модификации данной таблицы
добавить столбец типа DATE для хранения временной метки, тогда первичный
ключ необходимо было бы сделать составным из даты и идентификатора
товара, но могут быть сложности, если в таблице уже есть данные.
Изменить тип атрибута item_name на числовой и поменять название на
item_name_id, к примеру, чтобы вынести описание в отдельную таблицу,
сохранив на нее ссылку. Если этого не сделать, то возможна ситуация, при
которой в разные моменты времени у одного и того же товара разное описание.
3 Задание
Неправильная работа с NULL, чтобы проверить, нужно использовать IS.
Нельзя использовать агрегирующие функции в WHERE, перенести
SUM(SALARY) > 100000 в HAVING.
Неполная группировка: в GROUP BY также должен быть столбец
DEPARTMENT_ID, или необходимо убрать DEPARTMENT_ID из SELECT/
Необязательное исправление: явно назначить алиасы и исключить
неявное объединение в WHERE, перенеся в JOIN.

4 Задание
Главное препятствие для этого то, что карандаш может лежать у стены.
Так как не указано в какой именно комнате уронили карандаш, то при
необычных обстоятельствах перепрыгиванию через карандаш также может
помешать:
1. наклон пола (карандаш точно находится у стены);
2. размеры карандаша или комнаты (вы можете не поместиться в
комнате или карандаш может быть больше вас);
3. среда (наличие воды и других веществ, плотность которых выше
плотности карандаша, но меньше вашей, из-за чего он всплывает, а вы нет).",
108,452354245.txt,.txt,text,"1.

client_id тип данных можно заменить на serial или guid
Возможно, стоит добавить поле email с типом данных varchar(255)
В целом набор и смысл полей считаю корректным.

2.

Думаю, что стоит создать таблицу для хранения исторических данных
Таблицу с информацией о товаре оставить в следующем виде:

items (
item_id serial(или guid), --уникальный id товара
item_name varchar(255), --наименование товар
);

items_costs (
items_costs_id serial(guid) -- уникальный id записи о цене в определенный промежуток времени
item_id number(integer) -- FK идентификатор товара
item_cost number(integer) -- стоимость товара
fisrt_date date -- дата начала действия стоимости
end_date date -- дата окончания действия стоимости
);

При проектировании стоит учитывать уникальность сочетания id товара и даты начала действия цены

3.

SELECT DEPARTMENT_ID, DEPARTMENT_NAME
JOIN EMPLOYEE E
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_ID, DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;",
109,4524240.docx,.docx,docx,"Поле city_id. Стоит создать другую таблицу city с названиями городов и id каждого города. В таблице clients поле city_id связать с таблицей city.
Поле age. Стоит при регистрации добавлять дату рождения, а не возраст, т.к. возраст будет меняться, а дата рождения – нет.
Стоило бы создать вторую таблицу prices. Со следующим наполнением:
prices (
prices_id number, -- уникальный id цены конкретного товара
item_id number, -- уникальный id товара (из таблицы items)
cost number, -- цена товара
date_beg date, -- дата, с которой актуальна опред. цена на опред. товар
date_end date -- дата, с которой цена неактуальна
);
А в таблицу items оставить только 2 поля (item_id, item_name). Благодаря созданной таблице prices мы бы смогли обеспечить историческое хранение стоимости товара, было бы удобнее отслеживать изменения цен и составлять отчеты за разный период.
Желтым подчеркнуты места, где считаю, что допущены ошибки.
Зеленым – места, где было что-то добавлено/изменено.
В случае, если карандаш в углу или у самой стены, мы бы не смогли через него перепрыгнуть.
Еще стоит учесть, что в условии не указано, что мы в той же комнате, где уронили карандаш. Если мы находимся в другой комнате, то тоже не сможем через него перепрыгнуть.
Старый запрос | Новый запрос
SELECT 
DEPARTMENT_ID, 
DEPARTMENT_NAME, 
SUM(SALARY) TOTAL_SALARY 
FROM EMPLOYEE E, DEPARTMENTS D 
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID 
AND MANAGER_ID = NULL 
AND LOCATION_ID = (SELECT LOCATION_ID 
 FROM LOCATIONS 
 WHERE CITY = 'SEOUL') 
AND SUM(SALARY) >= 100000 
GROUP BY DEPARTMENT_NAME | SELECT 
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM 
 EMPLOYEES E
JOIN 
 DEPARTMENTS D USING(DEPARTMENT_ID) 
WHERE 
 E.MANAGER_ID IS NULL
 AND D.LOCATION_ID = (
 SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL'
 )
GROUP BY 
 D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING 
 SUM(E.SALARY) > 100000;",
110,45245220.pdf,.pdf,pdf,"1.
Корректно:
- client_id — уникальный идентификатор.
- login — логин, уникальный.
- reg_date — дата регистрации, полезна для аналитики и сегментации клиентов.
- city_id — если это внешний ключ на таблицу cities, то это правильно.
Изменить:
- Разделение имени и фамилии. Иногда клиенты имеют вторые имена или двойные фамилии.
- Поле age. Возраст как число — это ошибка проектирования, потому что он изменяется со
временем. Лучше хранить дату рождения — birth_date, возраст можно рассчитать при
необходимости.
- Добавить поля для контактной информации email и phone_number
- Если города только внутри одной страны, то ничего менять не обязательно. Но иначе нужно поле
country.
2.
Вынести информацию о стоимости в отдельную таблицу, где каждая запись будет соответствовать
определённому периоду действия цены. Пусть будет таблица item_prices - история изменения
цен. При добавлении нового товара — создаётся запись в items и первая запись в item_price с
текущей ценой. При изменении цены у старой цены устанавливается end_date = дата
изменения - 1 день. Добавляется новая строка с новой ценой и start_date = дата
изменения, end_date = NULL.
item_prices (
price_id NUMBER PRIMARY KEY,
item_id NUMBER NOT NULL,
item_cost NUMBER NOT NULL,
start_date DATE NOT NULL,
end_date DATE, -- NULL означает, что цена актуальна
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
3.
1. Ошибка с NULL в MANAGER_ID = NULL. Надо использовать IS NULL.
2. Агрегатные функции не могут использоваться в WHERE SUM(SALARY) >= 100000, их нужно
использовать в HAVING.
3. В SELECT есть DEPARTMENT_ID, то его тоже надо внести в GROUP BY.
4.
Карандаш у стены и мы не кузнечики).",
111,4525245.txt,.txt,text,"Задание 1.

clients (
client_id number, --уникальный id клиента-- НЕ ПРОПИСАНО ОГРАНИЧЕНИЕ НА СОЗДАНИЕ ДУБЛИРУЮЩИХ ЗАПИСЕЙ. НЕ ЯСНО, КАКИМ ОБРАЗОМ СОЗДАЕТСЯ client_id. 
 Я БЫ ПОМЕНЯЛА NUMBER на SERIAL И ДОБАВИЛА PRIMARY KEY
client_name varchar(255), --имя клиента -- ДОБАВИЛА БЫ NOT NULL. УМЕНЬШИЛА БЫ КОЛИЧЕСТВО СИМВОЛОВ ДО 30
client_surname varchar(255), --фамилия клиента-- ДОБАВИЛА БЫ NOT NULL. УМЕНЬШИЛА БЫ КОЛИЧЕСТВО СИМВОЛОВ ДО 30 
login varchar(30), --логин, который придумал клиент -- ДОБАВИЛА БЫ NOT NULL. ПРОПИСАЛА БЫ ОГРАНИЧЕНИЯ НА СОЗДАНИЕ ДУБЛЕЙ ЧЕРЕЗ UNIQUE.
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id) -- В БД МОЖЕТ ОТСУТСТВОВАТЬ НАЗВАНИЕ ГОРОДА, В КОТОРОМ ЖИВЕТ КЛИЕНТ. НЕОБХОДИМО ПРЕДУСМОТРЕТЬ ВОЗМОЖНОСТЬ РУЧНОГО ВВОДА,
 ЕСЛИ НАЗВАНИЕ НАСЕЛЕННОГО ПУНКТА ОТСУТСТВУЕТ В ПРЕДЛОЖЕННЫХ ВАРИАНТАХ. 
age number, --возраст клиента -- ВОЗРАСТ СО ВРЕМЕНЕМ МОЖЕТ МЕНЯТЬСЯ, ДАТА РОЖДЕНИЯ БЫЛА БЫ АКТУАЛЬНЕЕ.
reg_date date –дата регистрации на сайте
);

Задание 2.

items ( 
item_id number, --уникальный id товара -- НЕ ПРОПИСАНО ОГРАНИЧЕНИЕ НА СОЗДАНИЕ ДУБЛИРУЮЩИХ ЗАПИСЕЙ. НЕ ЯСНО, КАКИМ ОБРАЗОМ СОЗДАЕТСЯ item_id. 
 Я БЫ ПОМЕНЯЛА NUMBER на SERIAL И ДОБАВИЛА PRIMARY KEY
item_name varchar(255), --наименование товара
item_cost number –стоимость товара -- Я БЫ ДОБАВИЛА:1. КОЛОНКУ С ЦЕНОЙ ЗАКУПКИ ТОВАРА С НДС;
 2. КОЛОНКУ СО СТОИМОСТЬЮ ТОВАРА БЕЗ НДС;
 3. КОЛОНКУ С ЦЕНОЙ ЗАКУПКИ ТОВАРА БЕЗ НДС; -- ОТДЕЛЬНЫЕ КОЛОНКИ БЕЗ НДС ТРЕБУЮТСЯ, Т.К. В РОССИИ СТАВКА НДС НЕ ТОЛЬКО 20 %.
 4. НЕОБХОДИМА ОТДЕЛЬНАЯ ТАБЛИЦА, В КОТОРОЙ БУДУТ УКАЗАНЫ item_id, СТОИМОСТЬ ТОВАРА С НДС И БЕЗ НДС,
 ДАТА ДО КОТОРОЙ ЭТА СТОИМОСТЬ ДЕЙСТВОВАЛА. ЕСЛИ ЦЕНА АКТУАЛЬНА, ТО КОЛОНКА С ДАТОЙ NULL. ПРИ ИЗМЕНЕНИИ СТОИМОСТИ, СОЗДАЕТСЯ НОВАЯ СТРОКА
 С item_id, НОВОЙ СТОИМОСТЬЮ, А В ПРЕДЫДУЩЕЙ СТРОКЕ УКАЗЫВАЕТСЯ ДАТА ИЗМЕНЕНИЯ ЦЕНЫ. ПРИМЕР НИЖЕ:
 
 item_id | стоимость товара | ДАТА
 -------------------------------------
 123 | 1536 | 2024/06/28
 123 | 1608 | 2024/07/15
 123 | 1695 | null
);

Задание 3.

SELECT D.DEPARTMENT_NAME
 
FROM EMPLOYEES E,
 RIGHT JOIN DEPARTMENTS D
 ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
 AND D.LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
 
GROUP BY D.DEPARTMENT_NAME
HAVING SUM(SALARY) > 100000
ORDER BY D.DEPARTMENT_NAME

Задание 4.

В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?

КОМНАТА ЗАКРЫТА НА КЛЮЧ И Я НЕ МОГУ В НЕЕ ВОЙТИ.",
112,45254245.docx,.docx,docx,"Задача 1:
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date --дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему мнению некорректно и какие изменения внесли бы.
Ответ 1:
Рекомендации по улучшению :
1. Поле login (логин):
- Поле login не уникально. В реальных системах логин должен быть уникален, чтобы предотвратить дублирование. Следует добавить ограничение UNIQUE на поле login.
2. Поле client_name и client_surname (имя и фамилия клиента):
- Важно учитывать, что не все клиенты могут иметь фамилию, или же могут использовать одно слово вместо имени и фамилии. Это поле можно заменить на одно поле full_name.
- Вместо varchar(255), можно сократить длину до разумной, например, varchar(100).
3. Поле age (возраст):
- Возраст является динамическим, поэтому лучше хранить дату рождения (birth_date), чтобы в дальнейшем рассчитывать возраст клиента на момент необходимости.
4. Поле city_id (город):
- Поле city_id должно ссылаться на таблицу городов, чтобы предотвратить ошибки при вводе данных.
5. Можно добавить внешние ключи для ссылок на другие таблицы (например, таблица с городами).
Изменённая схема таблицы:
clients (
client_id number PRIMARY KEY,
full_name varchar(100),
login varchar(30) UNIQUE,
city_id number REFERENCES cities(city_id),
birth_date date,
reg_date date
);
Добавляем таблицу Cities:
cities (
city_id number, -- уникальный id города
city_name varchar(255) -- название города
);
Задача 2:
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она илиможно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number --стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различные отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранениестоимости товара?
Ответ 2:
Для выполнения поставленных задач необходимо внести следующие изменения:
Для ведения отчетности:
Для отслеживания изменений стоимости товара, необходимо хранить историю цен. Это можно сделать с помощью создания новой таблицы для цен товаров. В этой таблице будет указана дата начала действия цены и, возможно, дата её окончания.
Изменённая архитектура:
Из таблицы items уберем поле с ценой - «item_cost number --стоимость товара»:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
);
Добавляем новую таблицу item_prices:
item_prices (
price_id number PRIMARY KEY,
item_id number REFERENCES items(item_id),
item_cost number,
start_date date, -- Дата начала действия цены
end_date date -- Дата окончания действия цены (может быть NULL для актуальной цены)
);
Задача 3:
Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS
WHERE CITY = 'SEOUL') AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Ответ 3:
Исправление SQL-запроса
Основные ошибки:
MANAGER_ID = NULL — здесь нужно использовать IS NULL.
SUM(SALARY) >= 100000 не может быть использован в WHERE, так как это агрегатная функция. Вместо этого нужно применить фильтр в HAVING.
Использование старого синтаксиса соединений таблиц через запятую — лучше использовать JOIN.
Исправленный запрос:
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
Задача 4:
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Ответ 4:
Для ответа на данный вопрос требуется больше данных. Однако, основываясь только на предоставленной информации можно предложить несколько вариантов:
Я не нахожусь в комнате где уронили на пол карандаш.
Карандаш был поднят сразу после падения.
Комната слишком большая или разделенная какими-либо перегородками в результате чего, я не видел как он упал. Либо карандаш скрыт и я его не вижу (к примеру, он находится в тени).
Комната слишком низкая и прыгать в ней невозможно.
Карандаш находится слишком близко к стене или другому препятствию и у меня нет возможности преодолеть это препятствие.
У меня нет физической возможности или навыков и я не могу прыгать.
Эти 6 вариантов охватывают лишь часть возможных объяснений, и, конечно, можно предположить ещё множество как реалистичных, так и гипотетических сценариев. Однако дать окончательный ответ невозможно, поскольку ситуация может включать самые разные факторы, начиная от физических ограничений и заканчивая особенностями восприятия или контекста.",
113,452545445.txt,.txt,text,"1. Схема clients

clients (
 client_id number, --уникальный id клиента
 client_name varchar(255), --имя клиента 
 client_surname varchar(255), --фамилия клиента
 email varchar(255), -- уникальный эмейл в качестве логина
 city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
 birth_date, -- дата рождения вместо возраста
 reg_date date, –-дата регистрации на сайте
 deleted bool, -- удален ли данный пользователь
);

2. Схема items

items (
item_id number, --уникальный id товара
item_name varchar(255) --наименование товара
);

- добавить отдельную таблицу для цены

items_cost(
cost_id number, -- уникальный id цены
item_id number, -- внешний ключ к items
item_cost number, –- стоимость товара
start_date date, -- дата с назначением новой цены (для актуальных цен по настоящее время)
end_date date, -- дата с окончанием действия цены
);

3. SQL

SELECT 
 E.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(SALARY) as TOTAL_SALARY
FROM 
 EMPLOYEE E, DEPARTMENTS D
WHERE
 E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND E.MANAGER_ID IS NULL -- is null
 AND LOCATION_ID = (
 SELECT 
 LOCATION_ID
 FROM 
 LOCATIONS 
 WHERE 
 CITY = 'SEOUL')
GROUP BY 
 E.DEPARTMENT_ID, D.DEPARTMENT_NAME -- группировка по выбранным полям
HAVING 
 TOTAL_SALARY >= 100000 -- фильтруем после группировки

4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через 
него перепрыгнуть?

- Карандаш упал вплотную к стене;
- Потолки очень низкие;
- Карандаш огромный.",
114,452727.pdf,.pdf,pdf,"1 задание
1. Вместо возраста клиента, нужно хранить дату его рождения, чтобы не обновлять
возраст каждый год.
2. У логина должно быть ограничение уникальности или можно использовать email вместо
него.
3. По хорошему сделать дополнительну таблицу с логированем.
4. Добавить первичный ключ на client_id и индексы на часто используемые поля.
5. Если планируются доставки, то лучше создать отдельную таблицу с адресами.
2 задание
Оставить исходную таблицу почти без изменений, а цены вынести в отедльную таблицу.
Структура новой таблицы:
CREATE TABLE item_prices (
price_id SERIAL PRIMARY KEY
,item_id INT NOT NULL REFERENCES items(item_id)
,price NUMERIC(10, 2) NOT NULL
,valid_from DATE NOT NULL
,valid_to DATE
UNIQUE (item_id, valid_from)
);
3 задание
1. Вместо MANAGER_ID = NULL нужно MANAGER_ID IS NULL
2. В where нельзя использовать sum()
3. DEPARTMENT_ID нужно добавить в group by
4. Отсутствует join в from
5. Это условие не должно быть в where: E.DEPARTMENT_ID = D.DEPARTMENT_ID
6. Отсутствие join с таблицей location
Исправленный запрос:
SELECT
d.DEPARTMENT_ID
,d.DEPARTMENT_NAME
,SUM(e.SALARY) AS total_salary
FROM
employees e
JOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN locations l ON d.LOCATION_ID = l.LOCATION_ID
WHERE
e.MANAGER_ID IS NULL
AND l.CITY = 'SEOUL'
GROUP BY
d.DEPARTMENT_ID
,d.DEPARTMENT_NAME
HAVING
SUM(e.SALARY) > 100000

4 задание
Потому что я инвалид-колясочник",
115,453.docx,.docx,docx,"Никитин Дмитрий
1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему мнению некорректно и какие изменения внесли бы.
Ответ:
Сначала нужно добавить первичный и внешние ключи. Далее добавлю автоинкремент к первичному ключу и NOT NULL, чтобы поля были обязательными.
Также сокращу размер имени и фамилии, так как фамилий и имён больше 100 символов абсолютное меньшинство.
Для поля login добавлено ключевое слово UNIQUE, которое ограничивает внесение в столбец неуникальных значений. Также увеличена длина для логина.
Далее столбец city_id был переименован в address_id, потому что логичнее было бы хранить данные не о городе, а сразу об адресе доставки, чтобы товар можно было доставить. При этом, условно, при регистрации пользователь сначала выбирает свой город, и он записывается в таблицу addresses в поле city, а далее он может при заказе дозаполнить свой адрес, а в таблице addresses хранить адреса отдельно от пользователей через внешний ключ.
Поле age изменено на date_of_birth, чтобы не следить за ежегодным изменением возраста для каждого клиента.
При этом дата регистрации и дата рождения не может превышать сегодняшнюю дату, поэтому добавлена проверка на это.
Также добавлен внешний ключ, ведущий к таблице addresses.
Наглядный пример решения:
clients(
client_id NUMBER PRIMARY KEY AUTOINCREMENT NOT NULL,
client_name VARCHAR(100) NOT NULL,
client_surname VARCHAR (100) NOT NULL,
login VARCHAR(50) UNIQUE NOT NULL,
address_id NUMBER NOT NULL,
date_of_birth DATE NOT NULL CHECK (date_of_birth <= CURRENT_DATE),
reg_date DATE NOT NULL CHECK (reg_date <= CURRENT_DATE),
phone_number NUMBER NOT NULL,
FOREIGN KEY (address_id) REFERENCES addresses (address_id)
);
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу, вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
Ответ:
Для этого нужно создать отдельную таблицу с ценами, поэтому в таблице items удаляется поле item_cost.
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
);
Далее создана таблица с ценами item_prices. У каждой цены теперь есть время действия, оно указано в полях start_date и end_date. При этом конечная дата может быть null, что означает, что цена бессрочная. За составной первичный ключ взято id товара и дата начала действия цены, так как это является уникальной комбинацией. Внешний ключ item_id отсылает к таблице items. Также для избегания установки сразу двух цен на 1 период можно создать триггеры.
CREATE TABLE item_prices (
item_id NUMBER, -- id товара
price NUMBER NOT NULL, -- цена товара
start_date DATE NOT NULL, -- дата начала действия цены
end_date DATE, -- дата окончания действия цены
PRIMARY KEY (item_id, start_date), -- первичный ключ
FOREIGN KEY (item_id) REFERENCES items(item_id) -- внешний ключ
);
Триггер для правильного использования базы данных при вставке.
DELIMITER //
CREATE TRIGGER before_insert_item_prices
BEFORE INSERT ON item_prices
FOR EACH ROW
BEGIN
IF EXISTS (
SELECT 1
FROM item_prices
WHERE item_id = NEW.item_id
AND (
(NEW.start_date BETWEEN start_date AND COALESCE(end_date, CURRENT_DATE))
OR (NEW.end_date BETWEEN start_date AND COALESCE(end_date, CURRENT_DATE))
OR (start_date BETWEEN NEW.start_date AND COALESCE(NEW.end_date, CURRENT_DATE))
OR (COALESCE(end_date, CURRENT_DATE) BETWEEN NEW.start_date AND COALESCE(NEW.end_date, CURRENT_DATE))
)
) THEN
SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Price range overlaps with existing range';
END IF;
END//
DELIMITER ;
Триггер для правильного использования при обновлении данных.
DELIMITER //
CREATE TRIGGER before_update_item_prices
BEFORE UPDATE ON item_prices
FOR EACH ROW
BEGIN
IF EXISTS (
SELECT 1
FROM item_prices
WHERE item_id = NEW.item_id
AND (item_id != OLD.item_id OR start_date != OLD.start_date) -- чтобы не сравнивать саму запись с собой
AND (
(NEW.start_date BETWEEN start_date AND COALESCE(end_date, CURRENT_DATE))
OR (NEW.end_date BETWEEN start_date AND COALESCE(end_date, CURRENT_DATE))
OR (start_date BETWEEN NEW.start_date AND COALESCE(NEW.end_date, CURRENT_DATE))
OR (COALESCE(end_date, CURRENT_DATE) BETWEEN NEW.start_date AND COALESCE(NEW.end_date, CURRENT_DATE))
)
) THEN
SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Updated price range overlaps with existing range';
END IF;
END//
DELIMITER ;
Для обеспечения целостности данных и предотвращения ситуаций, при которых для одного и того же товара устанавливаются несколько перекрывающихся по времени цен, были реализованы два триггера: BEFORE INSERT и BEFORE UPDATE на таблицу item_prices. Триггер BEFORE INSERT проверяет, существует ли уже в таблице запись с тем же item_id, у которой период действия цены пересекается с периодом новой вставляемой цены. При наличии конфликта выбрасывается исключение, и операция вставки блокируется. Аналогичная логика реализована в триггере BEFORE UPDATE, который дополнительно исключает из проверки саму обновляемую запись, чтобы избежать ложноположительных срабатываний при изменении полей. Такая реализация гарантирует, что в каждый момент времени для одного товара может действовать только одна цена, что особенно важно для корректного построения финансовой отчётности и анализа исторических данных.
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Ответ:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) >= 100000;
Данный запрос использует INNER JOIN для объединения таблиц EMPLOYEES, DEPARTMENTS и LOCATIONS по соответствующим внешним ключам. В фильтрующем условии WHERE отбираются только те сотрудники, у которых отсутствует менеджер (MANAGER_ID IS NULL), и только те отделы, которые находятся в городе Сеул. После группировки по каждому отделу осуществляется проверка через HAVING, что суммарная зарплата таких сотрудников превышает 100000.
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Ответ:
Морально нецелесообразно прыгать через карандаш, так как он маленький, перепрыгнуть невозможно по собственному желанию, так как такая идея не приходит в голову.
Комната заперта, в неё невозможно войти, а карандаш уронили до того, как заперли комнату, и все вышли из неё.
Карандаш закатился под шкаф.
Я наступил на карандаш, и он приклеился к подошве.
Начался потоп, комнату затопило по шею, карандаш всплыл.",
116,45345345.pdf,.pdf,pdf,"Вайцуль Александр
Задание 1.
Считаю, что поле age не содержит ценной информации. Возраст является
динамическим параметром и может изменяться, тогда как значение в базе
данных остаётся неизменным. Поэтому более корректно хранить дату
рождения клиента в поле birth_date.
В текущей структуре отсутствуют поля для связи с клиентом. Необходимо
добавить: email – для авторизации и коммуникации; phone – для SMS-
уведомлений и дополнительной идентификации
Можно добавить поле is_subscribed типа BOOLEAN для учёта согласия
клиента на получение рассылки.
Отсутствует обязательное поле password_hash для безопасного хранения
хэшированного пароля пользователя.
Поле city_id в данной таблице не имеет практического смысла. Информация о
местоположении должна храниться в таблице заказов, поскольку: Адрес
клиента может изменяться Эти данные не требуются для входа в личный
кабинет Такой подход исключит хранение избыточной информации.
Очевидно, что для данной таблице также необходимы ограничения на поля, но
это замечание относится уже к физической реализации, а не логического
проектирования
Примерный вид таблицы clients
CREATE TABLE clients (
client_id SERIAL PRIMARY KEY,
first_name VARCHAR(100) NOT NULL,
last_name VARCHAR(100) NOT NULL,
birth_date DATE,
email VARCHAR(255) UNIQUE NOT NULL,
phone VARCHAR(20) UNIQUE,
password_hash VARCHAR(255) NOT NULL,
is_subscribed BOOLEAN DEFAULT TRUE);

Задание 2.
Предлагаю нормализовать структуру данных, разделив таблицу items на две
связанные таблицы:
1) items - будет содержать основную информацию о товарах (item_id,
item_name)
2) items_price_history - будет хранить историю изменения цен с указанием:
price_date - дата изменения цены item_cost - актуальная цена на указанную
дату
CREATE TABLE items (
item_id NUMBER PRIMARY KEY,
item_name VARCHAR(255) NOT NULL
);
-- Таблица истории цен
CREATE TABLE item_prices_history (
item_id NUMBER REFERENCES items(item_id),
price_date DATE, -- дата цены
item_cost NUMBER NOT NULL, -- Цена в этом месяце
PRIMARY KEY (item_id, price_date)
);
Задание 3.
Исправленный запрос
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID =
D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;

Ошибки:
1) Проверка на NULL. Изменил на IS NULL
2) Условия на агрегатные функции должны быть HAVING, а не в WHERE.
Неравенство строгое. Следует из условия
3) Соединение таблиц через JOIN
4) В GROUP BY добавлен DEPARTAMENT_ID, так как он есть в SELECT
Задание 4.
Потому что его положили рядом со стеной (вплотную).",
117,45352378.txt,.txt,text,"1. Поле ""login"" (логин, который придумал клиент) не является корректным и необходимым, так как полей для идентификации пользователей достаточно, поле ""reg_date"" (дата регистрации на сайте) так же не несет в себе важную и необходимую информации о клиенте. Так же я бы добавил поля с полом и телефоном/почтой клиента.

2. Я бы добавил поле - внешний ключ на другую таблицу, где бы хранилась информация о всех ценах, которые были ранее присвоены данному товару.

3. SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;

MANAGER_ID = NULL - для проверки на NULL используется оператор IS NULL.
Условие SUM(SALARY) >= 100000 должно быть в HAVING, так как SUM - агрегатная функция.
GROUP BY должен содержать все столбцы, не агрегируемые в SELECT, поэтому добавляем DEPARTMENT_ID в GROUP BY.
После FROM также следует использовать явный JOIN для лучшей читаемости.

4. Через карандаш нельзя перепрыгнуть так он находиться в другой комнате, либо лежит на полу около стены, оба варианты не позволяют перепрыгнуть через карандаш.",
118,453543.pdf,.pdf,pdf,"1.
В целях обеспечения целостности данных, более точного хранения
информации о клиентах и возможности дальнейшего расширения функционала я бы
реализовал следующие изменения:
1. Поле client_id является первичным ключом и автоматически увеличивается
(например, с помощью AUTO_INCREMENT), чтобы избежать дубликатов.
2. В полях client_name и client_surname стоит добавить ограничение на
минимальную и максимальную длину, а также использовать более строгую
валидацию для предотвращения ввода недопустимых символов (например,
цифр или специальных символов).
3. Поле login должно быть уникальным, чтобы предотвратить регистрацию
нескольких пользователей с одним и тем же логином. Также стоит рассмотреть
возможность хранения логина в нижнем регистре для унификации.
4. Рекомендуется создать отдельную таблицу для городов (например, cities) с
полями city_id и city_name. Это позволит поддерживать связь между
таблицами и улучшит целостность данных.
5. Поле age может быть проблематичным, так как возраст может меняться. Лучше
хранить дату рождения (например, birth_date), что позволит всегда точно
вычислять возраст. Также следует добавить валидацию для проверки, что
возраст клиента соответствует реальности (например, от 0 до 120 лет).
6. Необходимо убедиться, что поле reg_date автоматически устанавливается на
текущую дату при создании записи, что можно сделать с помощью триггеров
или по умолчанию.
7. Возможно имеется смысл в добавления дополнительных полей, таких как
email (с уникальным ограничением) для связи и восстановления пароля, а
также phone_number для дополнительных контактов.
Обновленная схема таблицы:
CREATE TABLE clients (
client_id NUMBER PRIMARY KEY AUTO_INCREMENT,
client_name VARCHAR(255) NOT NULL,
client_surname VARCHAR(255) NOT NULL,
login VARCHAR(30) UNIQUE NOT NULL,
city_id NUMBER,
birth_date DATE NOT NULL,
reg_date DATE DEFAULT CURRENT_DATE,
FOREIGN KEY (city_id) REFERENCES cities(city_id)
);

2.
Вместо хранения только текущей цены в таблице items, следует создать
отдельную таблицу для хранения истории цен, что позволит фиксировать каждое
изменение стоимости товара. Такой подход позволит хранить полную историю
изменений цен на товары, облегчит формирование отчетов о доходах за различные
промежутки времени и упростит анализ ценовых трендов и сезонных изменений.
Новая структура таблиц:
Таблица товаров (items)
CREATE TABLE items (
item_id NUMBER PRIMARY KEY, -- уникальный id товара
item_name VARCHAR(255) NOT NULL -- наименование товара
);
Таблица историй цен (item_prices)
CREATE TABLE item_prices (
price_id NUMBER PRIMARY KEY AUTO_INCREMENT, -- уникальный id
записи о цене
item_id NUMBER NOT NULL, -- id товара
item_cost NUMBER NOT NULL, -- стоимость товара
start_date DATE NOT NULL, -- дата начала действия цены
end_date DATE, -- дата окончания действия цены (NULL, если цена
активна)
FOREIGN KEY (item_id) REFERENCES items(item_id) -- связь с
таблицей товаров
);
Таблица items теперь хранит только информацию о товарах, без цен.
В таблице item_prices:
● Каждая запись содержит стоимость товара и период ее действия.
● Поле start_date указывает дату, с которой начинает действовать цена.
● Поле end_date может быть NULL для текущей активной цены или содержать
дату, когда цена перестала действовать.
При изменении цены на товар необходимо будет добавить новую запись в
таблицу item_prices с новой ценой и обновить end_date у предыдущей записи:
-- Обновление предыдущей цены
UPDATE item_prices
SET end_date = CURRENT_DATE
WHERE item_id = :item_id AND end_date IS NULL;

-- Добавление новой цены
INSERT INTO item_prices (item_id, item_cost, start_date)
VALUES (:item_id, :new_cost, CURRENT_DATE);

3.
Вот основные проблемы и их исправления:
1. Для проверки на NULL используется оператор IS NULL, а не = NULL. Это
относится к условию MANAGER_ID.
2. Условие на сумму зарплаты должно быть в секции HAVING, а не в WHERE,
поскольку мы группируем данные и хотим получить агрегированные значения.
3. При группировке по DEPARTMENT_ID также следует включить его в GROUP BY,
чтобы избежать ошибок.
Исправленный запрос:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE
E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE
CITY = 'SEOUL')
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
В вышеприведенном запросе:
1. Использован JOIN вместо старого синтаксиса соединения для улучшения
читаемости.
2. Исправлено условие проверки MANAGER_ID на IS NULL.
3. Условие на сумму зарплаты перемещено в секцию HAVING.
4. Группировка по DEPARTMENT_ID добавлена, чтобы избежать ошибок.

4.
Карандаш лежит на полу, в связи с чем он не представляет собой препятствие.
Из-за чего нет необходимости перепрыгивать через него.",
119,45354345.docx,.docx,docx,"1) Поле `age` хранится как число**. Возраст — это динамическое значение, которое изменяется ежегодно. Хранение возраста напрямую может привести к устареванию данных. Лучше хранить дату рождения (`birth_date`) и вычислять возраст на её основе. Необходимо проверить факт существования таблицы городов, на которую ссылается city_id 2)Необходимо создать таблицу, в которую подгружались бы данные о ценах с датами изменений. 3) SELECT DEPARTMENT_ID, DEPARTMENT_NAME, SUM(SALARY) AS TOTAL_SALARY FROM EMPLOYEES JOIN DEPARTMENTS ON DEPARTMENT_ID = DEPARTMENT_ID JOIN LOCATIONS ON LOCATION_ID = LOCATION_ID WHERE MANAGER_ID IS NULL AND CITY = 'SEOUL' GROUP BY DEPARTMENT_ID, DEPARTMENT_NAME HAVING SUM(SALARY) >= 100000;
4)Необходимо убедиться в наличии комнаты и в наличии карандаша. убедиться, что карандаш в комнате и сравнить параметры карандаша с возможностью его перепрыгнуть. При заданных условиях я не могу перешагнуть по причине того, что карандаш в комнате, к которой я не могу подойти.",
120,45354522.xlsx,.xlsx,excel,"=== SHEET: Лист1 ===
items | items_price
ID товара | item_id* | PK | number | ID товара | item_id* | PK (FK) | number
Наименование товара | item_name | varchar (255) | Дата изменения цены | change_date* | PK | timestamp
Цена товара | item_cost | number
=== SHEET: Лист2 ===
Город | city | Покупатель | clients | Пользователь | user
ID города | city_id | number | ID покупателя | client_id | number | ID пользователя | user_id | number
Наименование города | city_name | varchar (255) | Имя покупателя | client_name | varchar (255) | Логин | login | varchar (30)
Фамилия покупателя | client_surname | varchar (255) | Пароль | password
ID города | city_id | number
Дата рождения | birth_date | date
Дата регистрации | reg_date | date
ID пользователя | user_id | number",
121,45378.txt,.txt,text,"1. Подобная таблица будет работать. Но я бы внёс несколько изменений.
 а) Я бы добавил автоинкремент для client_id и сделал бы его PRIMARY KEY
 б) утончнил бы важно ли делить имя на имя и фамилию, если нет, то объединил бы client_name и client_surname в client_name или client_full_name
 в) сделал бы ограничение уникальности для login
 г) убрал бы age с возрастом, вместо него добавил бы birth_date с датой рождения, потому что возраст каждый год меняется. 
 д) еще можно добавить hash_password c хешем пароля, если база данных будет использована для входа в аккаунт клиента

2. Нужно из таблицы items убрать items_cost и сделать еще одну таблицу с ценами:
 prices (
 id number, -- уникальный id изменения цены
 item_id number, -- id товара в таблице items
 item_cost number, -- стоимость товара
 start_date date -- дата начала действия стоимости);
 Таким образом всегда можно посмотреть цену на любую дату.

3. Запрос работать не будет, так как есть ошибки.
 а) отсутствует join при запросе из таблиц employees и departments
 б) проверка на пустое значение IS NULL, а не = NULL
 в) подзапрос может выдать несколько результатов, поэтому нужно использовать IN, а не =
 г) агрегатную функцию SUM нужно использовать с HAVING, а не в WHERE

 Правильный запрос будет такой:

 SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(SALARY)
 FROM EMPLOYEES E
 JOIN DEPARTMENTS D 
 ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 WHERE MANAGER_ID IS NULL
 AND LOCATION_ID IN (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
 GROUP BY DEPARTMENT_NAME
 HAVING SUM(SALARY) >= 100000;

4. Во-первых, возможно, могу. Сначала нужно проверить это.
 Далее, если действительно невозможно, то может быть несколько причин
 а) У меня нет доступа в комнату. Например, она заперта, а у меня нет ключа.
 б) В условиях говорится про то, что карандаш уронили, а не то, что он лежит на полу. Поэтому я не могу перепрыгнуть через карандаш, потому что в данный момент времени он падает на пол, а не уже лежит на нем.
 в) В комнате нет гравитации, соответственно прыжки там невозможны. 
 г) У меня нет информации о местонахождении комнаты.
 д) Комната существует только в условиях задачи, а я нахожусь в реальном мире. Я не могу прыгнуть в метафизическое пространство из реального.",
122,454645.txt,.txt,text,"Задание 1.
Тип number лучше заменить на более конкретный тип int, numeric и тд. TIMESTAMP лучше, чем DATE для reg_date. Для имени и фамилии 255 символов — перебор, обычно 100 хватает. На атрибут логин надо бы добавить ограничение UNIQUE, чтобы не было повторов. age лучше заменить на дату рождения тогда можно динамически вычислить возраст. Также не хватает таких полей, как email, phone, активность пользователя. Ну и city_id нужно привязать к отдельной таблице с городами.

Задание 2.

В этом случае лучше разделить данные на две таблицы. В item_prices будем хранить историю цен с чётко заданными периодами действия, а в items только id и имя. Тогда мы соблюдем принципы нормализации и избежим дублирования.

create table items(
 item_id int primary key,
 item_name varchar(255) not null);

create table item_price_history(
 item_id int not null, 
 cost int not null, 
 valid_from timestamp default now(), 
 valid_to timestamp, 
 foreign key (item_id) references items(item_id));

Задание 3.
1. Неправильно указано название таблицы - вместо EMPLOYEE должно быть employees. 
2. Некорректно выполнена проверка на NULL - использовано = NULL вместо IS NULL. 
3. Агрегатная функция SUM была помещена в блок WHERE, хотя должна быть в HAVING.
4. В GROUP BY отсутствовал department_id, который при этом был в SELECT.
5. Неявное соединение таблиц.

select d.department_id,
 d.department_name,
 sum(e.salary) as total_salary
from departments as d
join locations as l 
on d.location_id = l.location_id
join employees e 
on e.department_id = d.department_id
where l.city = 'SEOUL' and e.manager_id is null
group by d.department_id,
 d.department_name
having sum(e.salary) > 100000;

Задание 4.
Потому что карандаш упал вплотную к стене, и нет места чтобы перепыгнуть его.",
123,45524554.pdf,.pdf,pdf,"Тех задание
1 задание
Добавить ограничения уникальности для поля login, а также ввести валидацию для
полей имени и возраста.
Поле id города корректно, если есть отдельная таблица с городами, где хранится
соответствие city_id и названия города. В противном случае, наличие
только city_id может привести к недопониманию, если пользователь изменит город.
Изменить поле age на birth_date для более точного учета возраста.
2 задание
Создать таблицу для хранения ценовых изменений. Эта таблица будет содержать
информацию о каждой цене товара, включая даты, когда эта цена была установлена или
актуальна.
В таблице items можно вместо цены добавить внешний ключ, чтобы указывать
актуальную цену.
3 задание
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D USING(DEPARTMENT_ID)
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
AND D.LOCATION_ID = (SELECT LOCATION_ID.... Здесь также можно использовать
оператор in .
4 задание

В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?
Потому что я в другой комнате.
Он закатился под стол.
Потому что моя обувь приклеена к полу.
Потому что произошло землетрясение, комната разрушена и карандаш под
обломками.
Потому что у меня сломана нога.
Потому что это технически улучшенных карандаш, и он уничтожается если подойти к
нему на расстояние достаточное для прыжка
Потому что перегнуть нужно на руках.
Потому что он у стены (банальщина)",
124,45542345.docx,.docx,docx,"Тестовое задание
1 задание
В целом таблица имеет основную структуру, но есть некоторые моменты, которые можно было бы улучшить, а именно:
Изменить тип данных с NUMBER на INTEGER для полей client_id, city_id;
Поля client_name и client_surname объединить в одно поле (client_name);
Все значения полей обязательны для заполнения, значит надо добавить тип NOT NULL;
Для названий городов лучше создать отдельную таблицу для хранения информации о городах. С полями (city_id, city_name);
Поле login нужно дополнить ограничениями, например, уникальность UNIQUE, чтобы избежать дублирования логинов;
Вместо хранения данных о возрасте, лучше хранить дату рождения (birth_date DATE);
В поле reg_date необходимо установить автоматическое заполнение текущей датой с помощью оператор DEFAULT вместе с функцией CURRENT_DATE;
Так же можно было бы добавить отдельные поля в таблицу, а именно:
email – для хранения адреса электронной почты (ограничениями уникальности)
phone для хранения телефонного номера
password – для хранения пароля учетной записи
Создание таблицы clients:
CREATE TABLE clients (
client_id INT PRIMARY KEY AUTO_INCREMENT, -- генерируется уникальный номер id клиента и определяем первичный ключ таблицы,
client_name VARCHAR(255) NOT NULL, -- фамилия и имя клиента
email VARCHAR(255) UNIQUE, -- адрес электронной почты с ограничениями уникальности
login VARCHAR(30) UNIQUE, --логин, который придумал клиент с ограничениями уникальности
password VARCHAR(255) NOT NULL, --пароль, который придумал клиент с ограничениями уникальности
city_id INT NOT NULL, -- id города из таблицы cities (создается отдельно)
birth_date DATE NOT NULL, -- дата рождения клиента
phone VARCHAR NOT NULL, -- телефон клиента
reg_date DATE DEFAULT CURRENT_DATE, –дата регистрации на сайте автоматически заполнялся текущей датой;
FOREIGN KEY (city_id) REFERENCES cities (city_id) -- внешний ключ для таблицы citys
);
Создание таблицы cities:
CREATE TABLE cities(
city_id INT PRIMARY KEY,
city_name VARCHAR(255) NOT NULL
);
Модель базы данных
2 задание
Для того чтобы обеспечить историческое хранение стоимости товара в интернет магазине, необходимо доработать архитектуру таблицы
Создадим таблицу items, которая содержит поля с основной информацией о товаре
CREATE TABLE items (
item_id INT PRIMARY KEY AUTO_INCREMENT, --уникальный id товара
item_name VARCHAR(255) --наименование товара
);
Создадим таблицу price_change, которая содержит данные об изменении стоимости товара
CREATE TABLE price_change (
price_id INT PRIMARY KEY AUTOINCREMENT, -- уникальный ID записи о цене
item_id INT NOT NULL, -- id товара из таблицы items
item_price DECIMAL(10, 2) NOT NULL, -- цена товара
start_date DATE NOT NULL, -- дата начала действия новой цены
end_date DATE, -- дата окончания действия цены (если в поле -NULL, значит действует текущая цена)
FOREIGN KEY (item_id) REFERENCES items (item_id) -- внешний ключ для таблицы items
);
Описание архитектуры таблицы price_change:
При каждом изменении цены какого либо товара, создается новая запись в таблице price_change;
В таблице price_change указывается новая цена товара (item_price);
Устанавливается дата начала действия новой цены (start_date) ;
Если на данный момент цена не меняется, то поле end_date остается пустым (NULL);
Если цена изменилась снова, то нужно заполнить поле окончание действия цены (end_date) старой цены и заполнить все необходимые поля новой цены.
Плюсы данной архитектуры:
Все изменения цен товаров сохраняются;
Легко можно вывести текущие цены товаров (через проверку поля end_date на NULL);
С помощью данной архитектуры можно строить различные финансовые отчеты за разные промежутки времени.
3 задание
Вывести все отделы:
расположенные в Сеуле,
всех сотрудников, не имеющие менеджера,
зарабатывают в общей сложности более 100000.
Дана учебная схема HR, содержащая таблицы:
SELECT department_name
FROM locations l INNER JOIN departments d ON l. location_id = d.location_id
INNER JOIN employees e ON d.department_id = e.department_id
WHERE manager_id IS NULL AND city = 'Seoul'
GROUP BY department_name
HAVING SUM(salary) > 100000;
В данном запросе были допущены ошибки:
В условии задания требовалось вывести только отделы (department_name);
Соединение таблиц необходимо осуществлять через INNER JOIN;
В соединение таблиц необходимо добавить третью таблицу locations;
Для проверки на NULL нужно использовать IS NULL;
Не нужно использовать подзапрос для фильтрации по городу 'Seoul', а использовать условие (city = 'Seoul') напрямую в запросе;
Условие для вычисления суммы зарплат SUM(salary) > 100000, нужно использовать после группировки GROUP BY с помощью оператора HAVING;
Оператор >= заменили на >.
4 задание
Причин по которым, я не могу перепрыгнуть через карандаш может быть несколько:
Карандаш закатился в труднодоступное место (например, под диван);
Карандаш упал, совершенно в другом месте, в отличном от моего места прибывания (например, в другом городе, стране, планете и т.д.);
И самая простая причина, по которой я не могу перепрыгнуть, это потому, что я сейчас читаю данное задание и прыгать в этот момент не могу.
clients | clients
PK | client_id
client_name
email
login
password
FK | city_id
birth_date
phone
reg_date
cities | cities
PK | city_id
city_name
locations | locations | locations
PK | location_id
city
employees | employees
PK | employees.id
employees_name
salary
FK | manager_id
FK | department_id
FK | location_id
departments | departments
PK | department_id
department_name
FK | location_id",
125,4727272.txt,.txt,text,"None
 Для обеспечения возможности построения отчётов за разные промежутки времени необходимо дополнить таблицу полем с временем изменений. Если оно заполнено, то это история, если не заполнено, то актуальное состояние. Чтобы не усложнять запросы, создать триггеры на выборку, update/delete, выполняющие операции с этим полем. Настроить партиционирование таблицы, чтобы актуальное и история хранились физически отдельно.
1. Отсутствует Inner/Left Join и On.
3. В условии ""более 100 000"", но в запросе >=(будут включены значения =100 000).
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
4.1 Меня нет в ""некоторой комнате, где уронили карандаш"".
4.3 Карандаш невозможно перепрыгнуть (лежит у стены/под громоздким объектом).
4.4 Карандаш подняли с пола.",
126,52055.docx,.docx,docx,"Тестовое задание Тарасова М.А.
1.Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки. Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите, что по вашему мнению некорректно и какие изменения внесли бы.
Я бы предложил следующий вариант таблицы:
Clients(
Client_id integer NOT NULL,
client_name varchar(50) NOT NULL,
client_surname varchar(50) NOT NULL,
login varchar(30) unique NOT NULL,
city_id integer NOT NUL,
age integer NOT NULL check (age > 0)
reg_date date NOT NULL DEFAULT now()
CONSTRAINT client_pkey PRIMARY KEY (Client_id)
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу, вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете, что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое хранение стоимости товара?
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
start_date_cost date – начало действие цены
end_date_cost date – конец действия цены
);
Таблица будет выглядеть так
id name cost start_date_cost end_date_cost
1 name_1 25 01.01.2025 01.02.2025
1 name_1 55 02.02.2025 01.03.2025
при запросе к БД, цена будет соответствовать дате в конкретный период
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Оптимизируем запрос
SELECT
d.DEPARTMENT_ID,
d.DEPARTMENT_NAME,
SUM(e.SALARY) TOTAL_SALARY
FROM
EMPLOYEES e
JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN LOCATIONS l ON d.LOCATION_ID = l.LOCATION_ID
WHERE
e.MANAGER_ID IS NULL
AND l.CITY = 'SEOUL'
GROUP BY
d.DEPARTMENT_ID,
d.DEPARTMENT_NAME
HAVING
SUM(e.SALARY) > 100000
Добавим явные ссылки на таблицы в select
Вместо from используем join (название таблицы разное в запросе и в условии employeeS)
Вместо вложенных подзапросов будем использовать join
Поиск нулевых значений осуществляется через IS NULL
Так же по условию больше 10000, а не больше либо равно
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
- я нахожусь в другой комнате, поэтому не могу перепрыгнуть через тот карандаш.;
- карандаш закатился под шкаф, а шкаф до потолка, поэтому перепрыгнуть карандаш не представляется возможным;
- при падении карандаш оказался вплотную к стене, поэтому перепрыгнуть через него – значит прыгнуть прямо в стену, что невозможно",
127,522552.pdf,.pdf,pdf,"ТЕСТОВОЕ ЗАДАНИЕ
1 задание
Предложения по улучшению данных полей:
1. client_id:
• Изменить тип данных с NUMBER на INTEGER
• явно объявить PRIMARY KEY
• добавить автоматическую генерацию client_id с помощью -
AUTO_INCREMENT
2. client_name и client_surname:
• объединить в одно поле (client_name)
• Добавить ограничение на длину, например varchar(100)
3. login :
• поле login нужно дополнить ограничениями, например, уникальность
UNIQUE, чтобы избежать дублирования логинов
4. city_id:
• Для названий городов лучше создать отдельную таблицу для
хранения информации о городах. С полями (city_id, city_name, region)
• Изменить тип данных с NUMBER на INTEGER
5. age :
• Вместо хранения данных о возрасте, лучше хранить дату рождения
(birth_date DATE)
• Изменить тип данных с NUMBER на INTEGER
6. reg_date:
• В поле reg_date необходимо установить автоматическое заполнение
текущей датой с помощью оператор DEFAULT вместе с функцией
CURRENT_DATE

7. Все значения полей обязательны для заполнения, значит надо добавить
тип NOT NULL
8. Так же можно было бы добавить отдельные поля в таблицу, а именно:
• email VARCHAR(255) – для хранения адреса электронной почты
(ограничениями уникальности UNIQUE)
• phone VARCHAR(20) для хранения телефонного номера
• password VARCHAR(100) – для хранения пароля учетной записи
Создание таблицы clients:
CREATE TABLE clients (
client_id INT PRIMARY KEY AUTO_INCREMENT, -- генерируется уникальный номер id
клиента и определяем первичный ключ таблицы,
client_name VARCHAR(100) NOT NULL, -- фамилия и имя клиента
email VARCHAR(255) UNIQUE, -- адрес электронной почты с ограничениями уникальности
login VARCHAR(30) UNIQUE, --логин, который придумал клиент с ограничениями
уникальности
password VARCHAR(100) NOT NULL, --пароль, который придумал клиент с ограничениями
уникальности
city_id INT NOT NULL, -- id города из таблицы cities (создается отдельно)
birth_date DATE NOT NULL, -- дата рождения клиента
phone VARCHAR(20) NOT NULL, -- телефон клиента
reg_date DATE DEFAULT CURRENT_DATE, –дата регистрации на сайте автоматически
заполнялся текущей датой;
FOREIGN KEY (city_id) REFERENCES cities (city_id) -- внешний ключ для таблицы citys
);
Создание таблицы cities:
CREATE TABLE cities(
city_id INT PRIMARY KEY,
city_name VARCHAR(100) NOT NULL,
region VARCHAR(100) NOT NULL
);

Модель базы данных
clients cities
PK client_id PK city_id
client_name city_name
email region
login
password
FK city_id
birth_date
phone
reg_date
________________________________________________________

2 задание
Для того чтобы обеспечить историческое хранение стоимости товара в интернет
магазине, необходимо доработать архитектуру таблицы
1. Создадим таблицу items, которая содержит поля с основной информацией о
товаре
CREATE TABLE items (
item_id INT PRIMARY KEY AUTO_INCREMENT, --уникальный id товара
item_name VARCHAR(255) --наименование товара
);
2. Создадим таблицу price_change, которая содержит данные об изменении
стоимости товара
CREATE TABLE price_change (
price_id INT PRIMARY KEY AUTOINCREMENT, -- уникальный ID записи о цене
item_id INT NOT NULL, -- id товара из таблицы items
item_price DECIMAL(10, 2) NOT NULL, -- цена товара
start_date DATE NOT NULL, -- дата начала действия новой цены
end_date DATE, -- дата окончания действия цены (если в поле -NULL, значит действует
текущая цена)
FOREIGN KEY (item_id) REFERENCES items (item_id) -- внешний ключ для таблицы items
);
Описание архитектуры таблицы price_change:
1. При каждом изменении цены какого либо товара, создается новая запись в
таблице price_change;
2. В таблице price_change указывается новая цена товара (item_price);
3. Устанавливается дата начала действия новой цены (start_date) ;
4. Если на данный момент цена не меняется, то поле end_date остается
пустым (NULL);
5. Если цена изменилась снова, то нужно заполнить поле окончание действия
цены (end_date) старой цены и заполнить все необходимые поля новой
цены.

Плюсы данной архитектуры:
• Все изменения цен товаров сохраняются;
• Легко можно вывести текущие цены товаров (через проверку поля
end_date на NULL);
• С помощью данной архитектуры можно строить различные финансовые
отчеты за разные промежутки времени.
________________________________________________________

3 задание
Вывести все отделы:
• расположенные в Сеуле,
• всех сотрудников, не имеющие менеджера,
• зарабатывают в общей сложности более 100000.
Дана учебная схема HR, содержащая таблицы:
employees departments locations
PK employees.id PK department_id PK location_id
employees_name department_name
city
salary FK location_id
FK manager_id
FK department_id
FK location_id
Исправленный запрос:
SELECT department_name
FROM locations l INNER JOIN departments d ON l. location_id = d.location_id
INNER JOIN employees e ON d.department_id = e.department_id
WHERE manager_id IS NULL AND city = 'Seoul'
GROUP BY department_name
HAVING SUM(salary) > 100000;
В данном запросе были допущены ошибки:
1. В условии задания требовалось вывести только отделы (department_name);
2. Соединение таблиц необходимо осуществлять через INNER JOIN;
3. В соединение таблиц необходимо добавить третью таблицу locations;
4. Для проверки на NULL нужно использовать IS NULL;
5. Не нужно использовать подзапрос для фильтрации по городу 'Seoul', а
использовать условие (city = 'Seoul') напрямую в запросе;
6. Условие для вычисления суммы зарплат SUM(salary) > 100000, нужно
использовать после группировки GROUP BY с помощью оператора HAVING;
7. Оператор >= заменили на >.

4 задание
Причин по которым, я не могу перепрыгнуть через карандаш может быть несколько:
1. Карандаш закатился в труднодоступное место (например, под диван);
2. Карандаш упал, совершенно в другом месте, в отличном от моего места
прибывания (например, в другом городе, стране, планете и т.д.);
3. И самая простая причина, по которой я не могу перепрыгнуть, это потому,
что я сейчас читаю данное задание и прыгать в этот момент не могу;
4. Карандаш слишком маленький, чтобы через него прыгать, можно просто
перешагнуть.
Т
______________________________________________________
P.S.
Спасибо за интересное задание. Буду рада обратной связи и возможности
развиваться в направлении Data Engineer.",
128,5237823.txt,.txt,text,"1. предлагаю заменить поле ""возраст"" на ""год рождения"" клиента. чтобы информация обновлялась каждый год. Поле ""client_id"" нужно сделать не просто number, а еще навесить условие первичного ключа на него, для уникальности. для оптимизации лучше еще сделать автоинкремент на это поле. Еще нужно завести поле для хранения пароля пользователя, в хэшированном виде.
2. предлагаю создать отдельную таблицу для хранения коэффициентов, которые можно накладывать на базовую стоимость товаров в зависимости от скидок, праздников и т д. таким образом можно выгрузить нужный отчет за нужный период с текущими на тот момент изменениями цены.
3. в group by Добавить еще department_id. для соединения таблиц лучше использовать join вместо запятой для улучшения производительности на больших данных. JOIN позволяет более очевидно отделить условия объединения таблиц от всего остального. лучше написать manager_id is null вместо = null. Location_id лучше сделать не равным , а ""in"". на случай, если будет несколько значений Сеула. или может быть like (%Сеул%). На случай. если будут вхождения.
4. если карандаш такого размера, что невозможно через него перешагнуть. или если например карандаш закатился под стену.",
129,52387353.docx,.docx,docx,"Я считаю, что эта таблица хороша тем, что город, который клиент выбирает, в самой таблице является числом (id). По моему мнению, лишней частью таблицы являются данные о дате регистрации на сайте. Так же смысл поля возраста мне не ясен, я бы заменила его на дату рождения, при необходимости вообще это учитывать.
Для того, чтобы хранить «историю цен» необходимо создать дополнительную таблицу. В основной таблице вместо точной цены должен быть ключ (id), ведущий ко второй таблице. Новая таблица должна состоять из таких полей как
price_id number, -- id цены (первичный ключ)
item_id number, -- идентификатор товара
item_price number, -- стоимость товара
from_date date, -- дата, с которой установлена такая цена
until_date date, -- дата, когда эта цена потеряла актуальность(NULL если актуальна)
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
Возможно , в комнате слишком низкие потолки, поэтому его нельзя перепрыгнуть. Или карандаш настолько мал, что его невозможно увидеть перед прыжком. Или эта комната с карандашом вне досягаемости.",
130,5252250.pdf,.pdf,pdf,"1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она или можно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему
мнению некорректно и какие изменения внесли бы.
Ответ: да, но можно внести доработки, например добавить ограничения PRIMARY KEY для
client_id и FOREIGN KEY city_id, чтобы в дальнейшем связать с табличкой городов, так же
можно добавить ограничение NOT NULL и UNIQUE для поля login, так же можно изменить
типы данных, например client_name, client_surname и login сделать varchar(100), для age
сделать Int или хранить как birth_date с типы данных date
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно строить различныотчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранениестоимости

товара?
Так как нам надо хранить где-то цены за разные промежутки времени, то необходимо создать
ещё одну таблицу, в которой будем хранить все изменения цен, табличка будет выглядеть так:
\

3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, --EMPLOYEES
E DEPARTMENTS --через JOIN
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID -
AND MANAGER_ID = NULL -- IS вместо =
AND LOCATION_ID = (SELECT LOCATION_ID FROM
LOCATIONS
WHERE CITY = 'SEOUL') AND
SUM(SALARY) >= 100000 -- в HAVING
GROUP BY DEPARTMENT_NAME
Исправленный запрос:
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000
;
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?
Причин можно найти много, например карандаш расположен вплотную к стене или
карандаш закатился под шкаф и т.д.
Но лучше всегда концентрироваться на решении проблемы, а не на причинах
почему я не могу чего-то сделать.",
131,525385453.pdf,.pdf,pdf,"Задание 1.
Концептуально таблица имеет смысл. Информация про клиента
какая-никакая есть. Но мне видится несколько недочетов,
которые я бы исправил.
Начнем по порядку:
1) client_id
Вероятно, мы бы хотели, чтоб заполнения этого поля было
автоинкрементным при регистрации нового пользователя.
Мой опыт изучения sql подсказывает, что такие поля
принято обозначать в стиле client_id int GENERATED
ALWAYS AS IDENTITY NOT NULL. Так как аналогичное
serial не защищает айдишники от ручного вмешательства.
Ну и сделать тип данных int, быстрее работает, меньше
ресурсов тратит, да и зачем нам числа с плавающей точкой.
Также сделаем это поле как PRIMARY KEY
2) client_name varchar(255), client_surname varchar(255)
Тут все окей, но я бы сделал varchar(50) хотя бы, но можно и
до 30. Ну и поля NOT NULL соотв.
3) login
Аналогично NOT NULL, а так все хорошо.
4) city_id
Тоже сделаем int NOT NULL. И скорее всего city_id будет
ссылаться на другую табличку cities в качестве
REFERENCES cities(city_id).
5) age

Зачем нам хранить возраст клиента. Он постоянно меняется.
Лучше запрашивать его дату рождения и по мере
необходимости считать уже его возраст
birth_date date. Поле можно не делать NOT NULL. Так как
не всегда дата рождения является обязательной
информацией.
6) reg_date
Я бы тут ничего не менял.
Задание 2.
Для начала рассмотрим поля в таблице.
Сделаем item_id int GENERATED ALWAYS AS IDENTITY NOT
NULL PRIMARY KEY. (По логике из 1 задания) .
Добавим обязательность заполнения item_name varchar(255) NOT
NULL. Сделаем третье поле current_price deicmal(10,2) NOT
NULL. Можно добавить еще одно поле в котором будет видна
дата создания этого товара, чтобы мы знали, с какого времени мы
можем считать изменение его цен. created_at timestamp NOT
NULL DEFAULT CURRENT_TIMESTAMP.
Для хранения истории цен, будет логично создать отдельную
таблицу которая будет заниматься именно этим.
CREATE TABLE item_price_history (

price_id int GENERATED ALWAYS AS IDENTITY PRIMARY
KEY,
item_id int NOT NULL, price decimal(10, 2) NOT NULL,
change_date timestamp NOT NULL DEFAULT
CURRENT_TIMESTAMP,
CONSTRAINT FK_item_price_history_item FOREIGN KEY
(item_id) REFERENCES items(item_id)
);
Таблица item_price_history связана с первой таблицей по price_id.
Логика такая, что если мы вносим какой-то товар в первую
таблицу, например INSERT INTO items (item_name, current_price)
VALUES ('Товар 1', 100.00);
Затем цена изменилась, внесем изменение UPDATE items SET
current_price = 120.00 WHERE item_id = 1;
И можно, конечно, писать каждый раз INSERT INTO
item_price_history (item_id, price, change_date) VALUES (1, 100.00,
CURRENT_TIMESTAMP); Чтобы вручную сохранять историю
цен, но в идеале, написать какой-нибудь триггер, который сам
будет за нас это делать.

Задание 3
SELECT
DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM( SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND
MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Начнем по порядку.
1) В селекте нужно явно указывать из какой мы таблицы берем
значение, так как DEPARTMENT_ID есть в двух таблицах
сразу! И лучше явно уже укажем для
DEPARTMENT_NAME и SALARY. После SUM(SALARY) я
бы еще добавил AS, визуально приятнее когда явно
указываем псевдоним.
2) Для объединения двух таблиц необходимо пользоваться
ключевым словом JOIN. Так как у нас названия полей по
которым мы связываем одинаковые - мы можем

воспользоваться USING DEPARTMENT_ID вместо ON ,
чтобы упростить синтаксис. Оставим ON.
3) После объединения предлагается сразу профильтровать по
городу и работникам у которых менеджера нет. Проверка на
NULL делается с помощью ключевого слова IS.
4) В нашем селекте мы ищем DEPARTMENT_ID,
DEPARTMENT_NAME. Значит сортировать нужно по двум
сразу.
5) Запрос для проверки зарплаты необходимо делать используя
HAVING так как мы фильтруем результат после
группировки.
Таким образом мой запрос выглядит следующим образом:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM DEPARTMENTS AS D
JOIN EMPLOYEES AS E ON D.DEPARTMENT_ID =
E.DEPARTMENT_ID
WHERE D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND E.MANAGER_ID IS NULL
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME

HAVING SUM(E.SALARY) > =100000;
Задание 4
Для того, чтобы что-то перепрыгнуть, необходимо препятствие,
что-то через что перепрыгивать. Карандаш настолько мелкий
относительно меня объект, что его размером можно пренебречь.
Это как просто воздух под ногами перепрыгивать. Не получится.",
132,527278.txt,.txt,text,"Ответ на первый вопрос:

Недостаёт как минимум двух обязательных полей для регистрации и коммуникации с пользователем - это почтовый ящик и номер телефона. В дальнейшем эти данные можно использовать в коммерческих продвижениях или рекламных рассылках пользователям (в случае их согласия), а также эти данные нужны для верификации пользователя как человека.
Почему города хранятся как id? Почему не хранить значения текстовым значением по аналогии с именем итд. В интерфейсе мы отдаем названия города, а бд храним его id - это нецелесообразно, так как где-то должна лежать промежуточная таблица для матчинга значений, что добавляет лишнее действие при обработке данных.
Возраст хранить лучше как дату рождения, а не как число, так как в таком случае необходим микросервис актуализации возраста пользователей.
Ответ на второй вопрос:

Я бы хранил данные в отдельной таблице с биллингом, где у меня бы хранилось id товара, цена по которой товар приобрели, время покупки и id транзакции, также можно добавить id заказа.

Ответ на третий вопрос:

1. Условие определения связывания таблица пишется после ON, а не в WHERE.

2. В WHERE нельзя использовать агрегатные функции, их следует вынести в HAVING.

3. Условие в WHERE для MANAGER_ID необходимо указывать через 'is'.

4. В GROUP BY необходимо также добавить DEPARTMENT_ID

Ответ на четвертый вопрос:

У меня нет доступа к комнате.
Карандаш лежит возле стены.
Карандаш находится вплотную(или под) возле непреодолимого предмета(например шкаф).",
133,5337383.docx,.docx,docx,"1. Со своей стороны предлагаю следующую структуру таблицы:
clients (
client_id number PRIMARY KEY уникальный id клиента,
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
client_login varchar(30) UNIQUE not null, -- логин, который придумал клиент
city_id number Foreign Key, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date not null Default Current Date, –дата регистрации на сайте
client_email varchar(255), not null
);
Добавлено:
Primary key на поле client_id для уникальности записи по клиенту в целом с автоинкрементом на 1.
Поле client_login сделано уникальным, пользователи должны различаться по логину в том числе.
Внешний ключ для city_id для сохранения целостности данных, очевидно, что если в этой таблице хранится ID города, то должна быть другая таблица с названиями городов, например cities (id, city_name). city_id будет ссылкой на id в таблице cities.
Дата регистрации клиента по-дефолту текущая дата, но не нулевая, полезно в аналитических целях знать, когда клиенты регистрируются.
Не было указано никаких контактных данных, добавлено поле client_email для обратной связи, рассылки рекламных предложений и т.д. При необходимости можно добавить поля с телефоном или логинами в соцсетях.
2. Для хранения стоимости создать отдельную таблицу.
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара);
cost_history (
id number Primary key, -- уникальный id записи
item_id number not null Foreign key references items (item_id), -- внешний ключ на таблицу с названиями товаров.
cost number, -- цена товара
start_date date not null, -- дата начала действия цены
end_date date, -- дата окончания действия цены. Для текущей цены значение null.
);
При добавлении новой записи end_date прошлой цены изменяется с null на время окончания действия цены (день добавления новой записи или предыдущий день перед добавлением новой записи)
3. SELECT
DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID IS NULL
AND LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) > 100000
4. Я не могу перепрыгнуть карандаш в случае, если перед ним препятствие, которое не даст завершить прыжок или карандаш упал под стол, например. В остальных случаях его можно перепрыгнуть.",
134,537523755.txt,.txt,text,"Задание 1.
clients (
client_id number PRIMARY KEY, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30) UNIQUE, --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
birth_date DATE, --дата рождения клиента
reg_date DATE DEFAULT CURRENT_DATE –дата регистрации на сайте
);
По моему мнению данный набор и смысл полей не очень корректен , поэтому я решил внести некоторые изменения :
1. Добавим первичный ключ в поле client_id number для идентификации записей в самой таблице 
2. Вместо возраста клиента лучше указать его дату рождения , чтобы информация о возрасте в дальнейшем обновлялась 
3. В поле reg_date зададим автоматическое значение по умолчанию по текущему времени 
4. Добавим в поле login ограничение UNIQUE дабы предотвратить возможность создания нескольких записей с одинаковым логином 
 Задание 2. items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
;)
По моему мнению архитекрутра данной таблицы некорректна и чтобы обеспечить историческое хранение стоимости товара нужно создать таблицу с ценами 
 Создаем отдельную таблицу item_prices , это позволит нам хранить цену на каждый товар 
item_prices (
price_id PRIMARY KEY
item_id number 
item_cost number
current_date date 
olden_date date 
);
 Задание 3.
SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(SALARY)
FROM EMPLOYEE E,
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID = IS NULL
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_NAME , DEPARTMENT_ID
HAVING SUM(SALARY) => 100000
 Задание 4.Я не могу перепрыгнуть через карандаш потому что он упал у стены",
135,5454254.docx,.docx,docx,"Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
выбирается название города, а в таблицу сохраняется id)
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему мнению некорректно и какие изменения внесли бы.
Ответ на задание:
Я заменил бы
На
Поскольку возраст клиента меняется с каждым годом, а дата рождения останется неизменной.
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
Ответ на задание:
items (
item_id number PRIMARY KEY, --уникальный id товара
item_name varchar(255) NOT NULL, --наименование товара
item_cost number NOT NULL, --текущая стоимость товара
previous_cost number, --предыдущая стоимость товара
cost_change_date date --дата последнего изменения стоимости
);
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Ответ на задание:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'Seoul')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Ответ на задание:
Невозможность перепрыгнуть через карандаш на полу может быть обусловлена множеством причин, например физическим недомоганием, связанным с травмой ноги. Или, возможно, желанием этот карандаш поднять, поскольку кто-то может об него споткнуться и упасть. Также можно предположить что пол, на который уронили карандаш – скользкий и прыжок может привести к падению и травме. Кроме того, карандаш может находиться там, где возможности перепрыгнуть его не будет, например, у стены. Но лично я не могу перепрыгнуть этот конкретный карандаш из-за совокупности всех вышеперечисленных причин.
client_id | number, --уникальный id клиента
client_name | varchar(255), --имя клиента
client_surname | varchar(255), --фамилия клиента
login | varchar(30), --логин, который придумал клиент
city_id | number, --id города, который указал клиент (в интерфейсе
age | number, --возраст клиента
reg_date | date –дата регистрации на сайте
age | number, --возраст клиента
Birth date | date, -- дата рождения клиента",
136,5542245245.docx,.docx,docx,"Смысл полей является корректным, но есть изменения, которые необходимо внести:
client_id должен иметь тип данных integer, т.к. тип данных number представляет собой число c фиксированной запятой, а id должен являться целым числом. Это же касается city_id, который также должен являться целым числом, то есть иметь тип данных integer, т.к. представляет из себя ссылку на первичный ключ другой таблицы;
age должен иметь тип данных integer, т.к. возраст может быть только целым числом;
login представляет собой строку 30 символов длиной, но данного количества символов может быть недостаточно, поэтому следует изменить на 128 символов.
Вместо доработки архитектуры этой таблицы следует создать новую таблицу для хранения истории изменения цены. Новая архитектура представлена на рисунке ниже.
В этом запросе следует исправить:
Вместо неявного соединения, который является устаревшим, следует использовать оператор JOIN;
Условие MANAGER_ID = NULL является неправильным, вместо этого следует использовать IS NULL;
Агрегатная функция SUM не может использоваться в конструкции WHERE;
Измененный запрос представлен ниже:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
L.CITY = 'SEOUL' AND E.MANAGER_ID IS NULL
GROUP BY
D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) >= 100000;
Я не могу перепрыгнуть через карандаш, т.к. он лежит очень близко к стене, соответственно стена является препятствием.",
137,5631241.txt,.txt,text,"1. Для клиентов, прошедших регистрацию в интернет-магазине, в этой таблице очень мало полей.
Нужно добавить поля для email и номера телефона для лучшей идентификации и связи с клиентом, 
а ещё совсем нет полей для пароля (хэш пароля, соль, токен для подтверждения почты и восстановления пароля).
 
Поле client_id number, --уникальный id клиента
Для уникального идентификатора лучше использовать тип данных INT с автоинкрементом.

login varchar(30), --логин, который придумал клиент
Нет ограничения уникальности логина, для упрощения можно вообще его не использовать, а регистрировать пользователь по email.

client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
Длину строки в этих полях можно сократить до varchar(30), некорректное расходование памяти.
Для упрощения можно просто объединить их в одно поле full_name varchar(50).

Поле age number, --возраст клиента 
Изменить на дату рождения birth_date date 
Возраст меняется со временем.

2.Нужно создать отдельную таблицу для хранения изменений цен на товары.
Таблица будет иметь следующую схему:

item_price_history (
 history_id NUMBER PRIMARY KEY, -- уникальный ID записи истории
 item_id NUMBER, -- ID товара
 item_cost NUMBER, -- стоимость товара
 effective_date DATE, -- дата, с которой цена становится актуальной
 FOREIGN KEY (item_id) REFERENCES items(item_id)
);

При изменении цены товара необходимо: 
- добавить новую запись в таблицу item_price_history с новой ценой и текущей датой.
- обновить основную таблицу items.
 
3. Несколько исправлений:

Поля из таблиц следует называть точно.

Условие SUM(SALARY) >= 100000 нужно переместить в HAVING.

Добавить столбец DEPARTMENT_ID в GROUP BY. 

Условие MANAGER_ID = NULL должно быть заменено на MANAGER_ID IS NULL.

Лучше использовать явное соединение с помощью JOIN

исправленный запрос:

SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
 AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;

4. Задача отсылает к возможным ограничениям:

- нет доступа к комнате в которой уронили карандаш

- карандаш упал на пол возле стены и нет места для прыжка

- в этой комнате сейчас нельзя прыгать 

- я не могу прыгать

Также есть другие взгляды на задачу: 
Карандаш лежит на полу, он на одном уровне с полом и прыгать через него это избыточное действие; 
Мы чего-то не знаем об этом карандаше, может он только называется карандашом, а сам является обьектом который не перепрыгнуть.",
138,57373753.txt,.txt,text,"Я бы изменил тип данных client_name и client_surname на VARCHAR(64). login на login(32) и сделал бы поел уникальным. Вместо age, сделал бы birthday. Таким образом возраст из года в год всегда оставался бы актуальным.
Я бы создал таблицу цен, в которой будут храниться не только текущие цены товаров, но и исторические данные о ценах.
IS NULL вместо = NULL, Агрегатная функция SUM(SALARY) должна быть использована в HAVING, а не в WHERE. В WHERE нельзя использовать агрегатные функции, так как они выполняются после группировки. Таким образом, условие AND SUM(SALARY) >= 100000 следует перенести в HAVING. Для правильной группировки данных, нужно включить поле DEPARTMENT_ID в GROUP BY, потому что в запросе выбираются и другие поля, а не только агрегированное поле DEPARTMENT_NAME.",
139,57434345.docx,.docx,docx,"Ответы на “DE.pdf”
Не полностью корректным.

client_name и client_surname можно объединить в одно поле. А если стоит задача радикальной экономии дискового пространства - можно сделать отдельную таблицу со всеми именами и фамилиями, и заменить поля client_name и client_surname на client_name_id и client_surname_id (расчет на то, что имена и фамилии будут повторятся). Впрочем, если стоит задача минимизации количества запросов к бд - лучше не создавать лишние таблицы. 

Было бы неплохо добавить поля email и phone, чтобы можно было присылать рекламу, промоакции и электронные чеки. Также можно сделать ""login"" email'ом, ведь из логина практически никакой полезной информации ""вытащить"" нельзя.

Age можно сделать bool'ом (исполнилось ли клиенту 18 или нет – полезно для интернет-магазинов напитков). Еще есть вариант заменить возраст на дату рождения, чтобы не изменять это поле каждый год.
Логичным выглядит вариант создания новой таблицы:
item_prices ( 
price_id number, - id цены (primary key)
 item_id number – id товара (связан с таблицей items),
 price number - цена,
 start_date date – дата установки цены,
 end_date date – дата изменения цены,
Опечатка в названии таблицы (должно быть “EMPLOYEES”) [зеленым]
Для проверки на null нужно использовать “IS NULL”. [красный]
Указать таблицу, из которой берем столбцы в “WHERE” [синий]
“SUM” – агрегатная функция, нельзя использовать в “WHERE”. Вместо этого - “HAVING” после “GROUP BY”.
В “GROUP BY” нужно включить неагрегированный department_id
Пропущен AS в “SUM(SALARY) TOTAL_SALARY”
Исправленный запрос:
SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(SALARY) AS TOTAL_SALARY

 FROM EMPLOYEE E, DEPARTMENTS D

 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND E.MANAGER_ID IS NULL 
 AND LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')

 GROUP BY D.DEPARTMENT_NAME, D.DEPARTMENT_ID

HAVING SUM(SALARY) >= 100000
Потому что ""него"" относится и к карандашу (мужской род) и к полу (тоже мужской род). Не знаю, через что прыгать - некорректные входные данные в функцию прыжка.

./task4.go:5: too many arguments in call to JumpOver",
140,63366.docx,.docx,docx," 
В таблицу можно внести несколько улучшений: вместо age - будем запрашивать дату рождения, например, birth_date date - тогда возраст будет рассчитывать автоматически. Колонку login нужно сделать UNIQUE, потому что логин должен быть уникальным для каждого клиента. Колонка city_id требует внешней таблицы, и нужно использовать FOREIGN KEY. Можно добавить колонку с нформацией о статусе клиента: удален/активен - is_active.
 Эту таблицу нужно разделить на две таблицы: Товары (ID, название) и История цен. Почему так: таблица Товары будет содержать уникальную информацию о товаре, которая редко меняется, а таблицу История цен - будет хранить историю изменения цен, которя часто обновляется. Например, item_price ( price_id number PRIMARY KEY,  item_id number, priice number, valid_from date, valid_to date, FOREIGN KEY (item_id) REFERENCES items (item_id))
 Исправленый код: SELECT D.DEPARTMENT_ID,
       D.DEPARTMENT_NAME,
       SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
  AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
 Я бы могла списать ответ, что карандаш лежит плотно у стены, поэтому не могу перепрыгнуть. Но, я хочу написать, как я размышляла. Что это за ""некоторая комната""? Если у комнаты нет названия, значит это абстрактная комната, которая находится где-то в воображении, т.е. этой комнаты не существует. А я, как человек, существую, я реальна. Раз комнаты нет, значит и карандаша тоже нет, поэтому и перешагнуть через него я не могу.",
141,6396369.docx,.docx,docx,"Задание 1.
client id: добавить ограничение первичного ключа с автозаполнением - serial primary key (для автогенерации первичного ключа при вставке новых данных)
login: изменить максимально допустимое количество символов - тип varchar(255), также добавить ограничение unique and not null (количество символов 30 мало для наименования логина, и сам логин обязателен при регистрации и должен быть уникален для персонализации пользователя)
client_name: добавить ограничение not null
city_id: можно удалить из таблицы, лучше добавить адрес заказа в таблицу с деталями заказа, в данную таблицу вместо этого добавить поля email varchar(255) и teleph_number varchar(50). Можно также одно из этих полей сделать обязательным, то есть добавить ограничение not null, чтобы с клиентом можно было связаться.
age: заменить на поле birth_date date (так как поле с возрастом будет устаревать и давать не актуальную информацию), добавить ограничение not null (чтобы интернет магазин мог поздравить с днем рождения и не мог продать товары, не соответствующие возрасту)
reg_date: по умолчанию установить текущую дату default current_date.
Задание 2.
Для исторического хранения стоимости товара нужно добавить 2 столбца date_begin и date_end, в которых будет указана дата начала действия цены и дата ее окончания. Но тогда у нас возникнет проблема неуникальности строк по id товара, так как одному товару с одним id будут соответствовать несколько строк. Эту проблему можно решить составным первичным ключом, который будет включать в себя два поля - id и дату начала действия цены.
Задание 3.
SELECT DEPARTMENT_ID, -- это поле указывать необязательно, исходя из условия задачи.
    DEPARTMENT_NAME,   
    SUM(SALARY) TOTAL_SALARY    -- это поле указывать не нужно, так как в постановке задачи требуется вывести только департаменты
FROM EMPLOYEE E,  -- cross join с условием where будет работать медленнее, чем inner join. Нужно заменить на inner join.
    DEPARTMENTS D 
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID  
   AND MANAGER_ID = NULL 
   AND LOCATION_ID = (SELECT LOCATION_ID 
                                       FROM LOCATIONS  
                                       WHERE CITY = 'SEOUL') 
    AND SUM(SALARY) >= 100000 -- это условие нужно указать после having, после сортировки. Условие должно быть строгим по условию задачи.
GROUP BY DEPARTMENT_NAME -- в сортировке должны быть перечислены все не агрегированные поля, указанные в select.
Таким образом, корректный запрос будет выглядеть так:
SELECT
    DEPARTMENT_NAME
FROM EMPLOYEE E
    INNER JOIN DEPARTMENTS D 
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID  
WHERE MANAGER_ID = NULL 
    AND LOCATION_ID = (SELECT LOCATION_ID 
                                       FROM LOCATIONS  
                                       WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_NAME
HAVING SUM(SALARY) > 100000
Задание 4.
Вариант 1.
Если я нахожусь в другой комнате:
Не могу определить на слух, в какой другой комнате упал карандаш.
Не могу выйти из комнаты, потому что дверь закрыта.
Если знаю, в какой комнате упал карандаш, не могу туда зайти, потому что там, например, закрыта дверь и нет ключа.
Вообще нахожусь в другом доме (помещении) и не знаю, в каком доме находится комната с карандашом.
Вариант 2.
Если я нахожусь в этой комнате:
Выключен свет, и я не вижу, где карандаш.
Карандаш упал и укатился в угол, где нет физической возможности его перепрыгнуть.
Не могу ходить.
Карандаш больше меня.",
142,6786.pdf,.pdf,pdf,"1. Представьте, что вы устроились работать Дата-инженером в
некоторый интернет магазин. До вас в этой компании уже
работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно
уволился. Ваша задача провести проверку существующей
архитектуры и решить корректна ли она или можно внести
некоторые доработки. Вы обратили внимание на таблицу с
информацией о зарегистрировавшихся покупателях
(клиентах). Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в
интерфейсе выбирается название города, а в таблицу
сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте );
Считаете ли вы данный набор и смысл полей корректным?
Если нет, то напишите что по вашему мнению некорректно и
какие изменения внесли бы
Мой вариант
CREATE TABLE clients (
Id INT NOT NULL client_id number PRIMERY KEY,
first_client_name varchar(255) NOT NULL,

client_surname varchar(255) NOT NULL,
login varchar(30) NOT NULL,
city_id number,
age number,
reg_date date
FOREIGN KEY cities);
CREATE TABLE cities (
city_id number PRIMARY KEY,
city_name VARCHAR(255) NOT NULL );
Возможно нужно создать отдельно таблицу с городом и его id.
Изначально был вариант как показан ниже, но меня смутило
что «id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)», то
есть в одной таблице будет его id, а в другой хранится его
соответствующее название и id. Еще мне кажется что не
хватает информации, допустим клиенту не всегда будет
удобно оповещение по номеру, можно было бы его
дублировать и на электронную почту.

2. Представьте, что вы устроились работать Дата-
инженером в некоторый интернет магазин. До вас в этой
компании уже работал один разработчик, который придумал
небольшую базу данных для этого магазина и потом
неожиданно уволился. Ваша задача провести проверку
существующей архитектуры и решить корректна ли она или
можно внести некоторые доработки. Вы обратили внимание
на таблицу с информацией о товарах магазина. Таблица имеет
следующую схему:
items ( ); item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
Глядя на эту таблицу вы вспоминаете, что мы живём в
рыночной экономике и цена, если не каждый день, то каждый
месяц может меняться. К примеру, сезонные повышения цен
или наоборот скидки (перед началом учебного года или
новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно
строить различные отчёты (о доходах например) за разные
промежутки времени, в том числе и за прошлые месяцы и
даже прошлые года. Как бы вы доработали архитектуру
таблицы, что бы обеспечить историческое хранение
стоимости товара
Мой вариант
Отсутствует

3. Требуется проверить запрос на корректность и
исправить там ошибки, если они есть. Существует учебная
схема HR, содержащая таблицы: employees, departments и
locations Необходимо получить все отделы, расположенные в
Сеуле в которых все сотрудники, не имеющие менеджера,
зарабатывают в общей сложности более 100000. Для решения
задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Мой вариант
Отсутствует

4. В некоторой комнате на пол уронили карандаш.
Объясните почему вы не можете через него перепрыгнуть
Мой вариант
Вот здесь у меня много вариантов, допустим
1. Неизвестно какая именно комната, может она
многоуровневая (для наглядности представим театр,
мы на балконе, а карандаш упал на пол в партере, а
вход закрыт), уронили с высоты, а чтобы перепрыгнуть
мы физически не можем попасть на уровень ниже
2. Возможно у нас нога в гипсе, с такой ногой не
попрыгаешь
3. При падении закатился (за шкаф, холодильник)
4. Что если он упал буквально под ноги, нет места для
прыжка, только если делать шаг назад
5. Карандаш лежит у плинтуса, если и прыгать то
прямиком в стену
6. Есть еще какие-то внешние факторы, которые не
позволили карандашу остаться лежать на полу, ну та
же собака подбежала и утащила",
143,724424.txt,.txt,text,"1. Анализ таблицы clients

Некорректности и доработки:

Название поля number: Ошибка в описании — поле client_id должно быть числовым (INTEGER), а не number. Вероятно, опечатка.

Поле age: Возраст лучше заменить на birth_date (DATE), так как возраст устаревает и требует постоянного обновления.

Ограничения:

Отсутствие NOT NULL для обязательных полей (client_name, client_surname, login, reg_date).

Логин должен быть уникальным (UNIQUE).

city_id требует внешнего ключа на таблицу городов.

Логин varchar(30): Риск ограничения длины. Рекомендуется увеличить до 50-100 символов.

Тип данных reg_date: Для точности можно использовать TIMESTAMP вместо DATE, если важно время регистрации.
CREATE TABLE clients (
 client_id INTEGER PRIMARY KEY,
 client_name VARCHAR(255) NOT NULL,
 client_surname VARCHAR(255) NOT NULL,
 login VARCHAR(100) NOT NULL UNIQUE,
 city_id INTEGER REFERENCES cities(city_id),
 birth_date DATE NOT NULL,
 reg_date TIMESTAMP NOT NULL
);

2. Доработка таблицы items для хранения истории цен

Решение:
Создать таблицу item_prices для отслеживания изменений стоимости:

CREATE TABLE item_prices (
 item_id INTEGER REFERENCES items(item_id),
 price NUMBER NOT NULL,
 start_date DATE NOT NULL,
 end_date DATE,
 PRIMARY KEY (item_id, start_date)
);
Применение: При изменении цены добавлять новую запись с start_date и закрывать предыдущую, обновляя её end_date.

Преимущества: Позволяет строить отчеты на любую дату, анализировать динамику цен.

3. Исправленный SQL-запрос

Ошибки в исходном запросе:

EMPLOYEE → EMPLOYEES.

MANAGER_ID = NULL → MANAGER_ID IS NULL.

Условие SUM(SALARY) >= 100000 перенесено в HAVING.

Добавлена явная группировка по DEPARTMENT_ID.

Исправлен подзапрос для LOCATION_ID через JOIN.
SELECT 
 D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM 
 EMPLOYEES E
 JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE 
 E.MANAGER_ID IS NULL
 AND L.CITY = 'Seoul'
GROUP BY 
 D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING 
 SUM(E.SALARY) >= 100000;

4. Почему нельзя перепрыгнуть через карандаш?

Ответ:
Карандаш лежит на полу, его толщина пренебрежимо мала. Чтобы перепрыгнуть, нужно преодолеть его высоту, но так как она близка к нулю, физический прыжок не требуется — достаточно переступить. Формально задача может иметь логический подвох: в двумерном пространстве (например, на рисунке) ""перепрыгнуть"" невозможно из-за отсутствия третьего измерения.",
144,7252410.docx,.docx,docx,"1) Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему мнению некорректно и какие изменения внесли бы.
ОТВЕТ:
Вместо age лучше записывать дату рождения, так как age – number устаревает, также стоит уменьшить длину строки у имени и фамилии и оставить вместо 255, например, 50.
Можно еще добавить номер телефона и email клиентов.
clients (
client_id number, --уникальный id клиента
client_name varchar(50), --имя клиента
client_surname varchar(50), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
birth_date date, --дата рождения клиента
email varchar(50), --почта клиента
phone varchar(20), --номер телефона клиента
reg_date date –дата регистрации на сайте
);
2) Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года. Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
ОТВЕТ:
Так как стоимость товара непостоянна, имеет смысл сделать отдельную таблицу с ценой и отдельную с товарами
items (
item_id number, --уникальный id товара
item_name varchar(255) --наименование товара
);
item_prices(
price_id number, --уникальный id цены
item_id number, --ссылка на товар
item_cost number, –стоимость товара
start_date date, --дата, с которой действовала цена
end_date date --дата окончания действия цены (если NULL, то действующая цена)
);
3) Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
ОТВЕТ:
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D USING(DEPARTMENT_ID)
JOIN LOCATIONS L ON D.LOCATION_ID = L. LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L. CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
4) В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
ОТВЕТ:
Потому что карандаш упал в угол комнаты или вдоль стены.
Потому что карандаш закатился под шкаф/стол.
Потому что мы находимся в другой комнате, а не в той, где уронили карандаш.
Потому что потолки слишком низкие и мы никак не можем прыгнуть в этой комнате.",
145,7275753.docx,.docx,docx,"Ответ на задание 1:

Считаю, что для улучшения структуры БД, более строгой проверки данных и упрощения работы с данными клиентов нужно внести следующие изменения:

CREATE TABLE clients (
 client_id SERIAL PRIMARY KEY, -- Уникальный id клиента, первичный ключ
 client_name VARCHAR(255) NOT NULL, -- Имя клиента, не может быть пустым
 client_surname VARCHAR(255) NOT NULL, -- Фамилия клиента, не может быть пустым
 login VARCHAR(30) UNIQUE NOT NULL, -- Логин, уникальный и не может быть пустым
 city_id INTEGER REFERENCES cities(city_id), -- Ссылка на таблицу городов
 age INTEGER CHECK (age > 0 AND age < 120), -- Возраст клиента, целое положительное число
 reg_date DATE NOT NULL, -- Дата регистрации на сайте, не может быть пустой

Возможно, стоит добавить поле для хранения электронной почты клиента, что часто требуется для связи и подтверждения аккаунта:

 email VARCHAR(255) UNIQUE NOT NULL -- Электронная почта клиента, уникальная и не может быть пустой

Ответ на задание 2:

Чтобы сохранить историю изменения цен на товары и упростить составление финансовых отчетов за различные периоды можно добавить новую таблицу, в которую будет заноситься каждое изменение цены продукта, включая дату и новую стоимость. Также в новую таблицу можно добавить текстовое поле для указания причины изменения цены, например, ""Сезонное повышение"", ""Скидка на Новый год"" и т.д.

CREATE TABLE items (
 item_id SERIAL PRIMARY KEY, -- Уникальный id товара
 item_name VARCHAR(255) NOT NULL, -- Наименование товара
 item_cost NUMERIC NOT NULL -- Текущая стоимость товара
);

CREATE TABLE item_price_history (
 history_id SERIAL PRIMARY KEY, -- Уникальный идентификатор записи в журнале
 item_id INTEGER REFERENCES items(item_id), -- Ссылка на товар
 item_cost NUMERIC NOT NULL, -- Новая стоимость товара
 change_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, -- Дата и время изменения цены
 change_reason VARCHAR(255) -- Причина изменения цены
);

Ответ на задание 3:

В предоставленном запросе есть несколько ошибок и недочетов, которые необходимо исправить:

1) В SQL нельзя использовать = для проверки на NULL, вместо этого нужно использовать IS NULL.
2) Нельзя использовать агрегатные функции в условии WHERE, вместо этого нужно использовать HAVING
3) Отсутствие таблицы locations в FROM
4) В GROUP BY также нужно включить DEPARTMENT_ID, так как оно выбрано в SELECT

Запрос с внесенными корректировками:

SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E,
 DEPARTMENTS D,
 LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.LOCATION_ID = L.LOCATION_ID
AND E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;

Также для улучшения читаемости запроса предпочтительней использовать соединение таблиц при помощи JOIN:

SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;

Ответ на задание 4:

Перепрыгнуть через карандаш, упавший на пол, может быть невыполнимой задачей по ряду причин:

1) Прыжок может быть технически невозможен из-за ограничивающих факторов комнаты (Недостаточная высота для прыжка, препятствие в виде стены или предметов интерьера, хрупкий пол)
2) Такое действие не имеет смысла и не несет в себе явной практической пользы или удовольствия
3) Есть более приоритетные задачи и нет времени на это действие
4) Нежелание нарушать порядок в комнате, если это может вызвать шум или привлечь внимание
5) Непрактичность этого действия, особенно если есть более простые способы решения задачи, например просто обойти карандаш или поднять его",
146,735573753.docx,.docx,docx,"В текущей структуре нет ограничений на уникальность логина, из-за этого могут возникнуть проблемы. Также нет проверки на обязательность заполнения полей (client_name, client_surname, login и reg_date должны быть обязательными, чтобы избежать неполных данных). Поле city_id не связано внешним ключом с таблицей городов, из-за чего могут возникнуть некорректные ссылки. Отсутствуют индексы для ускорения поиска по часто используемым полям, таким как login и client_id. Ещё отсутствует проверка возраста (например чтобы вводились разумные числа вроде 1-120)
Создам отдельную таблицу для хранения истории цен. В ней будут:
ID товара.
Цена товара.
Дата начала действия цены.
Дата окончания действия цены (если цена устарела).
Неправильная проверка на NULL. Надо было написать MANAGER_ID IS NULL. SUM(SALARY) нельзя использовать в WHERE, ее можно только в HAVING. В SELECT есть DEPARTMENT_ID, но в GROUP BY его нет. Опечатка в названии таблицы EMPLOYEE(S)
Через карандаш нельзя перепрыгнуть, потому что он закатился под стол :)",
147,737378.txt,.txt,text,"1. Добавление еще нескольких таблиц:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
client_dr date, -–дата рождения клиента
sex_id number, --id пола ( в интерфейсе выбирается пол, а в таблицу сохраняется id)
phone varchar(50) -- телефон клиента
);
--Адрес
address (
Address_id number, -- уникальный id адреса
country_id- number, -- id страны (в интерфейсе выбирается название страны, а в таблицу сохраняется id)
subject_id - number, -- id региона (в интерфейсе выбирается название субъекта, а в таблицу сохраняется id)
district_id - number, -- id района(в интерфейсе выбирается название района. а в таблицу сохраняется id)
city_id - number, -- id города(в интерфейсе выбирается название субъекта, а в таблицу сохраняется id)
locality_id - number, -- id населенного пункта(в интерфейсе выбирается название населенного пункта, а в таблицу сохраняется id)
street_id - number, -- id населенного пункта(в интерфейсе выбирается улицы, а в таблицу сохраняется id)
house- varchar(50),-- дом
apartment - varchar(50),-- квартира
address_address - varchar(512)--сформированный адрес
);

--Адресса клиентов(клиент может указать несколько адресов)
clientaddress (
clientaddress_id number, уникальный id 
client_id number, -id клиента
Address_id number --id адреса,который указал клиент 
);
--Данные о регистрации
registration (
registration_id number, уникальный id 
login varchar(30), --логин, который придумал клиент 
password varchar(30), --пароль, который придумал клиент 
client_id number, -id клиента
email varchar(255), -- email клиента
reg_date date –дата регистрации на сайте
);

2. --Товар
 items (item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
);
--Производитель
firm (
firm_id number, --уникальный id 
firm_name varchar(512),--наименование фирмы
firm_ogrn varchar(50), --ОГРН фирмы
firm_inn varchar(50) --ИНН фирмы
);
--Стоимось товара
cost(
price_id number, --уникальный id 
firm_mid number, --id фирмы, котороя произвела товар
firm_pid number, --id фирмы, котороя поставила товар
cost_price numeric, -- цена закупки
percent_id number, -- id процента наценки(в интерфейсе выбирается процент наценки, а в таблицу сохраняется id)
cost_cost numeric, --стоимость товара
cost_date date –дата поставки
);

3.
SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME
FROM EMPLOYEE E,
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID = NULL
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_ID,DEPARTMENT_NAME
HAVING SUM(SALARY) >= 100000 

4. Карандаш упал и лежит у стены или угла",
148,7422772.txt,.txt,text,"﻿Solution 4

Ответ без раздумий:
Потому что карандаш это портал в другое измерение из игры Half-Life, а у меня нет ломика, чтобы разобраться со всеми обитателя потустороннего мира.

Ответ с физическими ограничениями:
Комната находится на техническом этаже где высота потолков позволяет перемещение только ползком, поэтому прыжок в комнате невозможен.

Ответ с философским флером:
Перепрыгивать через карандаш это бессмысленное действие, а я не могу себе позволить бессмысленных действий.

Реалистичный:
Карандаш упал в самый угол комнаты и при прыжке я буду биться о стену или стены и не смогу его перепрыгнуть.",
149,7424558.pdf,.pdf,pdf,"1.ДляPostgreSQL:
client_id SERIALPRIMARYKEY, --автоинкрементныйуникальныйID
четырёхбайтноецелоесавтоувеличением
таккакпервичныйключвтаблицеКлиенты
client_name VARCHAR(100)NOTNULL, --имяклиента
символьнаястрокапеременнойдлины,неноль
client_surname VARCHAR(100)NOTNULL, --фамилияклиента
символьнаястрокапеременнойдлины,неноль
login VARCHAR(30)UNIQUENOTNULL,--уникальныйлогин
символьнаястрокапеременнойдлины,
неноль,проверканауникальность
city_id INTEGERREFERENCEScities(city_id),--внешнийключ
знаковоечетырёхбайтноецелоеint
age SMALLINTCHECK(ageBETWEEN0AND100),--возрастспроверкой
знаковоедвухбайтноецелоеint2
reg_date TIMESTAMPTZDEFAULTCURRENT_TIMESTAMP--датаивремясучётом
часовогопояса,
поумолчаниютекущиедатаивремя
2.Какбывыдоработалиархитектурутаблицы,чтобыобеспечитьисторическоехранениестоимости
товара?
Разделениеинформацииотовареиисторииизмененияценыпутемсозданиядополнительной
таблицыitem_price_history.
Втаблицеitemсинформациейотоварепервичнымключомсделаюitem_id,типданныхSERIAL
будетавтоинкрементомувеличиватьзначение.Названиенедолжнобытьпустымдляудобства
использования,поэтому NOTNULL.Информацияоценебудетпоказыватьсяактуальнаянатекущий
момент,поэтомустроканазываетсяcurrent_cost
item_idSERIALPRIMARYKEY,
item_nameVARCHAR(255)NOTNULL,
current_costNUMERIC(10,2)
Втаблицеitem_price_historyследующиестроки
price_idSERIALPRIMARYKEY,
item_idINTEGERNOTNULLREFERENCESitems(item_id),
priceNUMERIC(10,2)NOTNULL,
valid_fromTIMESTAMPTZNOTNULLDEFAULTCURRENT_TIMESTAMP,
valid_toTIMESTAMPTZ,
change_reasonVARCHAR(100), --причинаизменения(переоценка,акцияит.д.)
CONSTRAINTvalid_periodCHECK(valid_toISNULLORvalid_from<valid_to)
Связьтаблицitemи item_price_historyчерезitem_id.
Важнымиполямиявляются valid_fromи valid_to—этопериоддействияцены,засчеткоторых
можноотслеживатьисториюизменениявпоследующем.Вполе change_reasonприэтомхранится
информацияопричинахпереоценки.

Приизменениицены:устанавливаемзначениедляvalid_toисоздаёмновуюзаписьсновым
значениемцены
3.
SELECTD.DEPARTMENT_ID,D.DEPARTMENT_NAME,SUM(E.SALARY)ASTOTAL_SALARY
FROMEMPLOYEESE
JOINDEPARTMENTSDONE.DEPARTMENT_ID=D.DEPARTMENT_ID
JOINLOCATIONSLOND.LOCATION_ID=L.LOCATION_ID
WHEREE.MANAGER_IDISNULLANDL.CITY='Seoul'
GROUPBYD.DEPARTMENT_ID,D.DEPARTMENT_NAME
HAVINGSUM(E.SALARY)>100000;
4.Внекоторойкомнатенаполурониликарандаш.Объяснитепочемувынеможетечерезнего
перепрыгнуть?
-карандашупалвплотнуюкстене,нетместадлятого,чтобыпоставитьстопупослепрыжка
-вкомнатетемно,яневижукудаурониликарандаш
-карандашуронилиподстол,тамнетместаввысоту,чтобыпрыгнуть
-янеумеюпрыгать
-яфизическинеспособнапрыгать
-янахожусьвдругомместеот«некоторойкомнаты»,гденаполурониликарандащ
-внекоторойкомнатевсевремяроняюткарандаши,весьполужеимизавален,янезнаючерезкакой
прыгать
-послетого,каккарандашуронили,нанегопоставилидиван,ятакдалекоивысоконепрыгаю",
150,74272724.docx,.docx,docx,"Задание №1. Ответ:
Вместо столбца `age` стоит сделать столбец `birthday` типа datetime с указанием даты рождения, т.к. возраст клиента `age` в изначальной БД не будет увеличиваться из года в год, поэтому через несколько лет мы не сможем узнать точный возраст клиента, потому что он всегда был статичным.
`city_id` может использоваться, если в БД есть информация, какой город соответствует id (таблица). Иначе требуется создать такую таблицу, содержащую id и названия городов.
Задание №2. Ответ:
Для обеспечения исторического хранения стоимости товара, следует добавить 2 столбца - `start_cost_change` типа datetime и `end_cost_change` типа datetime.
`start_cost_change` будет отображать дату, когда изменилась цена, а `end_cost_change` будет отображать дату, до которой эта цена была актуальна для товара. Таким образом, будет несколько записей и появится необходимость сделать primary key для записей в таблицах.
Задание №3. Ответ:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) TOTAL_SALARY
FROM EMPLOYEE E JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL AND E.LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000
В запросе не было JOIN, не было обращений к столбцам через alias, проверка WHERE E.MANAGER_ID = NULL была неверна, для проверки на нулевое значение нужно использовать выражение IS. Нас интересуют сотрудники, зарабатывавшие более 100000, выражение >= 100000 было неверно а также должно было быть после группировки через HAVING. Выражение E.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL') неверно, т.к. результатов подзапросов может быть несколько, должно использоваться с IN.
Задание №4. Ответ:
Я не могу через него перепрыгнуть вероятно, потому что вовсе не нахожусь в этой «некоторой» комнате. Также, из возможных причин может быть то, что комната закрыта или она слишком мала, чтобы я в нее пролез и перепрыгнул через карандаш. Также, возможно, что карандаш в этой комнате может быть довольно больших размеров (размеры карандаша ведь не уточняются), чтобы я через него перепрыгнул.",
151,752272.docx,.docx,docx,"ТЕСТОВОЕ ЗАДАНИЕ
Задание 1
1) Я бы использовал client_id как ключ с автоинкрементом для минимизации дублирования.
2) Также я бы указал, что city_id является внешним ключом для сопоставления ID и города.
3) Хранение возраста в таблице не является хорошей практикой. Лучше использовать дату рождения (birth_date), чтобы уменьшить количество изменений.
4) Также можно было бы использовать поле full_name вместо двух колонок, но это зависит от задачи и от того, какие запросы преобладают к таблице.

Мой вариант запроса для создания таблицы:
CREATE TABLE clients (
 client_id SERIAL PRIMARY KEY,
 full_name varchar(255) NOT NULL,
 login varchar(50) UNIQUE NOT NULL,
 city_id number REFERENCES cities(city_id),
 birth_date DATE,
 reg_date DATE NOT NULL
);
Задание 2
Я бы создал ещё одну таблицу, где хранил бы уникальные данные.

1 таблица:
CREATE TABLE items (
 item_id SERIAL PRIMARY KEY,
 item_name varchar(255) NOT NULL,
 current_cost number NOT NULL
);
2 таблица:
CREATE TABLE item_prices (
 price_id SERIAL PRIMARY KEY, -- уникальный id записи
 item_id number REFERENCES items(item_id), -- id товара
 price number NOT NULL, -- стоимость товара
 start_date DATE NOT NULL, -- дата начала действия цены
 end_date DATE -- дата окончания действия цены
);
Задание 3
1) manager_id = NULL — необходимо использовать IS NULL для проверки.
2) Использование SUM(SALARY) — если мы хотим выполнить условие после группировки с агрегирующей функцией, необходимо использовать HAVING.
3) Неправильная группировка. Правильно будет выполнить группировку так: GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME.

Мой вариант запроса:
SELECT 
 D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM 
 EMPLOYEES E
JOIN 
 DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE 
 E.MANAGER_ID IS NULL
 AND D.LOCATION_ID = (
 SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL'
 )
GROUP BY 
 D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING 
 SUM(E.SALARY) >= 100000;
Задание 4
Я бы не смог перепрыгнуть карандаш из-за стены, около которой он находится.",
152,753737.docx,.docx,docx,"Изменить тип поля age с числового на date и хранить в нём дату рождения, а не текущий возраст.
Добавлю поддержку историчности данных для этой сущности.
Для этого можно применить медленно изменяющиеся измерения SCD 2го типа.
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID IS NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE upper(CITY) = 'SEOUL')
GROUP BY DEPARTMENT_NAME, DEPARTMENT_ID
HAVING SUM(SALARY) >= 100000
Карандаш лежит у самой стены.
Комната заперта.",
153,75375375.docx,.docx,docx,"1.
1.1. Отсутствие первичного ключа (PRIMARY KEY)
Поле client_id объявлено как number, но не указано, что оно является первичным ключом. Добавить ограничение PRIMARY KEY для гарантии уникальности и ускорения поиска. Внести изменение: client_id number PRIMARY KEY
1.2. Нет ограничений на уникальность логина (login)
Логин (login) должен быть уникальным, но в схеме нет ограничения UNIQUE. Добавить UNIQUE, чтобы избежать дубликатов. Добавить NOT NULL, так как логин — обязательное поле. Внести изменение: login varchar(30) UNIQUE NOT NULL
1.3. Отсутствие связи с таблицей городов (city_id)
city_id ссылается на другую таблицу (города), но нет FOREIGN KEY. Нет проверки на NULL (клиент может не указать город). Добавить внешний ключ (FOREIGN KEY) для целостности данных.
city_id number REFERENCES cities(city_id) ON DELETE SET NULL
1.4. Поле age без проверок
Возраст может быть отрицательным или нереалистичным (например, 200 лет). Лучше хранить дату рождения (birth_date), а не возраст. Заменить age на birth_date и добавить проверку (CHECK). Возраст можно вычислять на уровне приложения или SQL-запроса.
birth_date date CHECK (birth_date <= CURRENT_DATE)
1.5. Нет обязательных полей (NOT NULL)
Поля client_name, client_surname, reg_date могут содержать NULL. Добавить NOT NULL для обязательных полей. Для reg_date установить значение по умолчанию (DEFAULT CURRENT_DATE).
client_name varchar(255) NOT NULL,
client_surname varchar(255) NOT NULL,
reg_date date NOT NULL DEFAULT CURRENT_DATE
1.6. Отсутствие индексов
Нет индексов для часто используемых полей (login, city_id).
CREATE INDEX idx_clients_login ON clients(login);
CREATE INDEX idx_clients_city_id ON clients(city_id);
-- Улучшенная схема таблицы:
CREATE TABLE clients (
client_id number PRIMARY KEY,
client_name varchar(255) NOT NULL,
client_surname varchar(255) NOT NULL,
login varchar(30) UNIQUE NOT NULL,
city_id number REFERENCES cities(city_id) ON DELETE SET NULL,
birth_date date CHECK (birth_date <= CURRENT_DATE),
reg_date date NOT NULL DEFAULT CURRENT_DATE
);
-- Индексы
CREATE INDEX idx_clients_login ON clients(login);
CREATE INDEX idx_clients_city_id ON clients(city_id);
Дополнительные рекомендации
1. Нормализация: Если у клиента несколько адресов/телефонов, вынести их в отдельные таблицы.
2. Аудит изменений: Добавить поля created_at и updated_at для отслеживания изменений.
2.
Решение: Создать отдельную таблицу для хранения всех изменений цены с временными метками.
-- Основная таблица товаров (текущие данные)
items (
item_id number PRIMARY KEY,
item_name varchar(255) NOT NULL
);
-- Таблица истории цен
price_history (
price_id number PRIMARY KEY,
item_id number REFERENCES items(item_id) ON DELETE CASCADE,
cost number NOT NULL CHECK (cost > 0),
valid_from date NOT NULL DEFAULT CURRENT_DATE,
valid_to date,
changed_by varchar(100), -- кто изменил цену
reason varchar(255) -- причина (акция, сезонность и т.д.)
);
При изменении цены вставляется новая запись в price_history с: valid_from — дата начала действия цены. valid_to — дата окончания.
3.
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN
LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
L.CITY = 'SEOUL'
AND E.MANAGER_ID IS NULL
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
Правильная проверка NULL: E.MANAGER_ID IS NULL вместо MANAGER_ID = NULL.
Перенос агрегатного условия в HAVING: SUM(E.SALARY) > 100000 теперь в HAVING, а не в WHERE.
Явное соединение с LOCATIONS: Добавлен JOIN между DEPARTMENTS и LOCATIONS для корректной фильтрации по городу.
Добавлен DEPARTMENT_ID в GROUP BY: Для однозначной группировки (даже если DEPARTMENT_NAME уникален).
4.
Карандаш положили на пол в комнате так, что никто не смог перепрыгнуть через него, потому что он расположен вплотную к стене.
Ещё один вариант — карандаш лежит в углу, что тоже затрудняет прыжок через него.",
154,7837378.txt,.txt,text,"1. Необходимо внести следующие изменения:
 1) Поле login должно быть уникально
 2) Столбец age необходимо заменить на birth_date с типом данный date, так как возраст придется обновлять каждый год; дата рождения является более информативной, в отличие от цифры возраст

2. Для доработки архитектуры таблицы необходимо удалить столбец со стоимостью товара (item_cost), создать новую таблицу, в которой будут храниться данные об изменениях цены товара. Структура таблицы:
 prices (
 item_id number, --
 item_price number, --текущая цена товара
 changing_date date --дата изменения цены товара
 );
При изменении цены товара в новой таблице будет создаваться запись с новой установленной ценой товара и датой изменений цены. Таким образом все предыдущие значения цены товара (любого) будут храниться в таблице. А для получения актуальной цены товара необходимо выбрать последнюю по дате запись в новой таблице prices
3. Исправленный запрос:
SELECT E.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND E.MANAGER_ID = NULL
 AND D.LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
GROUP BY E.DEPARTMENT_ID
HAVING SUM(E.SALARY) >= 100000

4. Потому что карандаш укатился к стене",
155,78378.pdf,.pdf,pdf,"Задание №1
1. У client_id вместо типа данных «number» изменил бы на «INT PRIMARY KEY
AUTO_INCREMENT».
2. В client_name «varchar(255)», согласно рекомендациям по выбору типов данных
для полей таблицы, сократил бы значение символов. Вместо «varchar(255)»,
например, «varchar(20)».
3. В client_surname «varchar(255)», сделал бы тоже самое, сократил бы значение
символов с «varchar(255)» до, например, «varchar(40)».
4. login «varchar(30)» – без изменений.
5. В city_id вместо типа данных «number» изменил бы на «INT NOT NULL». Потому
что city_id внешний ключ и для внешних ключей рекомендуется устанавливать
ограничение NOT NULL. Каждый внешний ключ должен иметь такой же тип
данных, как связанное поле главной таблицы (в нашем случае INT). По умолчанию
любой столбец, кроме ключевого, может содержать значение NULL. При создании
таблицы — это можно переопределить, используя ограничение NOT NULL для этого
столбца.
6. В age тип «number» изменил бы на тип данных «INT».
7. reg_date «date» – без изменений.
*Еще бы добавил / изменил:
– Добавил бы поле (столбец) password с типом данных «varchar(30)».
– Добавил бы поле (столбец) email с типом данных «varchar(30)».
– Добавил бы поле (столбец) phone_number с типом данных «INT».
– Наверное добавил бы поле (столбец) с физическим адресом, где клиент проживает,
address с типом данных «varchar(50)».
– Возможно изменил бы поле (столбец) age на дату рождения клиента, date_birth с
типом данных «date».

Задание №2
1. У item_id вместо типа данных «number» изменил бы на «INT PRIMARY KEY
AUTO_INCREMENT».
2. В item_name varchar(255), согласно рекомендациям по выбору типов данных для
полей таблицы, сократил бы значение символов. Вместо varchar(255), например,
varchar(25).
3. В item_cost тип «number» изменил бы на тип данных «DECIMAL(8,2) или
NUMERIC(6,3)». Оба этих типа эквивалентны.
*Как обеспечить историческое хранение стоимости товара?
(Создать еще одну отдельную таблицу, где будут хранится исторические данные.
Так как в вопросе речь идет о доработке данной таблицы, этот вариант не подходит).
Создать для каждой отдельной записи в таблице поле-ключ атрибут данной версии.
И добавить дополнительные поля (столбцы) в таблицу items:
– Предыдущая цена his_cost с типом данных «DECIMAL(8,2) или NUMERIC(6,3)»
– Дата изменения товара his_date с типом данных «date».
Задание №3
SELECT d.department_id, department_name, SUM(salary) total_salary
FROM employees e INNER JOIN departments d ON e.department_id = d.department_id,
locations
WHERE manager_id IS NULL
AND location_id = (SELECT location_id FROM locations WHERE city = 'Seoul')
GROUP BY department_id, department_name
HAVING SUM(salary) > 100000
Задание №4
1) В комнате слишком низкие потолки.
2) Карандаш упал вплотную со стеной или мебелью.
3) Потому что пол нельзя перепрыгнуть.",
156,783783.docx,.docx,docx,"1. Таблицу можно и нужно улучшить, предложение
CREATE TABLE clients (
    client_id INT PRIMARY KEY AUTO_INCREMENT, -- уникальный идентификатор
    client_name VARCHAR(100) NOT NULL, -- имя клиента
    client_surname VARCHAR(100) NOT NULL, -- фамилия клиента
    login VARCHAR(30) UNIQUE NOT NULL, -- уникальный логин
    city_id INT, -- id города
    birth_date DATE, -- дата рождения клиента
    reg_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- дата регистрации с автоматическим заполнением
    email VARCHAR(255) UNIQUE NOT NULL, -- уникальная электронная почта
    phone_number VARCHAR(20), -- телефон клиента (опционально)
    FOREIGN KEY (city_id) REFERENCES cities(city_id), -- внешний ключ для обеспечения целостности
    INDEX idx_login (login),
    INDEX idx_email (email)
)
2. Можно написать таблицу логов + тригер
CREATE TABLE item_prices_audit (
    audit_id INT AUTO_INCREMENT PRIMARY KEY,
    item_id INT,
    item_cost DECIMAL(10, 2),
    change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    changed_by VARCHAR(100),
    change_type VARCHAR(50),
    FOREIGN KEY (item_id) REFERENCES items(item_id)
)
DELIMITER //
CREATE TRIGGER trg_price_audit AFTER UPDATE ON items
FOR EACH ROW
BEGIN
    INSERT INTO item_prices_audit (item_id, item_cost, changed_by, change_type)
    VALUES (NEW.item_id, NEW.item_cost, USER(), 'изменение цены');
END//
3. Запрос некорректен, надо изменить на
SELECT D.DEPARTMENT_ID,
    D.DEPARTMENT_NAME,
    SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
    JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
    AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID,
    D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
4. Не стоит прыгать по офису, я полагаю)",
157,783783.txt,.txt,text,"1.
- Поля client_name и client_surname имеют тип varchar(255). 
 Для имен и фамилий это большой размер, поскольку редко встречаются имена и фамилии такой длины. 
 Возможно, достаточно будет varchar(100) или даже varchar(50).
 
- Поле login varchar(30) может быть недостаточно длинным, стандартные email могут быть длинными.
 Можно рассмотреть увеличение длины до varchar(100).
 
- Поле age с типом number не удобно для работы. Лучше хранить дату рождения клиента в формате date и вычислять возраст динамически, чтобы избежать проблем с изменением возраста клиента с течением времени.

- Для поля login необходимо установить ограничение уникальности (UNIQUE), чтобы избежать дублирования логинов среди клиентов.

- Поле city_id предполагает, что существует отдельная таблица городов с их названиями с точки зрения нормализации.
 В таблице cities должны быть необходимые поля (например, city_name, region, country).
 
- Поле reg_date лучше сделать timestamp, чтобы иметь более точную информацию. Возможно новым пользователям будет предоставлена какая-нибудь скидка, если они сделают заказ в первые часы знакомства с магазином.

2.
- необходимо создать новую таблицу, которая будет хранить все изменения цены каждого товара с указанием периода действия этой цены.

- первая таблица будет items:
 item_id serial PRIMARY KEY, -> уникальный id товара,
 item_name varchar(255) NOT NULL -> наименование товара
 
Вторая таблица будет item_prices: 
 price_id serial PRIMARY KEY, -> уникальный id записи о цене,
 item_id number NOT NULL, -> внешний ключ на товар
 item_cost number NOT NULL, -> стоимость товара
 valid_from date NOT NULL, -> дата начала действия цены
 valid_to date -> дата окончания действия цены (может быть NULL, если цена действующая)
 
- items хранит основную информацию о товаре, за исключением текущей цены.

- item_prices хранит информацию о всех изменениях цен. В поле valid_from указывается дата начала действия цены, а в поле valid_to — дата окончания действия цены. 
 Если цена действующая, valid_to остается NULL.
 

3.

- В SQL проверка на NULL должна выполняться с использованием оператора IS NULL, а не = NULL.

- SUM(SALARY) — это агрегатная функция, ее нельзя использовать в условии WHERE. Для агрегатных функций применяется оператор HAVING.

- В запросе используется GROUP BY DEPARTMENT_NAME, но в выборке также присутствует DEPARTMENT_ID, которое тоже нужно добавить в GROUP BY.

- Можно избавиться от вложенного запроса и использовать джоин для оптимизации запроса.

Корректный запрос:
 SELECT D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) TOTAL_SALARY
 FROM EMPLOYEES E
 JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
 WHERE E.MANAGER_ID IS NULL
 AND L.CITY = 'SEOUL'
 GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
 HAVING SUM(E.SALARY) > 100000; 

4.
- карандаш упал в другой комнате, где меня нет;
- карандаш маленький и не создает препятствия, чтобы его перепрыгивать;
- карандаш упал на пол, а мы знаем с детства, что пол - это лава, соответственно, он расплавился. Получается отсутствует препятствие для прыжка.",
158,78587578,,error,,Unsupported extension:  (file=78587578)
159,786.docx,.docx,docx,"Задание 1
Таблицу clients я бы изменила так:
clients (
client_id NUMBER PRIMARY KEY, (добавим первичный ключ для хранения уникального id клиента)
client_name VARCHAR(255), -- имя клиента
client_surname VARCHAR(255), -- фамилия клиента
login VARCHAR(30) UNIQUE, (добавим уникальность в логин, который придумал клиент)
email VARCHAR(255) UNIQUE, (добавим адрес электронной почты клиентов, для связи с ними)
city_id NUMBER, (id города подразумевает существование таблицы городов)
birth_date DATE, -- (изменим столбец возраст на дату рождения клиента, чтобы постоянно не переписывать данные и позволит более точно определять возраст клиента)
reg_date DATE -- дата регистрации на сайте
FOREIGN KEY (city_id) REFERENCES city(city_id)
);
Задание 2
Для реализации исторического хранения стоимости товара в таблице items, создадим дополнительную таблицу для хранения изменений цен.
item_prices (
price_id NUMBER PRIMARY KEY, уникальный идентификатор записи о цене
item_id NUMBER, -- внешний ключ на таблицу items
price NUMBER, -- стоимость товара
start_date DATE, -- дата начала действия цены
stop_date DATE, -- дата окончания действия цены (может быть NULL для текущей цены)
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Из таблицы items уберем информацию о стоимости, так как она хранится в item_prices.
items (
item_id NUMBER PRIMARY KEY, -- уникальный id товара
item_name VARCHAR(255), -- наименование товара
);
Задание 3
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME,SUM(E.SALARY) AS TOTAL_SALARY FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
Что изменилось
1. Использование JOIN для более ясного соединения таблиц.
2. Исправлено условие на E.MANAGER_ID IS NULL.
3. Добавлено поле D.DEPARTMENT_ID в GROUP BY, так как оно используется в SELECT.
4. Условие для суммы перемещено в HAVING, чтобы фильтровать группы после агрегации.
Задание 4
Можно придумать много вариантов, когда перепрыгнуть карандаш невозможно, например он закатился за тяжелый и больщой предмет мебели, он лежит у стены, возможно в комнате слишком низкий потолок и прыгать там невозможно, может быть неизвестно местонахождение комнаты и так далее.",
160,78668.docx,.docx,docx,"Ответ на задание
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
выбирается название города, а в таблицу сохраняется id)
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему мнению некорректно и какие изменения внесли бы.
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы *, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100 000. Для решения задачи был написан следующий запрос:
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
client_id | number, --уникальный id клиента
client_name | varchar(255), --имя клиента
client_surname | varchar(255), --фамилия клиента
login | varchar(30), --логин, который придумал клиент
city_id | number, --id города, который указал клиент (в интерфейсе
age | number, --возраст клиента
reg_date | date –дата регистрации на сайте
По моему мнению некорректно 
client_id необходимо уникальность значения и целочисленным, например unique, int
имя клиента и фамилию можно ограничить 50 символами, например varchar(50) 
login необходимо уникальность значения, например Nvarchar(30)
city_id необходимо целочисленное значение
age необходимо целочисленное значение
По моему мнению некорректно 
item_id необходимо уникальность значения и целочисленным, например unique, int
item_name можно ограничить 50 символами, например varchar(50) 
item_cost указать тип данных money
Для сохранения исторической стоимости товара я бы добавил item_cost_date с значением атрибута типа date
Пример | Мой вариант
SELECT DEPARTMENT_ID, 
 DEPARTMENT_NAME, 
 SUM(SALARY) TOTAL_SALARY 
 FROM EMPLOYEE E, 
 DEPARTMENTS D 
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID 
 AND MANAGER_ID = NULL 
 AND LOCATION_ID = (SELECT LOCATION_ID 
 FROM LOCATIONS 
 WHERE CITY = 'SEOUL') 
 AND SUM(SALARY) >= 100000 
GROUP BY DEPARTMENT_NAME | SELECT department_name
FROM(
 SELECT 
 department_name,
 SUM(salary) AS total_salary
 FROM employees E, JOIN 
 department D ON E.department _id = D.department _id 
 WHERE manager_id IS NULL 
 AND location_id IN (SELECT location_id 
 FROM locations 
 WHERE city = ‘Сеул’) 
 GROUP BY department_name ) T
GROUP BY department_name
HAVING SUM(salary) > 100000
Варианты ответов:
Он упал в угол комнаты, в которой я нахожусь.
Он упал на пол в комнате 2го этажа, в то время как я на 1ом этаже. 
Я понятия не имею, в какой комнате он упал.
Помещение с низким потолком (что-то вроде шахты), где нет возможности прыгнуть.
Такие правила комнаты. Нельзя прыгать.",
161,786686.docx,.docx,docx,"Задание 1.
В таблице отстусвуют ограничения ограничений (NOT NULL, UNIQUE, PRIMARY KEY)
Например, client_id должен быть PRIMARY KEY (уникальным и не NULL), login должен быть уникальным (UNIQUE).
Нет связи с таблицей городов (cities), city_id должен быть FOREIGN KEY на таблицу городов.
Харнить возраст лучше в формате даты рождения, так как возраст в отличае от даты рождения меняется.
Задание 2.
Нет первичного ключа у item_id, должен быть PRIMARY KEY.
Нет ограничений на обязательные поля у item_name и item_cost должны быть NOT NULL.
Нет категоризации товаров из-за сложно анализировать продажи по категориям.
Нет информации о наличии/остатках что важно для управления запасами.
История изменений:
В таблице items оставить только данные по акуальной цене, при её изменении производить запись в дополнительную таблицу item_price_history.
item_price_history(
item_id NUMBER NOT NULL REFERENCES items(item_id),
old_cost NUMBER NOT NULL, -- старая цена
new_cost NUMBER NOT NULL, -- новая цена
change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
changed_by NUMBER -- id,кто изменил (админ/система)
);
Задание 3.
Исходный запрос:
SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, -- EMPLOYEES (неправильное имя таблицы)
 DEPARTMENTS D
,____ -- LOCATIONS L (далее используется поле CITY из этой таблицы)
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID = NULL --MANAGER_ID IS NULL (сравнение с NULL всегда возвращает NULL), для сравнения используются конструкции IS NULL или IS NOT NULL.
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
 AND SUM(SALARY) >= 100000 -- Агрегатные функции нельзя использовать в WHERE. Они разрешены только в HAVING (после GROUP BY).
GROUP BY DEPARTMENT_NAME -- D.DEPARTMENT_ID, D.DEPARTMENT_NAME (указан только DEPARTMENT_NAME, но в SELECT есть DEPARTMENT_ID)
Исправленный запрос: (Конструкция where исправлена на join для улучшения читаемости соблюдения современных стандартов)
SELECT 
 D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM 
 EMPLOYEES E
 INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 INNER JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE 
 E.MANAGER_ID IS NULL
 AND L.CITY = 'SEOUL'
GROUP BY 
 D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING 
 SUM(E.SALARY) > 100000
Задание 4.
Карандаш укатился и прижался длинной стороной к стене.",
162,7867845.docx,.docx,docx,"Тестовое задание
Задание 1.
CREATE TABLE clients (
client_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
client_name VARCHAR(255),
client_surname VARCHAR(255),
login VARCHAR(30) UNIQUE,
city_id NUMBER,
birth_date DATE,
reg_date DATE,
CONSTRAINT fk_city FOREIGN KEY (city_id) REFERENCES cities(city_id)
);
Решение:
1) Необходимо задать client_id, как первичный ключ, а также добавить автоинкремент.
2) Логин должен быть уникальным.
3) Так как возраст клиента будет меняться, лучше сохранять дату рождения.
4) Предположим, что названия городов хранятся в отдельной таблице (cities), тогда лучше добавить ограничение, которое гарантирует целостность данных.
Задание 2.
CREATE TABLE items (
item_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
item_name VARCHAR2(255)
);
CREATE TABLE item_prices (
price_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
item_id NUMBER,
price NUMBER,
valid_from DATE,
valid_to DATE,
CONSTRAINT fk_item FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Решение:
Для того, чтобы обеспечить историческое хранение стоимости товара я бы создал отдельную таблицу, куда будет записывать текущая цена товара, а также даты с какого по какой период цена была действительной (если цена актуальна, то поле valid_to не заполняется).
Для того, чтобы узнать актуальную цену можно использовать запрос:
SELECT
i.item_id,
i.item_name,
p.price AS current_price
FROM
items i
JOIN
item_prices p ON i.item_id = p.item_id
WHERE
p.valid_to IS NULL;
Задание 3.
SELECT
d.DEPARTMENT_ID,
d.DEPARTMENT_NAME,
SUM(e.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES e
JOIN
DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN
LOCATIONS l ON d.LOCATION_ID = l.LOCATION_ID
WHERE
e.MANAGER_ID IS NULL
AND l.CITY = 'SEOUL'
GROUP BY
d.DEPARTMENT_ID, d.DEPARTMENT_NAME
HAVING
SUM(e.SALARY) > 100000;
Решение:
1) Лучше использовать явный JOIN вместо запятой.
2) В SQL NULL сравнивается с помощью IS NULL, а не =.
3) В GROUP BY должно быть указано всё, что в SELECT, кроме агрегатных функций.
4) Так как агрегатные функции применяются после группировки, SUM(SALARY) > 100000 нужно использовать в HAVING.
5) Мелкие ошибки: исходя из HR схемы, таблица называется EMPLOYEES; для фильтрации отделов, где работники зарабатывают больше 100000, требуется знак >.
Задание 4
1) Карандаш упал возле стены.
2) У меня могут болеть ноги.
3) В комнате запрещено прыгать.
4) Это просто гигантский карандаш.
5) Карандаш является лишь плодом воображения.
6) Тогда карандаш больше не вырастит :(",
163,786786.docx,.docx,docx,"Климов Денис
1 задание
Client_id – если предполагается, что это первичный ключ, то следует ему добавить автогенерацию значения
Login должен иметь ограничение на уникальность
City_id должен быть внешним ключом, ссылающимся на таблицу с городами
Не очень понятно хранится ли пароль от аккаунтов пользователей. Следовало бы добавить поле password, которое будет храниться в захэшированном виде
2 задание
Я бы создал вторую таблицу, где будет id записи, id товара (внешний ключ), стоимость товара и дата записи. В данную таблицу вносились бы все записи о новых ценах товаров, записи с самой молодой датой будут являться актуальными на данный момент.
3 задание
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY FROM EMPLOYEES E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID WHERE E.MANAGER_ID IS NULL AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL') GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME HAVING SUM(E.SALARY) >= 100000;
4 задание
Карандаш находится рядом со стеной",
164,78678678.pdf,.pdf,pdf,"Ответ на задание
1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую базу
данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку
существующей архитектуры и решить корректна ли она или можно внести некоторые
доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях
(клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему
мнению некорректно и какие изменения внесли бы.
По моему мнению некорректно
1. client_id необходимо уникальность значения и целочисленным, например unique,
int
2. имя клиента и фамилию можно ограничить 50 символами, например varchar(50)
3. login необходимо уникальность значения, например Nvarchar(30)
4. city_id необходимо целочисленное значение
5. age необходимо целочисленное значение

2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую базу
данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку
существующей архитектуры и решить корректна ли она или можно внести некоторые
доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости
товара?
По моему мнению некорректно
1. item_id необходимо уникальность значения и целочисленным, например unique, int
2. item_name можно ограничить 50 символами, например varchar(50)
3. item_cost указать тип данных money
4. Для сохранения исторической стоимости товара я бы добавил item_cost_date с
значением атрибута типа date

3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы *, расположенные в Сеуле в которых все сотрудники,
не имеющие менеджера, зарабатывают в общей сложности более 100 000. Для решения
задачи был написан следующий запрос:
Пример Мой вариант
SELECT DEPARTMENT_ID, SELECT department_name
DEPARTMENT_NAME, FROM(
SUM(SALARY) TOTAL_SALARY SELECT
FROM EMPLOYEE E, department_name,
DEPARTMENTS D SUM(salary) AS total_salary
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID FROM employees E, JOIN
AND MANAGER_ID = NULL department D ON E.department _id =
AND LOCATION_ID = (SELECT LOCATION_ID D.department _id
FROM LOCATIONS WHERE manager_id IS NULL
WHERE CITY = 'SEOUL') AND location_id IN (SELECT location_id
AND SUM(SALARY) >= 100000 FROM locations
GROUP BY DEPARTMENT_NAME WHERE city = ‘Сеул’)
GROUP BY department_name ) T
GROUP BY department_name
HAVING SUM(salary) > 100000

4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него
перепрыгнуть?
Варианты ответов:
1. Он упал в угол комнаты, в которой я нахожусь.
2. Он упал на пол в комнате 2го этажа, в то время как я на 1ом этаже.
3. Я понятия не имею, в какой комнате он упал.
4. Помещение с низким потолком (что-то вроде шахты), где нет возможности
прыгнуть.
5. Такие правила комнаты. Нельзя прыгать.",
165,786868.txt,.txt,text,"1 задание.

client_id — SERIAL PRIMARY KEY позволит автоматически проставлять идентификатор для каждого клиента.

client_name, client_surname — установить ограничение NOT NULL

login — установить ограничение UNIQUE и NOT NULL

city_id -связать с таблице городов при помощи внешнего ключа

age — установить ограничение CHECK>18

reg_date — CURRENT DATE для установки текущей даты в момент регистрации

Добавил бы поля email и phone - для связи с клиентами

2 задание.

Таблицу можно расширить такими полями как:

- дата поступления товара (date_received)

- дата продажи товара (date_sold)

- дата внесения изменений (update_date)

- отпускная цена товара (item_reteil_price)

- процент скидки (item_percent_discount)

3 задание.

В SELECT не указана таблица из которой брать поля D.DEPARTMENT_ID, D.DEPARTMENT_NAME, так же не указано откуда берем зарплату E.SALARY.

В WHERE не верно выполнена проверка на отсутствие менеджера IS NULL, а так же нельзя использовать фильтрацию с использованием агрегатной функций.

Фильтрация SUM(E.SALARY)>=100000 располагается в HAVING после GROUP BY

4 задание.

Уронили рядом со стеной.",
166,7878.pdf,.pdf,pdf,"1. Набор полей в таблице clients в целом выглядит вполне адекватным для хранения
информации о зарегистрировавшихся покупателях. Однако, я бы внесла некоторые
изменения и дополнения:
Добавила бы поле email varchar(255) для хранения электронной почты клиента, так
как это важный контактный адрес.
Добавила бы поле phone varchar(20) для хранения телефонного номера клиента.
Изменила бы поле city_id на city_name varchar(255), чтобы хранить не только
идентификатор города, но и его название. Это упростит работу с данными и делает
их более понятными для аналитики.
Добавила бы поле gender varchar(10) для хранения пола клиента.
Добавила бы поле last_login date для отслеживания последнего входа клиента на
сайт.
Таким образом, после внесения указанных изменений таблица clients будет более
информативной и удобной для работы с данными о клиентах интернет-магазина.
2. 1 вариант
Для того чтобы обеспечить историческое хранение стоимости товара в интернет-
магазине, можно использовать подход с созданием дополнительной таблицы для
отслеживания изменений цен. Это позволит сохранить историю цен на товары и
проводить анализ за различные временные промежутки.
Вот возможная схема для такой доработки:
1. Создать новую таблицу item_prices, которая будет хранить стоимость товара в
определённые временные промежутки.
CREATE TABLE item_prices (
price_id NUMBER PRIMARY KEY, -- уникальный id записи цены
item_id NUMBER, -- внешний ключ, ссылающийся на таблицу items
item_cost NUMBER, -- стоимость товара
start_date DATE, -- дата начала действия этой цены
end_date DATE, -- дата окончания действия этой цены
CONSTRAINT fk_item FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Пояснение полей:
- price_id: уникальный идентификатор на каждую запись цен.
- item_id: ссылается на `item_id` из таблицы `items` для связи товара с его ценами.
- item_cost: собственно, стоимость товара.
- start_date: дата, с которой данная цена начала действовать.
- end_date: дата, до которой данная цена была актуальна. Если цена действовала до
настоящего времени, данное поле можно оставить NULL или указать некую
финальную дату (например, '9999-12-31').
С помощью такой схемы можно легко получить информацию о ценах на товары за
любой период и поддерживать актуальность данных в базе.

2 вариант
Добавить дополнительное поле в таблицу items, которое будет отражать дату
изменения цены. Например:
items (item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number, --стоимость товара
price_date date); --дата изменения цены
Таким образом, каждый раз, когда цена товара меняется, новая запись будет
добавляться в таблицу с указанием даты изменения. Это позволит сохранить
историю изменения цен и использовать эту информацию для построения отчетов за
разные промежутки времени. Кроме того, можно создать соответствующие
индексы для повышения производительности запросов к этой таблице.
3. SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS
TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID = (SELECT LOCATION_ID FROM LOCATIONS WHERE
CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
1. Сравнение с NULL: Чтобы проверить, является ли значение NULL, нужно
использовать оператор IS NULL, а не =.
2. Условия GROUP BY и HAVING: После агрегатной функции SUM должно
использоваться условие HAVING, если вы хотите фильтровать результаты
группировки.
3. Фильтрация по отделам: Мы должны сначала найти все сотрудники, не имеющие
менеджера, и затем посчитать их зарплату по отделам.
Объяснение исправленного запроса:
- Используем JOIN для соединения таблиц EMPLOYEES и DEPARTMENTS по
DEPARTMENT_ID.
- Фильтруем сотрудников, где MANAGER_ID является NULL.
- Используем подзапрос для нахождения LOCATION_ID для города Сеул.
- Группируем результаты по DEPARTMENT_ID и DEPARTMENT_NAME.
- Используем HAVING для фильтрации групп, у которых сумма зарплаты
превышает 100000.

4. Карандаш уронили у стены, я не смогла бы его перепрыгнуть потому что врезалась
бы в стену.",
167,78786786378.txt,.txt,text,"1 Вопрос
clients (
 client_id number PRIMARY KEY, -- уникальный id клиента
 client_name varchar(255) NOT NULL, -- имя клиента
 client_surname varchar(255) NOT NULL, -- фамилия клиента
 login varchar(30) UNIQUE NOT NULL, -- уникальный логин, который придумал клиент
 city_id number NOT NULL, -- id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
 dBirth date NOT NULL, -- дата рождения
 reg_date date NOT NULL -- дата регистрации на сайте
);

2 Вопрос
items (
item_id number, -- уникальный id товара
item_name varchar(255), -- наименование товара
item_cost clob -- стоимость товара
);

3 Вопрос
SELECT 
 D.DEPARTMENT_ID,
 D.DEPARTMENT_NAME,
 SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E
 JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
 JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE 
 E.MANAGER_ID IS NULL,
 AND L.CITY = 'SEOUL'
GROUP BY
 D.DEPARTMENT_ID, 
 D.DEPARTMENT_NAME
HAVING
 SUM(E.SALARY) > 100000;

4 Вопрос
1) Он лежит у стенки
2) Это опасно
3) Никто не говорил, что я тоже в этой комнате
4) А для чего мне вообще прыгать через карандаш?",
168,8578.txt,.txt,text,"1. Логин должен быть уникальным, поэтому стоит добавить UNIQUE. Возраст лучше заменить на дату рождения и высчитывать его по необходимости, ибо возраст - изменяемое значение.Не понятно зачем тут город в виде id_city, если в связанной таблице хранится только название города, то стоит вместо ссылки проставлять название города. Если в связанной таблице также информация по городу, то это ок.
2.Можно создать новую таблицу, например, item_price_history и в ней будут поля: history_id-уникальный идентификатор записи в истории,item_id - идентификатор товара к которому относится запись,item_cost - цена товара на момент записи и date - дата, на момент которой была зафиксирована текущая цена и это будет связано один ко многим по полю item_id. Таким образом в таблице item_price_history будут записи с ценой на дату изменения.
3.
SELECT 
 d.DEPARTMENT_ID, -- идентификатор отдела из таблицы DEPARTMENTS
 d.DEPARTMENT_NAME, -- название отдела из таблицы DEPARTMENTS
 SUM(e.SALARY) AS TOTAL_SALARY -- суммирование зарплат сотрудников
FROM 
 EMPLOYEES e -- указание, что e - это псевдоним для таблицы EMPLOYEES
JOIN 
 DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID -- соединение с таблицей DEPARTMENTS по идентификатору отдела
JOIN 
 LOCATIONS l ON d.LOCATION_ID = l.LOCATION_ID -- соединение с таблицей LOCATIONS по идентификатору местоположения
WHERE 
 e.MANAGER_ID IS NULL -- проверка, что сотрудник не имеет менеджера
 AND l.CITY = 'SEOUL' -- фильтрация по городу Сеул
GROUP BY 
 d.DEPARTMENT_ID, -- группировка по идентификатору отдела
 d.DEPARTMENT_NAME -- группировка по названию отдела
HAVING 
 SUM(e.SALARY) > 100000; -- условие, что сумма зарплат больше 100000

4. Упала в другой комнате, указано 'В некоторой', но не в этой",
169,8585285.pdf,.pdf,pdf,"№ 1
Проблемы:
1. Поле “age” - будет устаревать каждый год, поэтому, на мой взгляд,
лучше заменить его на дату рождения клиента.
2. Поле “city_id” - если существует отдельная таблица со списком
городов, то все отлично, иначе это поле не имеет смысла
3. Отсутствуют контактные данные клиента, номер телефона / почта, без
них могут возникнуть проблемы с коммуникацией с клиентом.
4. Необходимо добавить ограничения на поля: login (уникальность, not
null), электронная почта (уникальность, not null), reg_date (not null),
client_name (not null), client_surname (not null).
5. Можно было бы добавить поле last_activity_date, чтобы упростить
аналитику по клиенту, но может возникнуть проблема с нарушением
нормализации, риска устаревания данных и дублирования, поэтому все
же лучше хранить данную статистику в другой таблице.
Считаю, что на client_id, city_id уже навешены необходимые ограничения
(primary key, references) соответственно.

№2
Я бы воспользовался scd2, тогда таблица имела бы такой вид:
items (
surrogate_id SERIAL PRIMARY KEY,
item_id INTEGER NOT NULL,
item_name VARCHAR(255) NOT NULL,
item_cost NUMERIC(10, 2) NOT NULL,
start_date DATE NOT NULL,
end_date DATE,
);
Или scd4: (к таблице items добавится новая):
price_history (
price_id SERIAL PRIMARY KEY,
item_id INT REFERENCES items(item_id),
cost NUMERIC NOT NULL,
start_date DATE NOT NULL,
end_date DATE -- NULL означает текущую активную цену
);

№3
SELECT
d.department_id,
d.department_name,
SUM(e.salary) AS total_manager_salary
FROM departments d
JOIN employees e
ON d.manager_id = e.employee_id
JOIN locations l
ON d.location_id = l.location_id
WHERE l.city = 'Seoul'
GROUP BY d.department_id, d.department_name
HAVING SUM(e.salary) > 100000;
№4
Карандаш положили в углу комнаты или вплотную к стене.",
170,87235257.pdf,.pdf,pdf,"Тестовое задание
1) В модели таблицы clients я бы исправила следующее:
Так как реквизит client_id - это уникальный id клиента, он является
первичным ключом и это должно быть отражено в схеме таблицы.
Также необходимо отразить в таблице, что city_id является внешним
ключом для другой таблицы, назовём её cities.
Кроме того, я бы объединила поля client_name и client_surname в одно
поле client_name типа varchar(500).
Дополнительно я бы добавила в таблицу реквизиты, которые могут
пригодиться с точки зрения бизнеса - это почта клиента с типом varchar(80).
Также я считаю, что в таблицу можно добавить реквизит, который будет
хранить в себе пол покупателя, с типом varchar(1).
Тогда схема таблицы выглядела бы следующим образом:
clients (
client_id int not null primary key — уникальный id клиента
client_name varchar(500) — имя клиента
login varchar(30), — логин, который придумал клиент
city_id int foreign key references cities(city_id)— ссылка на город из
таблицы cities
age number, --возраст клиента
reg_date date –дата регистрации на сайте
client_mail varchar(80) — почта клиента
client_gender varchar(1) - пол клиента
);
2) Для того, чтобы обеспечить историческое хранение стоимости товара, я бы
добавила в таблицу items ещё 2 реквизита: price_act_from и price_act_till.
Первый реквизит price_act_from имеет тип date и хранит в себе дату, с которой
действует указанная цена на товар. Второй реквизит price_act_till также имеет
тип date и хранит информацию о том, когда содержащаяся в экземпляре
таблицы цена перестала быть актуальной. Если реквизит price_act_till содержит
в себе null, то цена считается актуальной на момент запроса.
В таком случае схема таблицы items будет выглядеть следующим образом:
items(

item_id number,
item_name varchar(255),
item_cost number,
price_act_from date,
price_act_till date
)
3)
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.MANAGER_ID IS NULL
AND D.LOCATION_ID IN (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_NAME,
D.DEPARTMENT_ID
HAVING SUM(E.SALARY) >= 100000
4) Через карандаш нельзя перепрыгнуть, потому что его уронили рядом со
стеной.",
171,873.txt,.txt,text,"1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте);

Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему
мнению некорректно и какие изменения внесли бы.

Возможно стоит добавить поле password если аутентификация происходит по данной таблице, либо login вынести в другую таблицу с внешним ключом client_id.
Исходя из того, для каких целей используется таблица, как вариант - поля:
client_name, client_surname, city_id, age 
можно вынести в отдельную таблицу где client_id будет внешним ключом.

----------------------------------------------------------------------------------------------------------------------------

2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести некоторые доработки.

Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара);

Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно строить различныотчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.

Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранениестоимости
товара?

Вариант 1(если точно придерживаться поставленной задачи ""доработали архитектуру таблицы"")
Добавить для каждой записи 3 поля:
ID number, -- primary_key
Begin_date date, - начало действия цены.
End_date date, - окончание действия цены.
Наложить ограничение, на создание новой записи если Begin_date < End_date уже имеющейся(MAX(ID) group by item_id)
Либо:
а) при создании новой записи, в качестве Begin_date = End_date +1 последней из имеющихся по данному item_id (MAX(ID) group by item_id);
б) при создании новой записи, в качестве End_date последней из имеющихся по данному item_id (MAX(ID) group by item_id) ставить Begin_date - 1 ;
Зависит от логики работы со сроками действительности цен.

Таким образом item_cost перестаёт быть уникальным id в таблице, а становится ID товара, по которому можно отследить историчность цен данного товара.

Вариант 2.(с точки зрения нормализации БД)
Вынести item_cost в отдельную таблицу.
cost_items ( 
cost_id, -- уникальный id cnjbvjcnb товара
item_id number, -- id товара
cost number, –стоимость товара
Begin_date date, -- начало действия цены
End_date date, -- окончание действия цены
);

Тогда исходная таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара);

----------------------------------------------------------------------------------------------------------------------------

3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:

SELECT 
DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID = NULL
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
 AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME

Варианты решения:
SELECT 
DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID IS NULL
 AND LOCATION_ID IN (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
 
GROUP BY DEPARTMENT_NAME, DEPARTMENT_ID
HAVING SUM(SALARY) > 100000

SELECT 
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM 
EMPLOYEE E
LEFT JOIN DEPARTMENTS D ON E.EPARTMENT_ID=D.EPARTMENT_ID
JOIN LOCATIONS L IN D.LOCATION_ID=L.LOCATION_ID
WHERE 
E.MANAGER_ID IS NULL AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME,
HAVING SUM(SALARY) > 100000

----------------------------------------------------------------------------------------------------------------------------

4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?

Я нахожусь во вполне определённой комнате, а карандашь в некоторой.",
172,87525278.docx,.docx,docx,"1.Необходимо добавить ограничение NOT NULL на поля: фамилия, имя, логин, город, дата рождения, дата регистрации.
Поле возраст заменить на дату рождения, чтобы не заниматься ежегодным обновлением атрибута, а при необходимости легко можно было бы посчитать возраст клиента(+ точная дата рождения даёт возможность привлечь внимание клиента за счёт праздничной акции)
Также необходимо внести ограничения для поля логин: ограничение уникальности, минимальное количество символов, символы, которые нельзя использовать
VARCHAR(255) слишком большое количество символов для фамилии, имени и отчества. Можно сократить до VARCHAR(50)
Для client_id можно использовать SERIAL для автоматической инкрементации айдишника, если айдишники не имеют под собой какого-то особого способа генерации, а также обозначить его как PRIMARY KEY
В city_id заменить number на iteger например
2. Необходимо создать дополнительную таблицу для хранения исторических данных, а в исходной хранить только актуальную стоимость.
Пример новой таблицы:
CREATE TABLE items_history (
history_id SERIAL PRIMARY KEY,
item_id INTEGER NOT NULL REFERENCES items(item_id),
old_cost NUMERIC(10,2) NOT NULL,
new_cost NUMERIC(10,2) NOT NULL,
change_date DATE,
change_reason VARCHAR(255) -- Причина изменения (акция, инфляция и т.д.)
);
3.SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(SALARY) as TOTAL_SALARY
FROM DEPARTMENTS D LEFT JOIN EMPLOYEE E
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE MANAGER_ID IS NULL AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY D. DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
4.Карандаш упал к стене",
173,8763.pdf,.pdf,pdf,"1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До
вас в этой компании уже работал один разработчик, который придумал небольшую базу данных
для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей
архитектуры и решить корректна ли она илиможно внести некоторые доработки. Вы обратили
внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах). Таблица
имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе выбирается название города, а в
таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте );
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему
мнению некорректно и какие изменения внесли бы.
ОТВЕТ
Данный набор полей в таблице clients не является корректным, так как таблица денормализована.
В текущем виде она не соответствует требованиям нормализации, что может привести к
дублированию данных и затруднениям при обновлении информации. Для улучшения архитектуры
и обеспечения структурированного хранения данных, я бы предложил привести схему к третьей
нормальной форме (3NF), что является стандартом для построения корпоративного хранилища
данных.
Пример:
1. Таблица клиентов (clients)
Хранит только информацию, относящуюся напрямую к клиенту, и не содержит дублирующих
данных.
CREATE TABLE clients (
client_id NUMBER PRIMARY KEY, -- Уникальный ID клиента
login VARCHAR(100) UNIQUE, -- Уникальный логин клиента
password_hash VARCHAR(255), -- Хэш пароля клиента
salt VARCHAR(255), -- Соль для хеширования пароля
reg_date TIMESTAMP -- Дата регистрации на сайте
);
2. Таблица client_info (информация о клиенте):
CREATE TABLE client_info (

client_id NUMBER PRIMARY KEY, -- Уникальный ID клиента
client_name VARCHAR(255), -- Имя клиента
client_surname VARCHAR(255), -- Фамилия клиента
birth_date DATE, -- Дата рождения клиента (вместо возраста, это добавляет
возможность, например, делать скидки клиентам ко дню рождения клиентов магазина, также не
будет такой проблемы, как обновление базы для актуализации возраста клиентов)
CONSTRAINT fk_client FOREIGN KEY (client_id) REFERENCES clients(client_id)
);
3. Таблица городов (cities)
Хранит уникальные города с их ID и названиями.
CREATE TABLE cities (
city_id NUMBER PRIMARY KEY, -- Уникальный ID города
city_name VARCHAR(255) NOT NULL -- Название города
);
4. Связь клиента и города (client_city)
Промежуточная таблица, связывающая клиентов с городами. Это нужно для соблюдения 3NF, где
каждый атрибут в таблице клиентов должен зависеть только от первичного ключа.
CREATE TABLE client_city (
client_id NUMBER, -- ID клиента
city_id NUMBER, -- ID города
CONSTRAINT fk_client FOREIGN KEY (client_id) REFERENCES clients(client_id),
CONSTRAINT fk_city FOREIGN KEY (city_id) REFERENCES cities(city_id)
);
5. Дополнительно можно создать таблицы для email и телефона
Это полезно, если у одного клиента может быть несколько email-адресов или телефонов (многие-
ко-многим).
Таблица emails:
CREATE TABLE emails (
email_id NUMBER PRIMARY KEY, -- Уникальный ID email
client_id NUMBER, -- ID клиента
email VARCHAR(255), -- Email клиента
CONSTRAINT fk_client_email FOREIGN KEY (client_id) REFERENCES clients(client_id)
);
6. Таблица phones:

CREATE TABLE phones (
phone_id NUMBER PRIMARY KEY, -- Уникальный ID телефона
client_id NUMBER, -- ID клиента
phone VARCHAR(15), -- Телефон клиента
CONSTRAINT fk_client_phone FOREIGN KEY (client_id) REFERENCES clients(client_id)
);
Связи:
Таблица clients связана с таблицей client_info через внешний ключ client_id
Таблица clients связана с таблицей client_city через внешний ключ client_id
Таблица cities связана с таблицей client_city через внешний ключ city_id
Таблицы emails и phones связаны с таблицей clients через внешний ключ client_id
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До
вас в этой компании уже работал один разработчик, который придумал небольшую базу данных
для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей
архитектуры и решить корректна ли она илиможно внести некоторые доработки. Вы обратили
внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не
каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или
наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у
магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различныt
отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и
даже прошлые года. Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое
хранениестоимости товара?
ОТВЕТ
Я бы не смог ограничиться одной таблицей, так как корпоративное хранилище данных требует
нормализации для минимизации дублирования и поддержания целостности данных. Для
эффективного хранения и анализа информации необходимо разделить данные на логически
независимые таблицы. Это позволит не только избежать избыточности, но и обеспечит гибкость
при расширении и модификации базы, позволяя корректно хранить исторические данные и легко
интегрировать новые функции, такие как отчетность.
Пример:
1. Таблица items (основная информация о товарах):

Эта таблица будет хранить информацию о самих товарах.
CREATE TABLE items (
item_id NUMBER PRIMARY KEY, -- Уникальный ID товара
item_name VARCHAR(255) NOT NULL -- Наименование товара
);
2. Таблица item_prices (история изменения цен):
Для того чтобы учитывать историю изменения цен на товары, создаем таблицу с историей цен.
CREATE TABLE item_prices (
price_id NUMBER PRIMARY KEY, -- Уникальный ID записи о цене
item_id NUMBER NOT NULL, -- ID товара (связь с таблицей items)
item_cost NUMBER NOT NULL, -- Стоимость товара
start_date DATE NOT NULL, -- Дата начала действия цены
end_date DATE, -- Дата окончания действия цены (NULL, если цена актуальна)
CONSTRAINT fk_item FOREIGN KEY (item_id) REFERENCES items(item_id)
);
3. Таблица promotions (информация о скидках):
CREATE TABLE promotions (
promo_id NUMBER PRIMARY KEY, -- Уникальный ID промо-акции
promotion_name VARCHAR(255) NOT NULL -- Название или описание промо-акции
);
4. Таблица promotion_items (история скидок на товары):
CREATE TABLE promotion_items (
promo_item_id NUMBER PRIMARY KEY, -- Уникальный ID записи
promo_id NUMBER NOT NULL, -- ID промо-акции (связь с таблицей promotions)
item_id NUMBER NOT NULL, -- ID товара (связь с таблицей items)
discount_percent NUMBER NOT NULL, -- Процент скидки
start_date DATE NOT NULL, -- Дата начала действия скидки
end_date DATE, -- Дата окончания действия скидки
CONSTRAINT fk_promo FOREIGN KEY (promo_id) REFERENCES promotions(promo_id),
CONSTRAINT fk_item FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Таблицы:

Таблица items хранит информацию о товаре.
Таблица item_prices хранит историю цен на товар.
Таблица promotions хранит информацию о промо-акциях (общая информация, например,
название или тип акции).
Таблица promotion_items хранит историю применения скидок к товарам, связывая товары с
промо-акциями.
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000. Для решения задачи был
написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND MANAGER_ID = NULL AND LOCATION_ID =
(SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL') AND SUM(SALARY) >= 100000 GROUP
BY DEPARTMENT_NAME
ОТВЕТ
1. Ошибка в группировке, не учитывается поле DEPARTMENT_ID
2. WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND MANAGER_ID = NULL AND LOCATION_ID =
(SELECT LOCATION_ID FROM LOCATIONS WHERE CITY = 'SEOUL') AND SUM(SALARY) >= 100000 – вот
это вы забавно придумали ))))
Не хватает джоинов, фильтр по зарплате надо перенести в HAVING, тк SUM() – агрегатная функция,
подзапрос для фильтрации города убираем, также по формулировке (зарабатывают в общей
сложности более 100000), наверное лучше использовать знак >.
3. FROM EMPLOYEE E, DEPARTMENTS D очевидно ошибка
Пример исправленного запроса:
SELECT
D.DEPARTMENT_ID
,D.DEPARTMENT_NAME
,SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN LOCATIONS L

ON D.LOCATION_ID = L.LOCATION_ID
WHERE
E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него
перепрыгнуть?
ОТВЕТ
Здесь можно придумать много решений.
1. Самое очевидное – зачем в принципе прыгать через карандаш? Его можно просто поднять или
взять другой карандаш, если некогда лазать по полу в поисках карандаша.
2. Карандаш мог закатиться под мебель, например, под стол – через него нельзя перепрыгнуть.
Ровно также, если он укатился в угол комнаты или к стене, если комната объята пламенем или
затоплена водой.
3. В некоторой комнате уронили карандаш, в некоторой, это какой и где конкретно, я в этой
комнате нахожусь? Если нет, то я не могу через него перепрыгнуть.
4. И все остальные истории с уточняющими вопросами, поскольку без них можно думать
бесконечно много.",
174,876876.docx,.docx,docx,"Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
выбирается название города, а в таблицу сохраняется id)
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему мнению некорректно и какие изменения внесли бы.
Ответ на задание:
clients (
client_id number, —уникальный id клиента
client_name varchar(255), —имя клиента
client_surname varchar(255), —фамилия клиента
login varchar(30), —логин, который придумал клиент
city_id number, —id города, который указал клиент (в интерфейсе выбирается название города, а в таблицу сохраняется id)
birth_date date, —дата рождения клиента
reg_date date —дата регистрации на сайте
);
*Вместо возраста клиента (age) использовать его дату рождения (birth_date), так как со временем возраст клиента меняется, а текущий возраст рассчитывать исходя из даты рождения клиента и текущей даты.
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
Ответ на задание:
items (
item_id NUMBER, -- уникальный id товара
item_name VARCHAR(255), -- наименование товара
item_cost NUMBER, -- стоимость товара
price_start_date DATE, -- дата начала действия цены
price_end_date DATE -- дата окончания действия цены
);
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000. Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
Ответ на задание:
SELECT D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM employees E
JOIN departments D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN locations L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'Seoul'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Карандаш закатился в угол
client_id | number, --уникальный id клиента
client_name | varchar(255), --имя клиента
client_surname | varchar(255), --фамилия клиента
login | varchar(30), --логин, который придумал клиент
city_id | number, --id города, который указал клиент (в интерфейсе
age | number, --возраст клиента
reg_date | date –дата регистрации на сайте",
175,877837.docx,.docx,docx,"Поскольку нет конкретных данных и требований длина логина может быть избыточной или наоборот тк при использовании почты ее длина может быть больше 30 символов, а также логины должны быть уникальными значениями следовательно нужно дополнить что значения должны быть уникальными и прописать ограничение UNIQUE.
Поля client_id , city_id лучше писать Int и поставить ограничение not null.Также не доконца понятно является ли city_id вторичным ключем или нет.
Поле age лучше заменить на тип данных date(дату рождения) и отдельно считать возраст тк иначе каждый год его нужно будет увеличивать.Как вариант SELECT EXTRACT(YEAR FROM AGE(NOW(), birth_date)) AS age FROM client
таким образам мы не только сможем посчитать возраст но и будем понимать возраст на текущий момент.
Для хранения историчности можно использовать отдельную таблицу в которой мы будем вести учет изменения цен:
table item_price
price_id int 
 item_id int
 cost number 
 valid_from date – дата когда цена начала быть октуальна
 valid_to date – дата когда цена перестала быть актуальна, если null -текущая цена
Таким образом мы можем хранить изменения стоимости по времени и видеть когда цена была актуально
В целом проще просто переписать данный запрос чем его редачить:
SELECT DEPARTMENT_ID, DEPARTMENT_NAME,SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN
LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
CITY = 'SEOUL'
AND MANAGER_ID IS NULL
GROUP BY
DEPARTMENT_ID, DEPARTMENT_NAME
HAVING
SUM(SALARY) > 100000;
Таким образам мы сразу джойним таблицы, и прописываем условия на город и отсутствие менеджера и после группировки делаем фильтрацию по зарплате больше 100000.
Я нахожусь в другой комнате, я не умею прыгать , я не знаю что такое карандаш.",
176,8868.txt,.txt,text,"Вопрос 1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему
мнению некорректно и какие изменения внесли бы

ОТВЕТ.
Технически можно работать и с такой таблицей. 
Но если есть возможность, то можно модифицировать
а) добавить:
client_middlename varchar(255), --отчество клиента (более точная идентификация, но необязательное к заполнению, т.к. есть люди без отчества)
email varchar(255), --электронная почта клиента (но есть вероятность, что эти данные храняться в отдельной таблице типа clients_contact)
phone varchar(12) --телефон клиента (но есть вероятность, что эти данные храняться в отдельной таблице типа clients_contact)
б) заменить:
birth_date date, --дата рождения клиента (если использовать такое поле вместо поля age - возраст можно вычислить более точно, а к его дате рождения, к примеру, приурочить какие-нибудь бонусы в магазине)
в) изменить
reg_date datetime –-дата регистрации на сайте (добавив время регистрации, можно будет воспользоваться временной аналитикой регистрации новых пользователей)
_______________________________________________________________________________________________________________________________________________________________________________________________________________

Вопрос 2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
);
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно строить различныотчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранениестоимости
товара?

ОТВЕТ.
Обычно в таких случаях хватает добавления двух полей:
date_begin date или datetime, --дата начала действия цены. тип datetime нужен, если нужна еще часовая аналитика, т.е. стоимость может менятся несколько раз в день или в разное время. иначе достаточно типа date
date_end date или datetime --автоматически заполняемое поле при вставке новой строки новой стоимости конкретного товара.
Также если изменение стоимости товара имеет какие-то признаки типа акция, то возможно добавление поля: 
promo bit --значение 1 - это акционная стоимость, иначе 0 - простое изменение цены
Если признаки изменения носят более обширный характер, но могут иметь систематизированный вид, то можно вместо promo ввести
stock_id number --id справочника причины изменения цены, сами расшифровки хранятся в отдельной таблице

Но скорее всего я бы разделил на две таблицы. 
Первая это просто таблица товаров из двух столбцов
items (
item_id number, 
item_name varchar(255), 
);
Вторая - это таблица исторической стоимости товаров
cost_items (
item_id number, 
item_cost number, 
date_begin date, 
date_end date 
);
столбцы promo или stock_id - не обязательны в минимальном наборе
_______________________________________________________________________________________________________________________________________________________________________________________________________________

Вопрос 3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
 DEPARTMENT_NAME,
 SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID = NULL
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
 AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME

ОТВЕТ.
а) Если требуется только поправить ошибки запроса, тогда ответ:
SELECT D.DEPARTMENT_ID, /* необходимо указание из какой таблицы столбец DEPARTMENT_ID */
 DEPARTMENT_NAME,
 SUM(SALARY) as TOTAL_SALARY
FROM EMPLOYEES E, /* в начальном условии объявлена таблица employees, т.е. в конце названия есть буква ""s"" */
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID is NULL /* независимо от значения параметра SET ANSI_NULLS, такое условие всегда отрабатывает одинаково в отличие от условия ""= NULL"" */
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
GROUP BY D.DEPARTMENT_ID, DEPARTMENT_NAME /* не хватает группировки по D.DEPARTMENT_ID */
HAVING SUM(SALARY) > 100000 /* по-моему мнению, когда в задаче написано ""более"", то это знак "">"" */

б) Если придираться к тому, что в задаче написано ""Необходимо получить все отделы, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000"", то нам достаточно только названия отдела и ответ:
SELECT DEPARTMENT_NAME
FROM EMPLOYEES E,
 DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
 AND MANAGER_ID is NULL
 AND LOCATION_ID = (SELECT LOCATION_ID
 FROM LOCATIONS
 WHERE CITY = 'SEOUL')
GROUP BY DEPARTMENT_NAME
HAVING SUM(SALARY) > 100000
_______________________________________________________________________________________________________________________________________________________________________________________________________________

Вопрос 4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?

ОТВЕТ.
а) самое простое объяснение - потому что я не нахожусь в той комнате, где находится карандаш. Т.к. обычно слово некоторый/некоторой означает, что данное понятие точно не определено.
б) а так можно изобрести любые другие ответы - ""потому что я сплю"", ""потому что я не умею/нет сил прыгать"", ""потому что карандаш закатился под плинтус"" и т.д. и т.п.",
177,94.1.pdf,.pdf,pdf,"Чудинова Анна
https://colab.research.google.com/drive/14VHUlTWiopWKcG79gSMqmW-YuwDt-cMF?usp=sharing
 1. clients
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал
один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача
провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки. Вы обратили
внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент
(в интерфейсе выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –-дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным?
 Ответ
Я бы предложила немного изменить таблицу.
Для начала необходимо:
столбец с возрастом клиента age заменить на столбец с информацией о дате рождения клиента. Так, со временем
актуальность данных не пропадет;
также стоит добавить колонку с номером телефона или email для связи с клиентом или рассылки информации. Эта же
информация может пригодиться для сброса пароля.
Дополнительно можно улучшить:
добавить атрибут PRIMARY KEY к столбцу с уникальными id клиентов. Так, мы гарантируем уникальность id клиента;
добавить атрибут UNIQUE колонкам, поля которых также должны быть уникальными – login, email. Причем можно
опционально добавить NOT NULL, если необходимо, чтобы поле обязательно было заполнено.
Таблица имеет следующую схему:
clients (
client_id number PRIMARY KEY, -- уникальный id клиента
client_name varchar(255), -- имя клиента
client_surname varchar(255), -- фамилия клиента
login varchar(30) UNIQUE NOT NULL, -- уникальный логин, который придумал клиент
email varchar(255) UNIQUE NOT NULL -- уникальный email
city_id number, -- id города, который указал клиент
(в интерфейсе выбирается название города, а в таблицу сохраняется id)
birth_date date, -- возраст клиента
reg_date date -- дата регистрации на сайте
);
 2. SCD
Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин. До вас в этой компании уже работал
один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача
провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки. Вы обратили
внимание на таблицу с информацией о товарах магазина. Таблица имеет следующую схему:

items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может
меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы
знаете что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранение стоимости товара?
 Ответ
В первую очередь необходимо обеспечить историчность данных. Для этого используем метод SCD2 и создадим отдельную
таблицу с ценами, а всю информацию о товаре (item_name) выделим в отдельную таблицу.
Таблицы будут выглядеть следующим образом:
для активных записей в столбце item_cost_date_to цена будет установлена по умолчанию, например, 01.01.9999
для удобства можно добавить столбец is_active для обозначения актуальных цен, что может облегчить поиск нужной
информации
items_costs (
id number PRIMARY KEY, -- уникальный id записи
item_id number, -- уникальный id товара
item_cost number, -- стоимость товара
start_dt date, -- дата установки стоимости товара
end_dt date default '01.01.9999', -- дата, до которой актуальна стоимость товара
is_active -- '1' - если запись актуальна, иначе 0
);
items (
id number PRIMARY KEY, -- уникальный id товара
item_name varchar(255), -- наименование товара
…
);
Также, в задаче упоминаются сезонные акции. Для записи информации об акциях можно добавить соответствующую таблицу, а в
items_costs добавить столбец ivent_id:
items_costs (
id number PRIMARY KEY, -- уникальный id записи
item_id number, -- уникальный id товара
ivent_id number, -- уникальный id акции или NULL, если цена установлена вне акции
item_cost number, -- стоимость товара
start_dt date, -- дата установки стоимости товара
end_dt date end_dt, -- дата, до которой актуальна стоимость товара
is_active -- '1' - если запись актуальна, иначе 0
);
items (
id number PRIMARY KEY, -- уникальный id товара
item_name varchar(255), -- наименование товара
…
);
ivents (
id number PRIMARY KEY, -- уникальный id акции
ivent_name varchar(255), -- наименование акции
start_dt date, -- дата начала акции
end_dt date, -- последний день акции
info varchar(255), -- краткая информация
);

Ошибки в коде

Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations. Необходимо получить все отделы0,
расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000. Для
решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
 Ответ
добавила left join
везде для точного определения колонок прописала их принадлежность к таблицам:
предполагаю, что информация о названии отдела и location_id - в таблице departments
информация и зарплатах и наличии менеджера у сотрудников - в employees employees, departments и locations
MANAGER_ID IS NULL вместо =
исправила ошибку в названии таблицы employees
LOCATION_ID IN (подзапрос)
прописала все столбцы, идущие в SELECT до аггрегации, в GROUP BY
после group by данные фильтруются с помощью HAVING
так как по условию необходимы отделы с суммарной зарплатой определенных сотрудников больше 100000, то поставила
оператор >
SELECT E.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) TOTAL_SALARY
FROM EMPLOYEES E
LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL
AND D.LOCATION_ID IN (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
GROUP BY E.DEPARTMENT_ID,
D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) > 100000;
 Карандаш
В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Ответ
Я нахожусь в другой комнате или даже в здании напротив таким образом, что вижу карандаш, но добраться до него не могу.
Или:
Карандаш на самом деле представляет собой какой-то огромный объект (скульптуру), который я не могу физически
перепрыгнуть.",
178,94.2.txt,.txt,text,"В файле есть ссылка на Colab c текстом и SQL кодом:
https://colab.research.google.com/drive/14VHUlTWiopWKcG79gSMqmW-YuwDt-cMF?usp=sharing",
179,95.1.png,.png,ocr,"Задание 1.

Если работать с существующей архитектурой, то:

1. Следует переопределить типы данных в числовых атрибутах:
а. “client_id” на bigint;
b. “city_id” Ha integer;
с. “age” Ha smallint(ecnu субд He “postgresql” - tinyint );

2. Оптимизировать атрибуты Client_name, client_surname уменьшив
кол-во символов

3. Если данные для авторизации клиента размещены в другой
таблице, то стоит убрать атрибут “login” из этой.

4. Если такой таблицы нет, то необходимо добавить поле
(“password” с типом varchar(64) )

A так, я бы разделил персональные дынные пользователей и данные
авторизации:
1. Таблица для авторизации содержала бы UserID, login,
password(varchar(64)), role(“client” || “service-manager” || “admin”
2. Таблица персональных данных с UserID, Fname(varchar(50)),
Sname(varchar(50)), email?(varchar(50)),
current_phone_number(varchar(20)).

|...)

Если у царя-батюшки имеются какие-то амбиции, планы на
расширение, то в качестве атрибута UserlD можно использовать:
1. ЧУЮ с соответствующим типом данных - чу;

2. Составной РК, с по\_пи!-атрибутами, например,
reg_phone_number и id_city/reg_data (varchar(20), (integer/date))
Если их нет, то обычного bigint primary key generate always as identity

для автоинкрементного UserlD(bigint) хватит.

Задание 2.
Из таблицы items удалил бы item_cost.
Добавил бы таблицу costs_history, в которой определил поля
item_id(int nn), price_start_date(date nn), item_cost(integer пп),
multiplier(real).
РК был составным(ид товара + дата начала действия цены).

Следом добавил бы скрипт, написанный, например, на питоне,
который будет добавлять запись и указывать в ней множитель в
соответствии с текущей датой и достижением ранее
установленного где-то периода проведения акций и
соответствующим множителем.

“Где-то” - еще одна таблица в этой же бд с назв, пер.проведения и
коэф",
180,95.2.png,.png,ocr,"Задание 3.
select dapertment_name, sum(salary) as total_salary
from departments d, employees e
where e.department_id = d.department_id
and e.manager_id is null
and d.location_id in (select location_id from locations
where city = ‘seoul’)
group by department_name
having total_salary > 100000;

select department_name from departments d
inner join employees e

on e.department_id = d.department_id
inner join locations |

on |.location_id = d.location_id
where |.сКу = ‘seoul’

and e.manager_id is null

group by department_name
having sum(e.salary) > 100000;

Задание 4.
Потому что комната расположена выше этажом
Потому что я не успел добраться до нее и его, вероятно, уже подняли",
181,96.1.docx,.docx,docx,"1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что повашему
мнению некорректно и какие изменения внесли бы.
РЕШЕНИЕ
1. В таблице дается явное указание, что сlient_id number уникальное значение.
Из чего логично сделать вывод, что данное поле должно являться первичным ключом
2. Логичным было бы добавить ограничение NOT NULL для основных полей: login, client_name,
client_surname.
3. Сделать поле ligin уникальным, чтобы далее иметь возможность добавление индексов,
ускоряя выборку данных при их разрастании на сотни тысяч-миллионы строк
4. Вместо возраста, стоит заменить на дату рождения, поскольку возраст обновляется каждый
год и это требует постоянной перезаписи, что несет лишнюю нагрузку
5. Есть вопросы по city_id, упоминается что в интерфейсе можно выбрать название города, но
нет ссылки на другую таблицу с этими самыми городами. Не уверен что стоит сразу бросаться
и делать REFERENCES на эту неизвестную таблицу.
В качестве предложений по переустройству таблицу, хотел бы предложить следующее решение:
clients (
client_id NUMBER PRIMARY KEY,
client_name VARCHAR(255) NOT NULL,
client_surname VARCHAR(255) NOT NULL,
login VARCHAR(30) NOT NULL UNIQUE,
city_id NUMBER NOT NULL,
birth_date DATE NOT NULL;
Индексы используем для поля login
CREATE INDEX idx_clients_login ON clients(login);
Комментарии по факту изменений:
1. Добавлен первичный ключ (PRIMARY KEY) для client_id
2. Сделаны ограничения NOT NULL для полей client_name, client_surname, birth_date и тд
3. Чтобы иметь возможность в дальнейшем использовать индексы, поле login сделал уникальным
4. Заменено поле age на birth_date
5. Создан индекс для поля login
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
);
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть отдел
финансовой отчётности, в котором сотрудникам нужно строить различныотчёты (о доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое хранениестоимости
товара?
РЕШЕНИЕ
1. Основная проблема - хранение цен. Поскольку мы меняем цены динамические, а текущая
схема может хранить только одну цену товара, то при попытке аналитике с данными цен у нас
возникнет проблема.
В качетстве предложения по улучшению, я бы предложил вынести блок с ценами в отдельную
таблицу, таким образом это нам поможет реализовать механизм хранения истории цен
CREAETE TABLE item_prices (
item_id NUMBER,
price NUMBER NOT NULL,
date_from DATE NOT NULL,
date_to DATE,
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Комментарий по факту изменений:
1. Модифицировали основную таблицу товаров items убрав поле с ценой
2. Создали таблицу цен с датами изменений, которая позволит: хранить записи о ценах для
товаров, возможность легко определить цену с привязкой к конкртеной дате
3. Актуальная (текущая) цена товара будет храниться в записи, где поле date_from содержит
дату начала действия этой цены, а поле date_to содержит NULL. Это означает, что данная
цена действует с указанной даты и до сих пор.
P.S. В процессе размышлений понял, что мы храним дату исключительно с привязкой к дате, но
не ко времени. Логично, что в условиях множественных скачков цен, нам необходимо иметь
возможность взять цену не только по дням, но и по часам.
CREAETE TABLE item_prices (
item_id NUMBER,
price NUMBER NOT NULL,
date_from TIMESTAMP NOT NULL,
date_to TIMESTAMP,
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
С такой структурой мы сможем хранить историю изменения цен с точностью до секунд, что
позволит корректно отслеживать несколько изменений цены в течение одного дня.
Принцип работы остается прежним:
При изменении цены мы закрываем предыдущую запись, устанавливая в поле date_to текущую
дату и время, далее создаем новую запись с новой ценой, где date_from - текущая дата и
время, а date_to - NULL.
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
РЕШЕНИЕ
Замечания к уже написанному коду:
1. Таблица исходно называется EMPLOYEES, а в данном случае EMPLOYEE, опечатка?
2. Условние MANAGER_ID = NULL не корректно. Для штатной проверки на условие заменить на
MANAGER_ID IS NULL;
3. Функция SUM нельзя использовать в предложении WHERE, требуется убрать в условие HAVING
после группировки (GROUP BY)
4. Логично было бы включить ВСЕ СТОЛБЦЫ в GRIOUP BY, которые есть в выборке SELECT, а не
только DEPARTMENT_NAME
5. Для связи таблиц используем JOIN
Исправленный вариант будет выглядеть:
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?
РЕШЕНИЕ
Мы не можем перепрыгнуть карандаш, поскольку его уронили в ""некоторой комнате"", конкретно
в какой мы не знаем. А еще, тут требуется уточнить, перепрыгнуть что именно, карандаш или
пол? Пол перепрыгнуть нельзя априори.",
182,96.2.pdf,.pdf,pdf,"1. Представьте, что вы устроились работать Дата-инженером в некоторый интернет
магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся
покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что
повашему
мнению некорректно и какие изменения внесли бы.
РЕШЕНИЕ
1. В таблице дается явное указание, что сlient_id number уникальное значение.
Из чего логично сделать вывод, что данное поле должно являться первичным ключом
2. Логичным было бы добавить ограничение NOT NULL для основных полей: login,
client_name,
client_surname.
3. Сделать поле ligin уникальным, чтобы далее иметь возможность добавление индексов,
ускоряя выборку данных при их разрастании на сотни тысяч-миллионы строк
4. Вместо возраста, стоит заменить на дату рождения, поскольку возраст обновляется
каждый
год и это требует постоянной перезаписи, что несет лишнюю нагрузку
5. Есть вопросы по city_id, упоминается что в интерфейсе можно выбрать название
города, но
нет ссылки на другую таблицу с этими самыми городами. Не уверен что стоит сразу
бросаться
и делать REFERENCES на эту неизвестную таблицу.
В качестве предложений по переустройству таблицу, хотел бы предложить следующее
решение:

clients (
client_id NUMBER PRIMARY KEY,
client_name VARCHAR(255) NOT NULL,
client_surname VARCHAR(255) NOT NULL,
login VARCHAR(30) NOT NULL UNIQUE,
city_id NUMBER NOT NULL,
birth_date DATE NOT NULL;
Индексы используем для поля login
CREATE INDEX idx_clients_login ON clients(login);
Комментарии по факту изменений:
1. Добавлен первичный ключ (PRIMARY KEY) для client_id
2. Сделаны ограничения NOT NULL для полей client_name, client_surname, birth_date и тд
3. Чтобы иметь возможность в дальнейшем использовать индексы, поле login сделал
уникальным
4. Заменено поле age на birth_date
5. Создан индекс для поля login
2. Представьте, что вы устроились работать Дата-инженером в некоторый интернет
магазин.
До вас в этой компании уже работал один разработчик, который придумал небольшую
базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести
проверку существующей архитектуры и решить корректна ли она илиможно внести
некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
);
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если
не каждый
день, то каждый месяц может меняться. К примеру, сезонные повышения цен или
наоборот скидки
(перед началом учебного года или новым годом). Так же вы знаете что у магазина есть
отдел

финансовой отчётности, в котором сотрудникам нужно строить различныотчёты (о
доходах
например) за разные промежутки времени, в том числе и за прошлые месяцы и даже
прошлые года.
Как бы вы доработали архитектуру таблицы, что бы обеспечить историческое
хранениестоимости
товара?
РЕШЕНИЕ
1. Основная проблема - хранение цен. Поскольку мы меняем цены динамические, а
текущая
схема может хранить только одну цену товара, то при попытке аналитике с данными цен у
нас
возникнет проблема.
В качетстве предложения по улучшению, я бы предложил вынести блок с ценами в
отдельную
таблицу, таким образом это нам поможет реализовать механизм хранения истории цен
CREAETE TABLE item_prices (
item_id NUMBER,
price NUMBER NOT NULL,
date_from DATE NOT NULL,
date_to DATE,
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
Комментарий по факту изменений:
1. Модифицировали основную таблицу товаров items убрав поле с ценой
2. Создали таблицу цен с датами изменений, которая позволит: хранить записи о ценах
для
товаров, возможность легко определить цену с привязкой к конкртеной дате
3. Актуальная (текущая) цена товара будет храниться в записи, где поле date_from
содержит
дату начала действия этой цены, а поле date_to содержит NULL. Это означает, что данная
цена действует с указанной даты и до сих пор.
P.S. В процессе размышлений понял, что мы храним дату исключительно с привязкой к
дате, но

не ко времени. Логично, что в условиях множественных скачков цен, нам необходимо
иметь
возможность взять цену не только по дням, но и по часам.
CREAETE TABLE item_prices (
item_id NUMBER,
price NUMBER NOT NULL,
date_from TIMESTAMP NOT NULL,
date_to TIMESTAMP,
FOREIGN KEY (item_id) REFERENCES items(item_id)
);
С такой структурой мы сможем хранить историю изменения цен с точностью до секунд,
что
позволит корректно отслеживать несколько изменений цены в течение одного дня.
Принцип работы остается прежним:
При изменении цены мы закрываем предыдущую запись, устанавливая в поле date_to
текущую
дату и время, далее создаем новую запись с новой ценой, где date_from - текущая дата и
время, а date_to - NULL.
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не
имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME

РЕШЕНИЕ
Замечания к уже написанному коду:
1. Таблица исходно называется EMPLOYEES, а в данном случае EMPLOYEE, опечатка?
2. Условние MANAGER_ID = NULL не корректно. Для штатной проверки на условие
заменить на
MANAGER_ID IS NULL;
3. Функция SUM нельзя использовать в предложении WHERE, требуется убрать в условие
HAVING
после группировки (GROUP BY)
4. Логично было бы включить ВСЕ СТОЛБЦЫ в GRIOUP BY, которые есть в выборке
SELECT, а не
только DEPARTMENT_NAME
5. Для связи таблиц используем JOIN
Исправленный вариант будет выглядеть:
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, SUM(E.SALARY) AS
TOTAL_SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000;
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через
него перепрыгнуть?
РЕШЕНИЕ
Мы не можем перепрыгнуть карандаш, поскольку его уронили в ""некоторой комнате"",
конкретно
в какой мы не знаем. А еще, тут требуется уточнить, перепрыгнуть что именно, карандаш
или
пол? Пол перепрыгнуть нельзя априори.",
183,97.docx,.docx,docx,"В таблице представлены 7 столбцов:
client_id – id клиента, тип INT, уникальное значение;
client_name – имя клиента, тип VARCHAR;
client_surname – фамилия клиента, тип VARCHAR;
login – логин, тип VARCHAR;
city_id – id города
age – возраст, тип INT
reg_date – дата регистрации, тип DATE.
Предлагается рассмотреть следующие возможные изменения:
Значение столбца login также сделать уникальным, чтобы не происходило повторений.
Для значений name, surname, login добавить ограничение на NOT NULL.
Заменить столбец city_id на city_name с типом VARCHAR, в котором будет указан не id города, а название. 
Либо оставить city_id, но создать вторую таблицу cities, где будут два столбца: city_id (первичный ключ) и city_name – и связать эти таблицы через внешний ключ city_id.
Уменьшить объём выделенной памяти для полей client_name и client_surname до 100 и увеличить для login до 100.
Столбец age изменить на birth_date с типом DATE, так как возраст меняется с каждым годом.
Добавить столбец с email или номером телефона(не обязательный к заполнению)
2. Представлена таблица items, включающая 3 столбца:
item_id – id товара, уникальное значение, тип INT
item_name – наименование товара, тип VARCHAR
item_cost – цена товара, тип INT
Возможные изменения:
Значение item_cost удалить из таблицы.
Взамен создать таблицу, которая будет содержать информацию о цене – item_price_history. Таблица будет содержать 4 столбца: item_id для связи с первой таблицей, price – цена, start_date – день начала действия цены, end_date – последний день действия цены.
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть. Существует учебная схема HR, содержащая таблицы: employees, departments и locations. Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
SELECT
d.department_id,
d.department_name,
SUM(e.salary) AS total_salary
FROM departments d
JOIN employees e ON e.department_id = e.department_id
JOIN locations l ON l.location_id = d.location_id
WHERE e.manager_id IS NULL
AND LOWER(l.city) = 'seoul'
GROUP BY d.department_name, d.department_id
HAVING SUM(e.salary) > 100000;
4. В некоторой комнате на пол уронили карандаш. Объясните почему вы не можете через него перепрыгнуть?
Не до конца обозначены условия, где на полу лежит карандаш: в середине комнаты, перед стеной или комодом?",
184,98.docx,.docx,docx,"ЗАДАНИЕ 1
Представьте, что вы устроились работать Дата-инженером в некоторый интернет-магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о зарегистрировавшихся покупателях (клиентах).
Таблица имеет следующую схему:
clients (
client_id number, --уникальный id клиента
client_name varchar(255), --имя клиента
client_surname varchar(255), --фамилия клиента
login varchar(30), --логин, который придумал клиент
city_id number, --id города, который указал клиент (в интерфейсе
выбирается название города, а в таблицу сохраняется id)
age number, --возраст клиента
reg_date date –дата регистрации на сайте
);
Считаете ли вы данный набор и смысл полей корректным? Если нет, то напишите что по вашему мнению некорректно и какие изменения внесли бы.
РЕШЕНИЕ
Атрибут client_id является первичным ключом таблицы, поэтому он должен быть уникальным и не иметь NULL-значений. При использовании типа данных number за выполнением этих условий придется следить самостоятельно. Я бы заменил его на SERIAL для простоты вставки новых записей.
Для полей client_name и client_surname тип данных varchar(255) выглядит избыточным. Мне трудно представить имя длиной в 255 символов. Возможно, стоит ограничиться, например, varchar(50).
Если по полю login возможна идентификация пользователя (допустим, он может войти по комбинации логин+пароль), то оно должно быть уникально.
Вместо поля с возрастом клиента лучше хранить дату рождения. У нас остается возможность использовать текущий возраст (рассчитываем через код вида (current_date – date_birth)/365)), и при этом данные не будут устаревать. Возраст человека меняется каждый год, а дата рождения – нет.
Для reg_date я бы использовал точное время регистрации, а не только дату. т.е. TIMESTAMP вместо DATE.
Я бы подумал в сторону того, что делать с удаленными клиентами. В текущей реализации, если клиент удалил аккаунт, мы можем или продолжить хранить о нем информацию в БД, или полностью удалить. Возможно, стоит добавить дополнительное поле, которое будет показывать, активен ли клиент. Например, is_active (TRUE или FALSE).
ЗАДАНИЕ 2
Представьте, что вы устроились работать Дата-инженером в некоторый интернет- магазин. До вас в этой компании уже работал один разработчик, который придумал небольшую базу данных для этого магазина и потом неожиданно уволился. Ваша задача провести проверку существующей архитектуры и решить корректна ли она или можно внести некоторые доработки.
Вы обратили внимание на таблицу с информацией о товарах магазина.
Таблица имеет следующую схему:
items (
item_id number, --уникальный id товара
item_name varchar(255), --наименование товара
item_cost number –стоимость товара
);
Глядя на эту таблицу вы вспоминаете, что мы живём в рыночной экономике и цена, если не каждый день, то каждый месяц может меняться. К примеру, сезонные повышения цен или наоборот скидки (перед началом учебного года или новым годом). Так же вы знаете, что у магазина есть отдел финансовой отчётности, в котором сотрудникам нужно строить различны отчёты (о доходах, например) за разные промежутки времени, в том числе и за прошлые месяцы и даже прошлые года.
Как бы вы доработали архитектуру таблицы, чтобы обеспечить историческое хранение стоимости товара?
РЕШЕНИЕ
Аналогично, item_id является PK, поэтому тип данных я бы изменил на SERIAL.
Если цена может изменяться и при этом для отчетности важно хранить историю ее изменений, я бы вынес “ценообразующую” часть в отдельную таблицу.
Т.е. в таблице items атрибут item_cost удаляем. Тогда, если нам понадобится найти цену товара за определенный период, мы можем сделать JOIN с этой таблицей, и по условию where нужная_дата between date_from and coalesce(date_to, current_date), получить актуальную цену.
ЗАДАНИЕ 3
3. Требуется проверить запрос на корректность и исправить там ошибки, если они есть.
Существует учебная схема HR, содержащая таблицы: employees, departments и locations
Необходимо получить все отделы0, расположенные в Сеуле в которых все сотрудники, не имеющие менеджера, зарабатывают в общей сложности более 100000.
Для решения задачи был написан следующий запрос:
SELECT DEPARTMENT_ID,
DEPARTMENT_NAME,
SUM(SALARY) TOTAL_SALARY
FROM EMPLOYEE E,
DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND MANAGER_ID = NULL
AND LOCATION_ID = (SELECT LOCATION_ID
FROM LOCATIONS
WHERE CITY = 'SEOUL')
AND SUM(SALARY) >= 100000
GROUP BY DEPARTMENT_NAME
РЕШЕНИЕ
При чтении запроса, можно заметить следующие неточности синтаксиса:
Некорректно написан JOIN таблиц EMPLOYEE и DEPARTMENTS. Я бы использовал стандартный синтаксис вида JOIN … ON …
В данном случае
Некорректно выполняется сравнение с NULL-значением. В SQL используется трехзначная логика, сравнение c NULL через = или <> даст UNKNOWN и строка будет в любом случае отброшена. В условии задачи сказано найти сотрудников, у которых менеджер отсуствует, для этого правильнее использовать IS NULL.
В данном случае:
В GROUP BY потеряно поле department_id. Так как мы используем агрегатную функцию SUM, все остальные столбцы (без агрегатных функций) из SELECT должны быть перечислены в GROUP BY.
В данном случае:
4. Фильтрация по агрегатному результату нужно вынести в HAVING, чтобы она выполнялась ПОСЛЕ GROUP BY.
В данном случае:
5*. Регистр для названий таблиц, атрибутов. Не ошибка, но я бы поправил его на lowercase для повышения читабельности, т.е. заглавными буквами оставляем только ключевые слова.
ЗАДАНИЕ 4
В некоторой комнате на пол уронили карандаш. Объясните, почему вы не можете через него перепрыгнуть?
РЕШЕНИЕ
Через карандаш я не могу перепрыгнуть, потому что он лежит у стены, прыгать сквозь которые я пока не в состоянии. Надеюсь, что после прохождения курса в учебном центре Neoflex такие испытания не будут для меня преградой.
item_price_history (
item_id NUMBER -- FK → items(item_id)
, price NUMBER -- цена в этот момент
, date_from DATE -- дата/время начала действия
, date_to DATE -- дата/время окончания действия (NULL для актуальной)
);
SELECT …
FROM EMPLOYEE E 
JOIN DEPARTMENTS D 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
…
…
AND MANAGER_ID IS NULL 
…
SELECT D.DEPARTMENT_ID, 
D.DEPARTMENT_NAME, 
SUM(SALARY) TOTAL_SALARY 
…
GROUP BY D.DEPARTMENT_ID, 
D.DEPARTMENT_NAME
WHERE …
GROUP BY …
HAVING SUM(e.salary) > 100000",
185,99.docx,.docx,docx,"1.
Для полей “client_id” и “city_id” не требуется плавающая точка, поэтому стоит использовать “integer” или “bigint”, чтобы избежать переполнения.
Так как “city_id” скорее всего является внешним ключом, то для изменения типа следует поменять также изменить тип в родительской таблице.
Так как поле “login” должно быть уникальным, то для этого поля должно быть ограничение уникальности.
Для поля age использование типа “number” является избыточным. Лучше использовать “smallint”, так как для возраста не требуется большого диапазона.
2.
Чтобы хранить историческую информацию о ценах на продукты, можно создать еще одну таблицу для отслеживания изменений цен, например “item_price_history”. Она должна содержать следующие поля:
item_price_history (
price_history_id number, -- id записи истории
item_id number, -- id товара, для которого хранятся изменения
price number, -- стоимость товара
change_date date, -- дата изменения цены
);
Для таблицы “items” можно поменять название поля “item_cost” на “item_current_cost” для лучшего понимания, что в нем хранится именно текущая цена.
3.
Для проверки на “NULL” необходимо использовать “IS NULL”.
Использование агрегатной функции “SUM(SALARY)” в “WHERE” некорректно. Оно должно быть помещено в “HAVING” после группировки.
В “GROUP BY” указан только “DEPARTMENT_NAME”, но в “SELECT” также находится “DEPARTMENT_ID”. Следует либо исключить “DEPARTMENT_ID” из “SELECT” либо добавить его в “GROUP BY”.
Для упрощения запроса можно исправить подзапрос с выбором местоположения на инструкцию “JOIN”.
Исправленный запрос будет выглядеть следующим образом:
SELECT
D.DEPARTMENT_ID,
D.DEPARTMENT_NAME,
SUM(E.SALARY) AS TOTAL_SALARY
FROM
EMPLOYEES E
JOIN
DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN
LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE
E.MANAGER_ID IS NULL
AND L.CITY = 'SEOUL'
GROUP BY
D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING
SUM(E.SALARY) > 100000;
4.
Я не могу перепрыгнуть через карандаш, потому что он лежит у стены.",
